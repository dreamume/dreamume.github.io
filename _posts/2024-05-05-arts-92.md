---
layout:     post
title:      "Weekly 092"
subtitle:   "Algorithm: Last Stone Weight II; Review: Receiving and Handling Events with Combione; Tips: ; Share: "
thumbnail-img: ""
date:       2024-05-05 20:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org9445a5f)
2.  [Review](#orgc847c2c)
    1.  [概述](#org810f380)
    2.  [连接一个发布者到一个订阅者](#orgef97a46)
    3.  [用操作改变 Output 类型](#orgeb64d91)
    4.  [用操作自定义发布者](#org95fb904)
    5.  [当需要时取消发布](#orgebffcee)
3.  [Tips](#orga8dc91d)
4.  [Share](#orga1fac9c)


<a id="org9445a5f"></a>

# Algorithm

Leetcode 1049: [Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/)

<https://dreamume.medium.com/leetcode-1049-last-stone-weight-ii-dc844919f6b5>


<a id="orgc847c2c"></a>

# Review

[Receiving and Handling Events with Combine](https://developer.apple.com/documentation/combine/receiving-and-handling-events-with-combine)


<a id="org810f380"></a>

## 概述

Combine 框架提供一个应用程序如何处理事件的声明式方案。不是潜在地实现多个代理回调或完成处理闭包，你可对一个给定事件源创建一个单处理链。链的每个部分是一个 Combine 操作从接收到的上一个步骤中执行一个在元素上执行一个不同的行为

考虑一个应用程序需要过滤一个表或基于文本框内容的 collection view。在 AppKit 中，文本框的每个敲键产生一个通知你可用 Combine 订阅。在收到通知后，你可使用操作来改变内容和发起事件转发，且使用最后的结果更新你的应用程序用户接口


<a id="orgef97a46"></a>

## 连接一个发布者到一个订阅者

为用 Combine 接收文本框的通知，访问 NotificationCenter 的缺省实例并调用它的 publisher(for:object:) 方法。这个调用携带通知名称和你想要通知的源对象，并返回产生通知元素的一个发布者

    let pub = NotificationCenter.default.publisher(for: NSControl.textDidChangeNotification, object: filterFeild)

你使用一个订阅者来接收来自发布者的元素。订阅者定义一个相关类型，Input，来声明它接收的类型。发布者也定义一个类型，Output，来声明它产生的结果。发布者和订阅者都定义一个类型，Failure，来显示它们产生或接收的错误类型。为连接一个订阅者到一个生产者，Output 必须匹配 Input，且 Failure 类型也必须匹配

Combine 提供两个内建的订阅者，其自动匹配其接触的发布者的 output 和 failure 类型：

-   sink(receiveCompletion:receiveValue:) 带两个闭包。第一个闭包当它接收到 Subscribers.Completion 时执行，其是一个列举显示是否发布者正常结束或失败。第二个闭包当它从发布者接收到一个元素时执行
-   assign(to:on:) 立即赋值它接收到的每个元素到一个给定对象的一个属性，使用键路径表示其属性

例如，你可使用 sink 订阅者在发布者完成时记日志，且每次它接收一个元素：

    let sub = NotificationCenter.default.publisher(for: NSControl.textDidChangeNotification, object: filterField).sink(receiveCompletion: { print ($0) }, receiveValue: { print ($0) })

sink(receiveCompletion:receiveValue:) 和 assign(to:on:) 订阅者都从它们的发布者那请求无限制数目的元素。为控制你接收到元素的速度，需要通过实现订阅者协议创建你自己的订阅者


<a id="orgeb64d91"></a>

## 用操作改变 Output 类型

前面提到的 sink 订阅者在 receiveValue 闭包里执行它所有的工作。这可能有点繁重如果它在接收元素或维持调用状态间需要执行大量自定义工作。Combine 的优点是组合操作来自定义事件转发

例如，NotificationCenter.Publisher.Output 在回调中不是一个方便的类型如果所有你需要的是文本框的字符串值。因为一个发布者的 output 时间上的一系列元素，Combine 提供序列修改操作如 map(\_ :), flatMap(maxPublishers:\_ :) 和 reduce(\_: \_:)。这些操作的行为和它们在对应的 Swift 标准库中相似

为改变发布者的 output 类型，你添加一个 map(\_ :) 操作，其返回一个不同的类型。这样，你可获得通知对象为一个文本框，然后获得文本框的字符串值

    let sub = NotificationCenter.default.publisher(for: NSControl.textDidChangeNotification, object: filterField).map( {($0.object as! NSTextField).stringValue }).sink(receiveCompletion: { print ($0) }, receiveValue: { print ($0) })

在发布者链产生你想要的类型后，替换 sink(receiveCompletion:receiveValue:) 为 assign(to:on:)。以下例子获得从发布者链中的字符串并赋值它们到自定义 view model 对象的 filterString：

    let sub = NotificationCenter.default.publisher(for: NSControl.textDidChangeNotification, object: filterField).map( {($0.object as! NSTextField).stringValue }).assign(to: \MyViewModel.filterString, on: myViewModel)


<a id="org95fb904"></a>

## 用操作自定义发布者

你可用一个操作执行行为来扩展发布者实例，否则需要手动写代码。有三种办法你可使用操作来改进事件处理链：

-   相比用输入到文本框的任意字符串更新视图模型，你可以使用 filter(\_ :) 操作来忽略某个长度以下的输入或拒绝非字母数字字符
-   如果过滤操作成本高，例如，如果它查询一个大型数据库 - 你可能想要等待用户停止输入。这样，debounce(for:scheduler:options:) 操作让你设置一个小的时间区间必须达到发布者才能触发一个事件。RunLoop 类提供方便的方法用秒或毫秒指定时间间隔
-   如果结果更新了 UI，你可转发回调到主线程通过调用 receive(on:options:) 方法。通过 RunLoop 类指定的Scheduler 实例作为第一个参数，你可告诉 Combine 在主 RunLoop 上调用你的订阅者

这样的发布者声明如下：

    let sub = NotificationCenter.default
    .publisher(for: NSControl.textDidChangeNotification, object: filterField)
    .map( {($0.object as! NSTextField).stringValue })
    .filter( {$0.unicodeScalars.allSatisfy({CharacterSet.alphanumerics.contains($0)}) } )
    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)
    .receive(on: RunLoop.main)
    .assign(to: \MyViewModel.filterString, on: myViewModel)


<a id="orgebffcee"></a>

## 当需要时取消发布

一个发布者持续触发直到它正常完成或失败。如果你不再想要订阅发布者，你可取消订阅。sink(receiveCompletion:receiveValue:) 和 assign(to:on:) 创建的订阅者类型都实现了 Cancellable 协议，其提供一个 cancel() 方法

    sub?.cancel()

如果你创建一个自定义订阅者，当你第一次订阅它时发布者发送一个订阅对象。存储这个订阅对象，且当你想要取消订阅时调用它的 cancel() 方法。当你创建一个自定义订阅者，你应该实现 Cancellable 协议，且你的 cancel() 实现要转发调用到存储的订阅对象


<a id="orga8dc91d"></a>

# Tips


<a id="orga1fac9c"></a>

# Share


---
layout:     post
title:      "Weekly 053"
subtitle:   "Algorithm: Dual Core CPU; Review: PHYSICAL AUDIO SIGNAL PROCESSING(); Tips: Notes about design patterns; Share: Selection in X+Y and Matrices with sorted rows and columns"
thumbnail-img: ""
date:       2022-02-08 18:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org689ecab)
2.  [Review](#org73a8408)
3.  [Tips](#org5ad50a8)
4.  [Share](#org8748064)
    1.  [简介](#org8a2effb)
    2.  [术语](#orga729741)
    3.  [主要的观察](#org278f898)
    4.  [选择算法](#org6426878)


<a id="org689ecab"></a>

# Algorithm

Dual Core CPU: <http://poj.org/problem?id=3469>

<https://dreamume.medium.com/poj-dual-core-cpu-b8275155abb2>


<a id="org73a8408"></a>

# Review


<a id="org5ad50a8"></a>

# Tips

设计模式之美 - 设计原则与思想：规范与重构

为什么要重构？软件设计大师Martin Fowler是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。“我们可以理解为在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量

首先，重构是时刻保证代码质量的一个极其有效的手段，为避免代码不断增多而导致越来越混乱

其次，优秀的代码或架构不是一开始就能完全设计好的，需要迭代，随着系统的演进，重构不可避免

最后，重构是避免过度设计的有效手段，在遇到问题时再对代码进行重构，避免前期投入太多时间做过度设计

大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等

小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等

比较好的一个策略是持续重构、有时间的时候就可以主动重构

大型重构需要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态

大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，有时间随时可以做

为保证重构不出错，最可落地执行、最有效的保证重构不出错的手段应该就是单元测试

对于大型重构，最有效的一个手段就是解耦，解耦的目的是实现代码高内聚、松耦合

解耦的手段：

-   封装与抽象
-   引入中间层
-   模块化
-   其他设计思想和原则


<a id="org8748064"></a>

# Share

Selection in X+Y and Matrices with sorted rows and columns

<http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf>


<a id="org8a2effb"></a>

## 简介

在本文中我们考虑已排序的行和列的矩阵的选择问题。选择X + Y，X、Y为排序数组，是本问题的特殊例子

设 $ X = (x_ {1}, x_ {2}, \\ldots, x_ {n}) $和 $ Y = (y_ {1}, y_ {2}, \\ldots, y_ {n}) $为两个实数数组。Cartesian和X + Y是 $ n \\times n $矩阵，第ij条目为 $ x_ {i} + y_ {j} $。如果X和Y为排序的，则X + Y是一个按行和列排序后的矩阵。X + Y的选择和其他相关问题已因统计和运筹的应用程序而引起关注。同样该问题出现在一些VLSI设计中

Jefferson, Shamos和Tarjan呈现了在 $ O(n \\log{n}) $时间复杂度内解决选择X + Y的中位数问题。Johnson和Mizoguchi给出一个 $ O(n \\log{n}) $算法选择X + Y中第k小的元素。这两个算法都在算法应用之前排序数组X和Y。尽管需要时间来排序X和Y，这两个算法依然只需要$ O(n \\log{n}) $时间复杂度。Fredericks和Johnson考虑排序列来在矩阵中选择。这些选择X + Y中第k大元素的算法, $ 1 \\le k \\le \\frac{1}{2} n^{2} $，时间复杂度为 $ O(max \\{n, n \\log{(k/n)} \\}) $。他们也给出对已排序行和列的矩阵的选择问题的O(n)时间复杂度算法

设A为一个$ n \\times n $实数矩阵，行和列已排序，设k为一个整数，$ 1 \\le k \\le n^{2} $。我们呈现一个O(n)时间复杂度算法来选择A的第k小元素。本文呈现的算法应用分治技术。这个方法可应用到相似顺序相关问题。例如，我们使用这个技术来获得一个线性时间算法在VLSI中处理频道路由的最佳偏移问题。虽然Frederickson和Johnson算法有一个相似的时间边界，本文呈现的算法更简单。同样我们的算法使用的技术也很实用


<a id="orga729741"></a>

## 术语

设A为一个$ n \\times n $的实数矩阵。A的元素不必不同。我们假设A的行和列索引为$ 1, 2, \\ldots, n $。我们称A为有序的如果每行的元素是非增序，每列元素是非减序。设 $ \\bar{n} = \\lceil \\frac{1}{2} (n+1) \\rceil $。A的子矩阵 $ \\bar{A} $是一个 $ \\bar{n} \\times \\bar{n} $矩阵且被定义为包含奇数索引号行列的A的子矩阵，加上n为偶数时A的最后的行和列。设L为一个实数列表，a为一个实数。我们定义 $ rank^{+} $和 $ rank^{-} $的a在L中如下：

$ rank^{+}(L, a) = \| \\{ x \\in L \| x > a \\} \| $

$ rank^{-}(L, a) = \| \\{ x \\in L \| x < a \\} \| $

假设$ 1 \\le k \\le \| L \| $。则a被定义为L的第k小元素当且仅当$ rank^{-}(L, a) \\le k - 1 $和 $ rank^{+}(L, a) \\le \| L \|  - k $。为简化，本文中我们使用术语L的第k个元素表示L的第k小元素


<a id="org278f898"></a>

## 主要的观察

如下定理是我们的选择算法的基础

**定理3.1** 设A为一个 $ n \\times n $有序矩阵且 $ \\bar{A} $为如之前描述的A的子矩阵。则，对任意实数a，如下不等式成立：

(i) $ rank^{-}(A, a) \\le 4 rank^{-}(\\bar{A}, a) $

(ii) $ rank^{+}(A, a) \\le 4 rank^{+} (\\bar{A}, a) $

证明：我们只证明(i)。(ii)的证法跟(i)相似。设 $ \\bar{A}_ {L} $包含 $ \\bar{A} $小于a的元素，则

$ \| \\bar{A}_ {L} \| = rank^{-}(\\bar{A}, a) $

设 $ A_ {L} $为A的部分包含：

(a) $ \\bar{A}_ {L} $和

(b) 对 $ A_ {ij} \\in \\bar{A}_ {L} $的每个元素，它在 $ A - \\bar{A} $的邻居元素 $ A_ {ij-1}, A_ {i+1, j-1}, A_ {i+1, j} $。因为矩阵A是有序的，$ A_ {L} $包含A的所有小于a的元素。这样

$ \| A_ {L} \| \\ge rank^{-}(A, a) $

通过$ A_ {L} $从 $ \\bar{A}_ {L} $的构造我们有

$ \| A_ {L} \| \\le 4 \| \\bar{A}_ {L} \| $

从这些式子中我们得到 $ rank^{-}(A, a) \\le 4 rank^{-}(\\bar{A}, a) $


<a id="org6426878"></a>

## 选择算法

在描述选择算法细节之前我们呈现一个在 $ n \\times n $有序矩阵A上计算一个实数a的$ rank^{-} $的O(n)时间复杂度算法。$rank^{+} $的计算相似

$ \\begin{array}{l} function \\, rank^{-}(A, a); \\\\ \\qquad begin \\\\ \\qquad \\qquad j = 1; x = 0; \\\\ \\qquad \\qquad \\text{for } i = 1 \\text{ to } n \\text{ do begin} \\\\ \\qquad \\qquad \\qquad \\text{while } j \\le n \\text{ and } A_ {ij} \\ge a \\text{ do } j = j + 1; \\\\ \\qquad \\qquad \\qquad x = x + n - j + 1 \\\\ \\qquad \\qquad \\qquad end; \\\\ \\qquad \\qquad \\qquad \\text{return } x \\\\ \\qquad end; \\end{array} $

如上代码是O(n)时间复杂度计算$ rank^{-}(A, a) $的方法。设pick(L, k)为一个函数，L为一个列表，k为一个整数，$ 1 \\le k \\le \| L \| $，且在 $ O(\| L \|) $时间复杂度上返回L的第k个元素

我们的选择算法的思想是从 $ \\bar{A} $中递归选择两个元素a和b，$ a \\ge b $，使得如下成立：

(1) A的第k个元素在a和b之间

(2) 小于a且大于b的A的元素的个数为O(n)

$ \\begin{array}{l} \\text{function } select(A, k); \\\\ \\qquad begin \\\\ \\qquad \\qquad (x, y) = biselect(n, A, k, k); \\\\ \\qquad \\qquad return x \\\\ \\qquad \\text{end } select; \\end{array} $

$ \\begin{array}{l} \\text{function } biselect(n, A, k_ {1}, k_ {2}); \\\\ \\qquad begin \\\\ 1. \\qquad \\text{if } n \\le 2 \\\\ 2. \\qquad \\text{then } (x, y) = (k_ {1}th \\text{ of } A, k_ {2}th \\text{ of } A) \\\\ \\qquad \\text{else begin} \\\\ 3. \\qquad \\qquad (a, b) = biselect(\\bar{n}, \\bar{A}, \\bar{k}_ {1}, \\bar{k}_ {2}); \\\\ 4. \\qquad \\qquad ra^{-} = rank^{-}(A, a); \\\\ 5. \\qquad \\qquad rb^{+} = rank^{+}(A, b); \\\\ 6. \\qquad \\qquad L = \\{A_ {ij} \| a > A_ {ij} > b \\}; \\\\ 7. \\qquad \\qquad \\text{if } ra^{-} \\le k_ {1} - 1 \\text{ then } x = a \\\\ 8. \\qquad \\qquad \\qquad \\text{else if } k_ {1} + rb^{+} - n^{2} \\le 0 \\text{ then } x = b \\\\ 9. \\qquad \\qquad \\qquad \\qquad \\text{else } x = pick(L, k_ {1} + rb^{+} - n^{2}); \\\\ 10. \\qquad \\qquad \\text{if } ra^{-} \\le k_ {2} - 1 \\text{ then } y = a \\\\ 11. \\qquad \\qquad \\qquad \\text{else if } k_ {2} + rb^{+} - n^{2} \\le 0 \\text{ then } y = b \\\\ 12. \\qquad \\qquad \\qquad \\qquad \\text{else } y = pick(L, k_ {2} + rb^{+} - n^{2}) \\\\ \\qquad \\qquad end; \\\\ 13. \\qquad \\qquad return (x, y) \\\\ \\qquad \\text{end biselect}; \\end{array} $

本文的主要结果是函数select(A, k)，见如上代码，在O(n)时间复杂度内计算一个 $ n \\times n $有序矩阵A的第k个元素。函数select调用递归函数 $ biselect(n, A, k_ {1}, k_ {2}), k_ {1} \\ge k_ {2} $，返回(x, y)，x是 $ n \\times n $矩阵A的第 $ k_ {1} $和 $ k_ {2} $个元素。设 $ \\bar{k}_ {1} $和 $ \\bar{k}_ {2} $定义如下：

$ \\bar{k}_ {1} = \\left\\{ \\begin{array}{cc} n + 1 + \\lceil \\frac{1}{4} k_ {1} \\rceil & \\text{if n is even,} \\\\ \\lceil \\frac{1}{4} (k_ {1} + 2n + 1) \\rceil & \\text{if n is odd} \\end{array} \\right. $

$ \\bar{k}_ {2} = \\lfloor \\frac{1}{4} (k_ {2} + 3) \\rfloor $

$ \\bar{k}_ {1} $被选择为最小的整数使得 $ \\bar{A} $的第 $ \\bar{k}_ {1} $个元素至少和A的第 $ k_ {1} $个元素一样大。$ \\bar{k}_ {2} $被选择为最大的整数使得 $ \\bar{A} $的第 $ \\bar{k}_ {2} $个元素不大于A的第 $ k_ {2} $个元素。算法中，A的第i个相缩写为A的第i个元素。函数biselect的第一个参数n是函数第二个参数所表示的子矩阵的维度。我们假设要么矩阵A在计算之前在内存中，要么A的元素可在需要时被计算。如果A为X + Y的形式，则只有向量X和Y需要在内存中

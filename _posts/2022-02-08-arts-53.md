---
layout:     post
title:      "Weekly 053"
subtitle:   "Algorithm: Dual Core CPU; Review: PHYSICAL AUDIO SIGNAL PROCESSING(); Tips: Notes about design patterns; Share: Selection in X+Y and Matrices with sorted rows and columns"
thumbnail-img: ""
date:       2022-02-08 18:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org689ecab)
2.  [Review](#org73a8408)
3.  [Tips](#org5ad50a8)
4.  [Share](#org8748064)
    1.  [简介](#org8a2effb)


<a id="org689ecab"></a>

# Algorithm

Dual Core CPU: <http://poj.org/problem?id=3469>

<https://dreamume.medium.com/poj-dual-core-cpu-b8275155abb2>


<a id="org73a8408"></a>

# Review


<a id="org5ad50a8"></a>

# Tips

设计模式之美 - 设计原则与思想：规范与重构

为什么要重构？软件设计大师Martin Fowler是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。“我们可以理解为在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量

首先，重构是时刻保证代码质量的一个极其有效的手段，为避免代码不断增多而导致越来越混乱

其次，优秀的代码或架构不是一开始就能完全设计好的，需要迭代，随着系统的演进，重构不可避免

最后，重构是避免过度设计的有效手段，在遇到问题时再对代码进行重构，避免前期投入太多时间做过度设计

大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等

小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等

比较好的一个策略是持续重构、有时间的时候就可以主动重构

大型重构需要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态

大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，有时间随时可以做

为保证重构不出错，最可落地执行、最有效的保证重构不出错的手段应该就是单元测试

对于大型重构，最有效的一个手段就是解耦，解耦的目的是实现代码高内聚、松耦合

解耦的手段：

-   封装与抽象
-   引入中间层
-   模块化
-   其他设计思想和原则


<a id="org8748064"></a>

# Share

Selection in X+Y and Matrices with sorted rows and columns

<http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf>


<a id="org8a2effb"></a>

## 简介

在本文中我们考虑已排序的行和列的矩阵的选择问题。选择X + Y，X、Y为排序数组，是本问题的特殊例子

设 $ X = (x_ {1}, x_ {2}, \\ldots, x_ {n}) $和 $ Y = (y_ {1}, y_ {2}, \\ldots, y_ {n}) $为两个实数数组。Cartesian和X + Y是 $ n \\times n $矩阵，第ij条目为 $ x_ {i} + y_ {j} $。如果X和Y为排序的，则X + Y是一个按行和列排序后的矩阵。X + Y的选择和其他相关问题已因统计和运筹的应用程序而引起关注。同样该问题出现在一些VLSI设计中

Jefferson, Shamos和Tarjan呈现了在 $ O(n \\log{n}) $时间复杂度内解决选择X + Y的中位数问题。Johnson和Mizoguchi给出一个 $ O(n \\log{n}) $算法选择X + Y中第k小的元素。这两个算法都在算法应用之前排序数组X和Y。尽管需要时间来排序X和Y，这两个算法依然只需要$ O(n \\log{n}) $时间复杂度。Fredericks和Johnson考虑排序列来在矩阵中选择。这些选择X + Y中第k大元素的算法, $ 1 \\le k \\le \\frac{1}{2} n^{2} $，时间复杂度为 $ O(max \\{n, n \\log{(k/n)} \\}) $。他们也给出对已排序行和列的矩阵的选择问题的O(n)时间复杂度算法

设A为一个$ n \\times n $实数矩阵，行和列已排序，设k为一个整数，$ 1 \\le k \\le n^{2} $。我们呈现一个O(n)时间复杂度算法来选择A的第k小元素。本文呈现的算法应用分治技术。这个方法可应用到相似顺序相关问题。例如，我们使用这个技术来获得一个线性时间算法在VLSI中处理频道路由的最佳偏移问题。虽然Frederickson和Johnson算法有一个相似的时间边界，本文呈现的算法更简单。同样我们的算法使用的技术也很实用

---
layout:     post
title:      "Weekly 084"
subtitle:   "Algorithm: Apply Operations to Make Two Strings Equal; Review: Detecting Scene Changes in Audiovisual Content; Tips: Van der Corput Sequence; Share: "
thumbnail-img: ""
date:       2023-11-15 21:10
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org3082605)
2.  [Review](#orge23a8bd)
    1.  [简介](#org30eb8e5)
    2.  [杠杆对齐电影剧本信息](#org09e42db)
3.  [Tips](#org9fc6ab0)
    1.  [例子](#org746ca65)
    2.  [C 实现](#orgd441417)
4.  [Share](#org76f7529)


<a id="org3082605"></a>

# Algorithm

Leetcode 2896: [Apply Operations to Make Two Strings Equal](https://leetcode.com/problems/apply-operations-to-make-two-strings-equal/)

<https://dreamume.medium.com/leetcode-2896-apply-operations-to-make-two-strings-equal-416d27820881>


<a id="orge23a8bd"></a>

# Review

[Detecting Scene Changes in Audiovisual Content](https://netflixtechblog.com/detecting-scene-changes-in-audiovisual-content-77a61d3eaad6)


<a id="org30eb8e5"></a>

## 简介

当观看一个电影或一个连续剧时，我们体验一个紧密地叙述，通常不需要太多思考底层结构。然而，电影和连续剧不是原子单位，由更小的元素比如帧、场景、序列和行为。理解这些元素和它们互相如何关联比如视频总结和高亮检测、基于内容的视频提取、声音加工和视频编辑很重要。在 Netflix，这样的工作流被世界上许多团队每天执行数百次，这样投资在内容理解的算法相关工具可收割特别的奖励

然而更多粒度单元比如帧和影片边界要么是琐碎的要么可主要依赖基于像素的信息，更高的顺序段需要一个更细节的内容理解，比如叙述或情感弧。更进一步，一些线索可从视频之外比如场景或音频和对话轨道得出。场景边界检测，特别地，确定场景间过渡的任务，一个场景指在相同时间和位置（通常有相关静态角色集）的连续序列影片和共享一个共同的行为或主题

在这个博客中，我们呈现两个补充处理在试听内容中检测场景边界。第一个方法，可视为一个弱监督，对齐荧幕字幕和时间字幕和赋予一个时间戳到屏幕的场景头来杠杆化场景形式的辅助数据。第二个处理，我们显示一个相对简单，预训练影片水平嵌入在我们内部的评测基准中有更好的当前艺术状态基线


<a id="org09e42db"></a>

## 杠杆对齐电影剧本信息

电影剧本是电影或演出的蓝本。它们以特殊的形式格式化，每个场景以一个场景头开始，显示属性比如位置和时间。这种一致的格式使得它能够分析电影剧本为一个结构化格式。同时，a) 改变在不停进行中（方向或角色的决定）或 b) 在发布的产品和编辑很少反映在电影剧本中，例如，不能重写来反映改变

为了与数据源对齐协调，我们需要对齐时间采样文字（例如，关闭的标题和音频描述）与电影剧本文字（对话和行为线），容忍 a) 正在发生的改变可导致语义相似但不匹配线对和 b) 可能的后期改变更重要（重排序，删除或插入整个场景）。为处理第一个挑战，我们使用语句水平预训练嵌入，例如，从一个嵌入模型优化精简确定，在两种源中呈现文字。对第二个挑战，我们使用动态时间变形（DTW），一种度量两个序列随时间或速度改变之间的相似性的方法。当 DTW 假设一个对齐上的单调条件，其频繁在实际中违反，它足够强壮来从本地非对齐和显著事件的大多数中恢复好对齐

DTW 的结果，场景头有时间戳可显示视频中可能的场景边界。对齐也用于例如有争议的视听的 ML 模型，电影剧本信息比如场景水平嵌入或转换标签赋值到视听的内容到训练的电影剧本预测模型


<a id="org9fc6ab0"></a>

# Tips

[Van der Corput sequence](https://en.wikipedia.org/wiki/Van_der_Corput_sequence)

一个 van der Corput 序列是一个在单位区间中最简单的一维低差异序列的例子。它在 1935 年首次由荷兰数学家 J. G. van der Corput 描述。它通过反向的基于 n 表示的自然数序列（ $ 1, 2, 3, \\ldots $ ）构成

正整数 $ n \\ge 1 $ 的 b 进制表示为

$ n = \\sum^{L-1}_ {k=0} d_ {k}(n)b^{k} = d_ {0}(n)b^{0} + \\cdots + d_ {L-1}(n)b^{L-1} $

以 b 为基表示 n，且 $ 0 \\le d_ {k}(n) < b $。即，n 为以 b 为基 k 数字的展开。van der Corput 序列中第 n 个数为

$ g_ {b}(n) = \\sum^{L-1}_ {k=0} d_ {k}(n)b^{-k-1} = d_ {0}(n)b^{-1} + \\cdots + d_ {L-1}(n)b^{-L} $


<a id="org746ca65"></a>

## 例子

例如，为获得十进制 van der Corput 序列，我们通过除以数 1 到 9 为 ( x / 10 )，然后我们改变分母到 100 来开始分割 ( x / 100 )。对分子，我们开始所有的两位数字数从 10 到 99，但以数字的后向序。结果，我们将给出以结尾数字为组的分子。首先，所有两位数字分子以 1 结束，这样下一个分子为 01, 11, 21, 31, 41, 51, 61, 71, 81, 91。然后分子以 2 结尾，为 02, 12, 22, 32, 42, 52, 62, 72, 82, 92。之后以 3 为结尾，&#x2026;

这样，序列开始为

$ \\{ \\frac{1}{10}, \\frac{2}{10}, \\frac{3}{10}, \\frac{4}{10}, \\frac{5}{10}, \\frac{6}{10}, \\frac{7}{10}, \\frac{8}{10}, \\frac{9}{10}, \\frac{1}{100}, \\frac{11}{100}, \\frac{21}{100}, \\frac{31}{100}, \\frac{41}{100}, \\frac{51}{100}, \\frac{61}{100}, \\frac{71}{100}, \\frac{81}{100}, \\frac{91}{100}, \\frac{2}{100}, \\frac{12}{100}, \\frac{22}{100}, \\frac{32}{100} \\} $

或以十进制表示

$ 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.01, 0.11, 0.21, 0.31, 0.41, 0.51, 0.61, 0.71, 0.81, 0.91, 0.02, 0.12, 0.22, 0.32, \\ldots $

也可以用二进制表示

$ 0.1_ {2}, 0.01_ {2}, 0.11_ {2}, 0.001_ {2}, 0.101_ {2}, 0.011_ {2}, 0.111_ {2}, 0.0001_ {2}, 0.1001_ {2}, 0.0101_ {2}, 0.1101_ {2}, 0.0011_ {2}, 0.1011_ {2}, 0.0111_ {2}, 0.1111_ {2}, \\ldots $

或对应的

$ \\frac{1}{2}, \\frac{1}{4}, \\frac{3}{4}, \\frac{1}{8}, \\frac{5}{8}, \\frac{3}{8}, \\frac{7}{8}, \\frac{1}{16}, \\frac{9}{16}, \\frac{5}{16}, \\frac{13}{16}, \\frac{3}{16}, \\frac{11}{16}, \\frac{7}{16}, \\frac{15}{16}, \\ldots $

van der Corput 序列中的元素（任意进制）形成单位区间中的一个紧密集。即，对 [0, 1] 中任意实数，存在一个 van der Corput 序列的子序列覆盖该数。它们在单位区间内有统一的分布


<a id="orgd441417"></a>

## C 实现

    double corput(int n, int base) {
      double q = 0;
      double bk = (double)1 / base;
    
      while (n > 0) {
        q += (n % base) * bk;
        n /= base;
        bk /= base;
      }
    
      return q;
    }


<a id="org76f7529"></a>

# Share


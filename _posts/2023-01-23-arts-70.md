---
layout:     post
title:      "Weekly 070"
subtitle:   "Algorithm: Race Car; Review: Notes about iOS Develop; Tips: iOS thread backtrace info; Share: Young's Inequality"
thumbnail-img: ""
date:       2023-01-23 15:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#orgcef5afa)
2.  [Review](#orge5a069e)
    1.  [包大小：如何从资源和代码层面实现全方位瘦身](#orgaad56e7)
        1.  [官方 App Thinning](#orgd790c68)
        2.  [无用图片资源](#orgc405c28)
        3.  [图片资源压缩](#org29ea6f0)
        4.  [代码瘦身](#org2799933)
    2.  [iOS 崩溃千奇百怪，如何全面监控](#org08f3495)
        1.  [我们先来看看信号可捕获的崩溃日志收集](#orgc7e853a)
        2.  [信号捕获不到的崩溃信息怎么收集](#orgd2dc2b6)
        3.  [采集到崩溃信息后如何分析并解决崩溃问题呢？](#org4f132cc)
    3.  [如何利用 RunLoop 原理去监控卡顿](#org4c1e879)
        1.  [RunLoop 原理](#org018c6b2)
        2.  [loop 的六个状态](#org840b55b)
        3.  [如何检查卡顿](#org88cdf54)
        4.  [如何获取卡顿的方法堆栈信息](#org02d90e3)
    4.  [临近 OOM，如何获取详细内存分配信息，分析内存问题](#org0a46080)
        1.  [通过 JetsamEvent 日志计算内存限制值](#org2508660)
        2.  [通过 XNU 获取内存限制值](#orgca47c86)
        3.  [通过内存警告获取内存限制值](#orgd65b8e8)
        4.  [定位内存问题信息收集](#orgc359611)
3.  [Tips](#orga86a7d1)
4.  [Share](#orgf0e372c)
    1.  [Hölder 指数形式](#org0179d3b)
    2.  [定义积分的形式](#org729b009)
    3.  [证明](#org2e129ba)


<a id="orgcef5afa"></a>

# Algorithm

Leetcode 818: Race Car: <https://leetcode.com/problems/race-car>

<https://dreamume.medium.com/leetcode-818-race-car-6d92b634893f>


<a id="orge5a069e"></a>

# Review

iOS 开发高手课    戴铭


<a id="orgaad56e7"></a>

## 包大小：如何从资源和代码层面实现全方位瘦身

相信你的团队也曾遇到过或正在经历着对包大小进行优化的任务，特别是 App Store 规定了安装包大小超过 150MB 的 App 不能使用 OTA（over-the-air）环境下载，也就是只能在 WiFi 环境下下载。所以，150MB 就成了 App 的生死线，一旦超越了这条线就很有可能会失去大量用户

如果你的 App 要再兼容 iOS7 和 iOS8 的话，苹果 [官方规定](https://help.apple.com/app-store-connect/#/dev611e0a21f) 主二进制 text 段的大小不能超过 60MB。如果没有达到这个标准，你甚至都没法提交 App Store

而实际情况是，业务复杂的 App 轻轻松松就超过了 60MB。虽然我们可以通过静态库转动态库的方式来快速避免这个限制，但是静态库转动态库后，动态库的大小差不多会增加一倍，这样 150MB 的限制就更难守住

另外，App 包体积过大，对用户更新升级率也会有很大影响


<a id="orgd790c68"></a>

### 官方 App Thinning

App Thinning 是由苹果公司推出的一项可以改善 App 下载进程的新技术，主要是为了解决用户下载 App 耗费过高流量的问题，同时还可以节省用户 iOS 设备的存储空间

App Thinning 会专门针对不同的设备来选择只适用于当前设备的内容以供下载。比如，iPhone 6 只会下载 2x 分辨率的图片资源，iPhone 6plus 则只会下载 3x 分辨率的图片资源

下图来自 [iOS Support Matrix](http://iossupportmatrix.com/)，列出来的是历来各个 iOS 设备的指令集详细矩阵分布。从中，我们可以一窥所有设备的芯片指令集以及支持的最高和最低 iOS 版本

<../img/iOS_instruction_sets_of_device_and_ios_version.webp>

使用 App Thinning 后，用户下载时就只会下载一个适合自己设备的芯片指令集架构文件

App Thinning 有三种方式，包括：App Slicing、Bitcode、On-Demand Resources

-   App Slicing，会在你向 iTunes Connect 上传 App 后，对 App 做切割，创建不同的变体，这样就可以适用到不同的设备
-   On-Demand Resources，主要是为游戏多关卡场景服务的。它会根据用户的关卡进度下载随后几个关卡的资源，并且已经过关的资源也会被删掉，这样就可以减少初装 App 的包大小
-   Bitcode ，是针对特定设备进行包大小优化，优化不明显

那么，如何在你项目里使用 App Thinning 呢？

其实，这里的大部分工作都是由 Xcode 和 App Store 来帮你完成的，你只需要通过 Xcode 添加 xcassets 目录，然后将图片添加进来即可


<a id="orgc405c28"></a>

### 无用图片资源

图片资源的优化空间，主要体现在删除无用图片和图片资源压缩这两方面。而删除无用图片，又是其中最容易、最应该先做的。像代码瘦身这样难啃的骨头，我们就留在后面吧。那么，我们是如何找到并删除这些无用图片资源的呢？

删除无用图片的过程，可以概括为下面这 6 大步

1.  通过 find 命令获取 App 安装包中的所有资源文件，比如 find *Users/daiming/Project* -name
2.  设置用到的资源的类型，比如 jpg、gif、png、webp
3.  使用正则匹配在源码中找出使用到的资源名，比如 pattern = @"@"(.+?)""
4.  使用 find 命令找到的所有资源文件，再去掉代码中使用到的资源文件，剩下的就是无用资源了
5.  对于按照规则设置的资源名，我们需要在匹配使用资源的正则表达式里添加相应的规则，比如 @“image\_%d”
6.  确认无用资源后，就可以对这些无用资源执行删除操作了。这个删除操作，你可以使用 NSFileManger 系统类提供的功能来完成

如果你不想自己重新写一个工具的话，可以选择开源的工具直接使用。我觉得目前最好用的是 [LSUnusedResources](https://github.com/tinymind/LSUnusedResources)，特别是对于使用编号规则的图片来说，可以通过直接添加规则来处理


<a id="org29ea6f0"></a>

### 图片资源压缩

对于 App 来说，图片资源总会在安装包里占个大头儿。对它们最好的处理，就是在不损失图片质量的前提下尽可能地作压缩。目前比较好的压缩方案是，将图片转成 WebP

[WebP](https://developers.google.com/speed/webp/) 是 Google 公司的一个开源项目

首先，我们一起看看选择 WebP 的理由：

-   WebP 压缩率高，而且肉眼看不出差异，同时支持有损和无损两种压缩模式。比如，将 Gif 图转为 Animated WebP ，有损压缩模式下可减少 64% 大小，无损压缩模式下可减少 19% 大小
-   WebP 支持 Alpha 透明和 24-bit 颜色数，不会像 PNG8 那样因为色彩不够而出现毛边

接下来，我们再看看怎么把图片转成 WebP？
Google 公司在开源 WebP 的同时，还提供了一个图片压缩工具 [cwebp](https://developers.google.com/speed/webp/docs/precompiled) 来将其他图片转成 WebP。cwebp 使用起来也很简单，只要根据图片情况设置好参数就行

cwebp 语法如下

    cwebp [options] input_file -o output_file.webp

比如，你要选择无损压缩模式的话，可以使用如下所示的命令

    cwebp -lossless original.png -o new.webp

其中，-lossless 表示的是，要对输入的 png 图像进行无损编码，转成 WebP 图片。不使用 -lossless ，则表示有损压缩

在 cwebp 语法中，还有一个比较关键的参数 -q float

图片色值在不同情况下，可以选择用 -q 参数来进行设置，在不损失图片质量情况下进行最大化压缩

-   小于 256 色适合无损压缩，压缩率高，参数使用 -lossless -q 100
-   大于 256 色使用 75% 有损压缩，参数使用 -q 75
-   远大于 256 色使用 75% 以下压缩率，参数 -q 50 -m 6

除了 cwebp 工具外，你还可以选择由腾讯公司开发的 [iSparta](http://isparta.github.io/)。iSpart 是一个 GUI 工具，操作方便快捷，可以实现 PNG 格式转 WebP，同时提供批量处理和记录操作配置的功能。如果是其他格式的图片要转成 WebP 格式的话，需要先将其转成 PNG 格式，再转成 WebP 格式

图片压缩完了并不是结束，我们还需要在显示图片时使用 libwebp 进行解析。这里有一个 iOS 工程使用 libwebp 的范例，你可以点击 [链接](https://github.com/carsonmcdonald/WebP-iOS-example)

不过，WebP 在 CPU 消耗和解码时间上会比 PNG 高两倍。所以，我们有时候还需要在性能和体积上做取舍

我的建议是，如果图片大小超过了 100KB，你可以考虑使用 WebP；而小于 100KB 时，你可以使用网页工具 [TinyPng](https://tinypng.com/) 或者 GUI 工具 [ImageOptim](https://imageoptim.com/mac) 进行图片压缩。这两个工具的压缩率没有 WebP 那么高，不会改变图片压缩方式，所以解析时对性能损耗也不会增加


<a id="org2799933"></a>

### 代码瘦身

可执行文件就是 Mach-O 文件，其大小是由代码量决定的。通常情况下，对可执行文件进行瘦身，就是找到并删除无用代码的过程。而查找无用代码时，我们可以按照找无用图片的思路，即：

-   首先，找出方法和类的全集
-   然后，找到使用过的方法和类
-   接下来，取二者的差集得到无用代码
-   最后，由人工确认无用代码可删除后，进行删除即可

1.  LinkMap 结合 Mach-O 找无用代码

    我们可以通过分析 LinkMap 来获得所有的代码类和方法的信息。获取 LinkMap 可以通过将 Build Setting 里的 Write Link Map File 设置为 Yes，然后指定 Path to Link Map File 的路径就可以得到每次编译后的 LinkMap 文件了。设置选项如下图所示
    
    <../img/set_linkmap_file.webp>
    
    LinkMap 文件分为三部分：Object File、Section 和 Symbols
    
    -   Object File 包含了代码工程的所有文件
    -   Section 描述了代码段在生成的 Mach-O 里的偏移位置和大小
    -   Symbols 会列出每个方法、类、block，以及它们的大小
    
    通过 LinkMap ，你不光可以统计出所有的方法和类，还能够清晰地看到代码所占包大小的具体分布，进而有针对性地进行代码优化
    
    得到了代码的全集信息以后，我们还需要找到已使用的方法和类，这样才能获取到差集，找出无用代码。所以接下来，我就先和你说说怎么通过 Mach-O 取到使用过的方法和类
    
    之前提过 iOS 的方法都会通过 objc_msgSend 来调用。而，objc_msgSend 在 Mach-O 文件里是通过 \__objc_selrefs 这个 section 来获取 selector 这个参数的
    
    所以，\__objc_selrefs 里的方法一定是被调用了的。\__objc_classrefs 里是被调用过的类，\__objc_superrefs 是调用过 super 的类。通过 \__objc_classrefs 和 \__objc_superrefs，我们就可以找出使用过的类和子类
    
    那么，Mach-O 文件的 \__objc_selrefs、\__objc_classrefs 和 \__objc_superrefs 怎么查看呢？
    
    我们可以使用 [MachOView](https://sourceforge.net/projects/machoview/) 来查看 Mach-O 文件里的信息。MachOView 同时也是一款开源软件，如果你对源码感兴趣的话，可以点击 [链接](https://github.com/gdbinit/MachOView)
    
    但是，这种查看方法并不是完美的，还会有些问题。原因在于， Objective-C 是门动态语言，方法调用可以写成在运行时动态调用，这样就无法收集全所有调用的方法和类。所以，我们通过这种方法找出的无用方法和类就只能作为参考，还需要二次确认

2.  通过 AppCode 找出无用代码

    用过不少工具，但效果其实都不是很好，都卡在了各种运用运行时调用方法的写法上。即使是大名鼎鼎的 AppCode 在这方面也做得不是很好，当代码量过百万行时 AppCode 的静态分析会“歇菜”
    
    但是，如果工程量不是很大的话，我还是建议你直接使用 AppCode 来做分析。毕竟代码量达到百万行的工程并不多。而，那些代码量达到百万行的团队，则会自己通过 Clang 静态分析来开发工具，去检查无用的方法和类
    
    用 AppCode 做分析的方法很简单，直接在 AppCode 里选择 Code->Inspect Code 就可以进行静态分析
    
    <../img/appcode_inspect_code.webp>
    
    静态分析完以后，我们可以在 Unused code 里看到所有的无用代码
    
    -   无用类：Unused class 是无用类，Unused import statement 是无用类引入声明，Unused property 是无用的属性
    -   无用方法：Unused method 是无用的方法，Unused parameter 是无用参数，Unused instance variable 是无用的实例变量，Unused local variable 是无用的局部变量，Unused value 是无用的值
    -   无用宏：Unused macro 是无用的宏
    -   无用全局：Unused global declaration 是无用全局声明
    
    看似 AppCode 已经把所有工作都完成了，其实不然。下面，我再和你列举下 AppCode 静态检查的问题：
    
    -   JSONModel 里定义了未使用的协议会被判定为无用协议
    -   如果子类使用了父类的方法，父类的这个方法不会被认为使用了
    -   通过点的方式使用属性，该属性会被认为没有使用
    -   使用 performSelector 方式调用的方法也检查不出来，比如 self performSelector:@selector(arrivalRefreshTime)
    -   运行时声明类的情况检查不出来。比如通过 NSClassFromString 方式调用的类会被查出为没有使用的类，比如 layerClass = NSClassFromString(@“SMFloatLayer”)。还有以[[self class] accessToken] 这样不指定类名的方式使用的类，会被认为该类没有被使用。像 UITableView 的自定义的 Cell 使用 registerClass，这样的情况也会认为这个 Cell 没有被使用
    
    基于以上种种原因，使用 AppCode 检查出来的无用代码，还需要人工二次确认才能够安全删除掉

3.  运行时检查类是否真正被使用过

    即使你使用 LinkMap 结合 Mach-O 或者 AppCode 的方式，通过静态检查已经找到并删除了无用的代码，那么就能说包里完全没有无用的代码了吗?
    
    实际上，在 App 的不断迭代过程中，新人不断接手、业务功能需求不断替换，会留下很多无用代码。这些代码在执行静态检查时会被用到，但是线上可能连这些老功能的入口都没有了，更是没有机会被用户用到。也就是说，这些无用功能相关的代码也是可以删除的
    
    那么，我们要怎么检查出这些无用代码呢？
    
    通过 ObjC 的 runtime 源码，我们可以找到怎么判断一个类是否初始化过的函数，如下：
    
        #define RW_INITIALIZED (1<<29)
        bool isInitialized() {
           return getMeta()->data()->flags & RW_INITIALIZED;
        }
    
    isInitialized 的结果会保存到元类的 class_rw_t 结构体的 flags 信息里，flags 的 1<<29 位记录的就是这个类是否初始化了的信息。而 flags 的其他位记录的信息，你可以参看 objc runtime 的源码，如下：
    
        // 类的方法列表已修复
        #define RW_METHODIZED         (1<<30)
        
        // 类已经初始化了
        #define RW_INITIALIZED        (1<<29)
        
        // 类在初始化过程中
        #define RW_INITIALIZING       (1<<28)
        
        // class_rw_t->ro 是 class_ro_t 的堆副本
        #define RW_COPIED_RO          (1<<27)
        
        // 类分配了内存，但没有注册
        #define RW_CONSTRUCTING       (1<<26)
        
        // 类分配了内存也注册了
        #define RW_CONSTRUCTED        (1<<25)
        
        // GC：class有不安全的finalize方法
        #define RW_FINALIZE_ON_MAIN_THREAD (1<<24)
        
        // 类的 +load 被调用了
        #define RW_LOADED             (1<<23)
    
    flags 采用位方式记录布尔值的方式，易于扩展、所用存储空间小、检索性能也好。所以，经常阅读优秀代码，特别有助于提高我们自己的代码质量
    
    具体编写运行时无用类检查工具时，我们可以在线下测试环节去检查所有类，先查出哪些类没有初始化，然后上线后针对那些没有初始化的类进行多版本监测观察，看看哪些是在主流程外个别情况下会用到的，判断合理性后进行二次确认，最终得到真正没有用到的类并删掉


<a id="org08f3495"></a>

## iOS 崩溃千奇百怪，如何全面监控

KVO 问题、NSNotification 线程问题、数组越界、野指针等崩溃信息，是可以通过信号捕获的。但是，像后台任务超时、内存被打爆、主线程卡顿超阈值等信息，是无法通过信号捕捉到的


<a id="orgc7e853a"></a>

### 我们先来看看信号可捕获的崩溃日志收集

收集崩溃日志最简单的方法，就是打开 Xcode 的菜单选择 Product -> Archive

然后，在提交时选上“Upload your app’s symbols to receive symbolicated reports from Apple”，以后你就可以直接在 Xcode 的 Archive 里看到符号化后的崩溃日志了

但是这种查看日志的方式，每次都是纯手工的操作，而且时效性较差。所以，目前很多公司的崩溃日志监控系统，都是通过 [PLCrashReporter](https://github.com/microsoft/plcrashreporter) 这样的第三方开源库捕获崩溃日志，然后上传到自己服务器上进行整体监控的

而没有服务端开发能力，或者对数据不敏感的公司，则会直接使用 [Fabric](https://get.fabric.io/) 或者 [Bugly](https://bugly.qq.com/v2/) 来监控崩溃

通过注册 signalHandler 来捕获到。其实现代码，如下所示：

    void registerSignalHandler(void) {
        signal(SIGSEGV, handleSignalException);
        signal(SIGFPE, handleSignalException);
        signal(SIGBUS, handleSignalException);
        signal(SIGPIPE, handleSignalException);
        signal(SIGHUP, handleSignalException);
        signal(SIGINT, handleSignalException);
        signal(SIGQUIT, handleSignalException);
        signal(SIGABRT, handleSignalException);
        signal(SIGILL, handleSignalException);
    }
    
    void handleSignalException(int signal) {
        NSMutableString *crashString = [[NSMutableString alloc]init];
        void* callstack[128];
        int i, frames = backtrace(callstack, 128);
        char** traceChar = backtrace_symbols(callstack, frames);
        for (i = 0; i <frames; ++i) {
            [crashString appendFormat:@"%s\n", traceChar[i]];
        }
        NSLog(crashString);
    }

上面这段代码对各种信号都进行了注册，捕获到异常信号后，在处理方法 handleSignalException 里通过 backtrace_symbols 方法就能获取到当前的堆栈信息。堆栈信息可以先保存在本地，下次启动时再上传到崩溃监控服务器就可以了


<a id="orgd2dc2b6"></a>

### 信号捕获不到的崩溃信息怎么收集

先介绍下 iOS 后台保活的 5 种方式：Background Mode、Background Fetch、Silent Push、PushKit、Background Task

-   使用 Background Mode 方式的话，App Store 在审核时会提高对 App 的要求。通常情况下，只有那些地图、音乐播放、VoIP 类的 App 才能通过审核
-   Background Fetch 方式的唤醒时间不稳定，而且用户可以在系统里设置关闭这种方式，导致它的使用场景很少
-   Silent Push 是推送的一种，会在后台唤起 App 30 秒。它的优先级很低，会调用 application:didReceiveRemoteNotifiacation:fetchCompletionHandler: 这个 delegate，和普通的 remote push notification 推送调用的 delegate 是一样的
-   PushKit 后台唤醒 App 后能够保活 30 秒。它主要用于提升 VoIP 应用的体验
-   Background Task 方式，是使用最多的。App 退后台后，默认都会使用这种方式

接下来，我们就看一下，Background Task 方式为什么是使用最多的，它可以解决哪些问题？

在你的程序退到后台以后，只有几秒钟的时间可以执行代码，接下来就会被系统挂起。进程挂起后所有线程都会暂停，不管这个线程是文件读写还是内存读写都会被暂停。但是，数据读写过程无法暂停只能被中断，中断时数据读写异常而且容易损坏文件，所以系统会选择主动杀掉 App 进程

而 Background Task 这种方式，就是系统提供了 beginBackgroundTaskWithExpirationHandler 方法来延长后台执行时间，可以解决你退后台后还需要一些时间去处理一些任务的诉求

Background Task 方式的使用方法，如下面这段代码所示：

    - (void)applicationDidEnterBackground:(UIApplication *)application {
        self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^( void) {
            [self yourTask];
        }];
    }

在这段代码中，yourTask 任务最多执行 3 分钟，3 分钟内 yourTask 运行完成，你的 App 就会挂起。 如果 yourTask 在 3 分钟之内没有执行完的话，系统会强制杀掉进程，从而造成崩溃，这就是为什么 App 退后台容易出现崩溃的原因

后台崩溃造成的影响是未知的。持久化存储的数据出现了问题，就会造成你的 App 无法正常使用

接下来，我们再看看第二个问题：如何避免后台崩溃呢？

你知道了， App 退后台后，如果执行时间过长就会导致被系统杀掉。那么，如果我们要想避免这种崩溃发生的话，就需要严格控制后台数据的读写操作。比如，你可以先判断需要处理的数据的大小，如果数据过大，也就是在后台限制时间内或延长后台执行时间后也处理不完的话，可以考虑在程序下次启动或后台唤醒时再进行处理

同时，App 退后台后，这种由于在规定时间内没有处理完而被系统强制杀掉的崩溃，是无法通过信号被捕获到的。这也说明了，随着团队规模扩大，要想保证 App 高可用的话，后台崩溃的监控就尤为重要了

那么，我们又应该怎么去收集退后台后超过保活阈值而导致信号捕获不到的那些崩溃信息呢？

采用 Background Task 方式时，我们可以根据 beginBackgroundTaskWithExpirationHandler 会让后台保活 3 分钟这个阈值，先设置一个计时器，在接近 3 分钟时判断后台程序是否还在执行。如果还在执行的话，我们就可以判断该程序即将后台崩溃，进行上报、记录，以达到监控的效果

还有哪些信号捕获不到的崩溃情况？怎样监控其他无法通过信号捕获的崩溃信息？

其他捕获不到的崩溃情况还有很多，主要就是内存打爆和主线程卡顿时间超过阈值被 watchdog 杀掉这两种情况

其实，监控这两类崩溃的思路和监控后台崩溃类似，我们都先要找到它们的阈值，然后在临近阈值时还在执行的后台程序，判断为将要崩溃，收集信息并上报

对于内存打爆信息的收集，你可以采用内存映射（mmap）的方式来保存现场。主线程卡顿时间超过阈值这种情况，你只要收集当前线程的堆栈信息就可以了


<a id="org4f132cc"></a>

### 采集到崩溃信息后如何分析并解决崩溃问题呢？

我们采集到的崩溃日志，主要包含的信息为：进程信息、基本信息、异常信息、线程回溯

-   进程信息：崩溃进程的相关信息，比如崩溃报告唯一标识符、唯一键值、设备标识
-   基本信息：崩溃发生的日期、iOS 版本
-   异常信息：异常类型、异常编码、异常的线程
-   线程回溯：崩溃时的方法调用栈

通常情况下，我们分析崩溃日志时最先看的是异常信息，分析出问题的是哪个线程，在线程回溯里找到那个线程；然后，分析方法调用栈，符号化后的方法调用栈可以完整地看到方法调用的过程，从而知道问题发生在哪个方法的调用上

一些被系统杀掉的情况，我们可以通过异常编码来分析。你可以在维基百科上，查看 [完整的异常编码](https://en.wikipedia.org/wiki/Hexspeak)。这里列出了 44 种异常编码，但常见的就是如下三种

-   0x8badf00d，表示 App 在一定时间内无响应而被 watchdog 杀掉的情况
-   0xdeadfa11，表示 App 被用户强制退出
-   0xc00010ff，表示 App 因为运行造成设备温度太高而被杀掉


<a id="org4c1e879"></a>

## 如何利用 RunLoop 原理去监控卡顿

导致卡顿问题的几种原因:

-   复杂 UI 、图文混排的绘制量过大
-   在主线程上做网络同步请求
-   在主线程做大量的 IO 操作
-   运算量过大，CPU 持续高占用
-   死锁和主子线程抢锁


<a id="org018c6b2"></a>

### RunLoop 原理

对于 iOS 开发来说，监控卡顿就是要去找到主线程上都做了哪些事儿。我们都知道，线程的消息事件是依赖于 NSRunLoop 的，所以从 NSRunLoop 入手，就可以知道主线程上都调用了哪些方法。我们通过监听 NSRunLoop 的状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿

所以，我推荐的监控卡顿的方案是：通过监控 RunLoop 的状态来判断是否会出现卡顿

RunLoop 这个对象，在 iOS 里由 CFRunLoop 实现。简单来说，RunLoop 是用来监听输入源，进行调度处理的。这里的输入源可以是输入设备、网络、周期性或者延迟时间、异步回调。RunLoop 会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预订时间或者重复间隔的同步事件

RunLoop 的目的是，当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠。所以，了解 RunLoop 原理不光能够运用到监控卡顿上，还可以提高用户的交互体验。通过将那些繁重而不紧急会大量占用 CPU 的任务（比如图片加载），放到空闲的 RunLoop 模式里执行，就可以避开在 UITrackingRunLoopMode 这个 RunLoop 模式时是执行。UITrackingRunLoopMode 是用户进行滚动操作时会切换到的 RunLoop 模式，避免在这个 RunLoop 模式执行繁重的 CPU 任务，就能避免影响用户交互操作上体验

接下来，我就通过 CFRunLoop 的源码来跟你分享下 RunLoop 的原理

第一步

通知 observers：RunLoop 要开始进入 loop 了。紧接着就进入 loop。代码如下：

    //通知 observers
    if (currentMode->_observerMask & kCFRunLoopEntry ) 
        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);
    //进入 loop
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);

第二步

开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block。代码如下：

    // 通知 Observers RunLoop 会触发 Timer 回调
    if (currentMode->_observerMask & kCFRunLoopBeforeTimers)
        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
    // 通知 Observers RunLoop 会触发 Source0 回调
    if (currentMode->_observerMask & kCFRunLoopBeforeSources)
        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
    // 执行 block
    __CFRunLoopDoBlocks(runloop, currentMode);

接下来，触发 Source0 回调，如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息。代码如下：

    if (MACH_PORT_NULL != dispatchPort ) {
        Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &msg)
        if (hasMsg) goto handle_msg;
    }

第三步

回调触发后，通知 Observers：RunLoop 的线程将进入休眠（sleep）状态。代码如下：

    Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);
    if (!poll && (currentMode->_observerMask & kCFRunLoopBeforeWaiting)) {
        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
    }

第四步

进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒

-   基于 port 的 Source 事件
-   Timer 时间到
-   RunLoop 超时
-   被调用者唤醒

等待唤醒的代码如下：

    do {
        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort) {
            // 基于 port 的 Source 事件、调用者唤醒
            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {
                break;
            }
            // Timer 时间到、RunLoop 超时
            if (currentMode->_timerFired) {
                break;
            }
    } while (1);

第五步

唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。代码如下：

    if (!poll && (currentMode->_observerMask & kCFRunLoopAfterWaiting))
        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);

第六步

RunLoop 被唤醒后就要开始处理消息了：

-   如果是 Timer 时间到的话，就触发 Timer 的回调
-   如果是 dispatch 的话，就执行 block
-   如果是 source1 事件的话，就处理这个事件

消息执行完后，就执行加到 loop 里的 block。代码如下：

    handle_msg:
    // 如果 Timer 时间到，就触发 Timer 回调
    if (msg-is-timer) {
        __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
    } 
    // 如果 dispatch 就执行 block
    else if (msg_is_dispatch) {
        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
    } 
    
    // Source1 事件的话，就处理这个事件
    else {
        CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
        sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
        if (sourceHandledThisLoop) {
            mach_msg(reply, MACH_SEND_MSG, reply);
        }
    }

第七步

根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或 loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop 。代码如下：

    if (sourceHandledThisLoop && stopAfterHandle) {
         // 事件已处理完
        retVal = kCFRunLoopRunHandledSource;
    } else if (timeout) {
        // 超时
        retVal = kCFRunLoopRunTimedOut;
    } else if (__CFRunLoopIsStopped(runloop)) {
        // 外部调用者强制停止
        retVal = kCFRunLoopRunStopped;
    } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
        // mode 为空，RunLoop 结束
        retVal = kCFRunLoopRunFinished;
    }

整个 RunLoop 过程，我们可以总结为如下所示的一张图片

<../img/ios_runloop_procedure.webp>

这里只列出了 CFRunLoop 的关键代码，你可以点击 [链接](https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c.auto.html) 查看完整代码


<a id="org840b55b"></a>

### loop 的六个状态

通过对 RunLoop 原理的分析，我们可以看出在整个过程中，loop 的状态包括 6 个，其代码定义如下：

    typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
        kCFRunLoopEntry , // 进入 loop
        kCFRunLoopBeforeTimers , // 触发 Timer 回调
        kCFRunLoopBeforeSources , // 触发 Source0 回调
        kCFRunLoopBeforeWaiting , // 等待 mach_port 消息
        kCFRunLoopAfterWaiting ), // 接收 mach_port 消息
        kCFRunLoopExit , // 退出 loop
        kCFRunLoopAllActivities  // loop 所有状态改变
    }

如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了

所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。RunLoop 在进入睡眠之前和唤醒后的两个 loop 状态定义的值，分别是 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting ，也就是要触发 Source0 回调和接收 mach_port 消息两个状态

接下来，我们就一起分析一下，如何对 loop 的这两个状态进行监听，以及监控的时间值如何设置才合理


<a id="org88cdf54"></a>

### 如何检查卡顿

要想监听 RunLoop，你就首先需要创建一个 CFRunLoopObserverContext 观察者，代码如下：

    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};
    runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&runLoopObserverCallBack,&context);

将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态

一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长

开启一个子线程监控的代码如下：

    //创建子线程监控
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        //子线程开启一个持续的 loop 用来进行监控
        while (YES) {
            long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));
            if (semaphoreWait != 0) {
                if (!runLoopObserver) {
                    timeoutCount = 0;
                    dispatchSemaphore = 0;
                    runLoopActivity = 0;
                    return;
                }
                //BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿
                if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) {
                    //将堆栈信息上报服务器的代码放到这里
                } //end activity
            }// end semaphore wait
            timeoutCount = 0;
        }// end while
    });

代码中的 NSEC_PER_SEC，代表的是触发卡顿的时间阈值，单位是秒。可以看到，我们把这个阈值设置成了 3 秒。那么，这个 3 秒的阈值是从何而来呢？这样设置合理吗？

其实，触发卡顿的时间阈值，我们可以根据 WatchDog 机制来设置。WatchDog 在不同状态下设置的不同时间，如下所示：

-   启动（Launch）：20s
-   恢复（Resume）：10s
-   挂起（Suspend）：10s
-   退出（Quit）：6s
-   后台（Background）：3min（在 iOS 7 之前，每次申请 10min； 之后改为每次申请 3min，可连续申请，最多申请到 10min）

通过 WatchDog 设置的时间，我认为可以把启动的阈值设置为 10 秒，其他状态则都默认设置为 3 秒。总的原则就是，要小于 WatchDog 的限制时间。当然了，这个阈值也不用小得太多，原则就是要优先解决用户感知最明显的体验问题


<a id="org02d90e3"></a>

### 如何获取卡顿的方法堆栈信息

子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。那么，在这个过程中，如何获取卡顿的方法堆栈信息呢？

获取堆栈信息的一种方法是直接调用系统函数。这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景

直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下：

    static int s_fatal_signals[] = {
        SIGABRT,
        SIGBUS,
        SIGFPE,
        SIGILL,
        SIGSEGV,
        SIGTRAP,
        SIGTERM,
        SIGKILL,
    };
    
    static int s_fatal_signal_num = sizeof(s_fatal_signals) / sizeof(s_fatal_signals[0]);
    
    void UncaughtExceptionHandler(NSException *exception) {
        NSArray *exceptionArray = [exception callStackSymbols]; //得到当前调用栈信息
        NSString *exceptionReason = [exception reason];       //非常重要，就是崩溃的原因
        NSString *exceptionName = [exception name];           //异常类型
    }
    
    void SignalHandler(int code)
    {
        NSLog(@"signal handler = %d",code);
    }
    
    void InitCrashReport()
    {
        //系统错误信号捕获
        for (int i = 0; i < s_fatal_signal_num; ++i) {
            signal(s_fatal_signals[i], SignalHandler);
        }
    
        //oc未捕获异常的捕获
        NSSetUncaughtExceptionHandler(&UncaughtExceptionHandler);
    }
    
    int main(int argc, char * argv[]) {
        @autoreleasepool {
            InitCrashReport();
            return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));

另一种方法是，直接用 PLCrashReporter 这个开源的第三方库来获取堆栈信息。这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是我推荐的获取堆栈信息的方法

具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示：

    // 获取数据
    NSData *lagData = [[[PLCrashReporter alloc]
                                              initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];
    // 转换成 PLCrashReport 对象
    PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];
    // 进行字符串格式化处理
    NSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];
    //将字符串上传服务器
    NSLog(@"lag happen, detail below: \n %@",lagReportString);

搜集到卡顿的方法堆栈信息以后，就是由开发者来分析并解决卡顿问题了

在今天这篇文章中，我们用到的从监控卡顿到收集卡顿问题信息的完整代码，你都可以点击 [链接](https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMLagMonitor.m) 查看


<a id="org0a46080"></a>

## 临近 OOM，如何获取详细内存分配信息，分析内存问题

JetSam 机制，指的就是操作系统为了控制内存资源过度使用而采用的一种资源管控机制


<a id="org2508660"></a>

### 通过 JetsamEvent 日志计算内存限制值

想要了解不同机器在不同系统版本的情况下，对 App 的内存限制是怎样的，有一种方法就是查看手机中以 JetsamEvent 开头的系统日志（我们可以从设置 -> 隐私 -> 分析中看到这些日志）

在这些系统日志中，查找崩溃原因时我们需要关注 per-process-limit 部分的 rpages。rpages 表示的是 ，App 占用的内存页数量；per-process-limit 表示的是，App 占用的内存超过了系统对单个 App 的内存限制

这部分日志的结构如下：

    "rpages" : 89600,
    "reason" : "per-process-limit",

现在，我们已经知道了内存页数量 rpages 为 89600，只要再知道内存页大小的值，就可以计算出系统对单个 App 限制的内存是多少了

内存页大小的值，我们也可以在 JetsamEvent 开头的系统日志里找到，也就是 pageSize 的值。如下图红框部分所示：

<../img/jetsam_event_system_log.webp>

可以看到，内存页大小 pageSize 的值是 16384。接下来，我们就可以计算出当前 App 的内存限制值：pageSize \* rpages / 1024 /1024 =16384 \* 89600 / 1024 / 1024 得到的值是 1400 MB，即 1.4G

这些 JetsamEvent 日志，都是系统在杀掉 App 后留在手机里的。在查看这些日志时，我们就会发现，很多日志都是 iOS 系统内核强杀掉那些优先级不高，并且占用的内存超过限制的 App 后留下的

这些日志属于系统级的，会存在系统目录下。App 上线后开发者是没有权限获取到系统目录内容的，也就是说，被强杀掉的 App 是无法获取到系统级日志的，只能线下设备通过连接 Xcode 获取到这部分日志。获取到 Jetsam 后，就能够算出系统对 App 设置的内存限制值

那么，iOS 系统是怎么发现 Jetsam 的呢？

iOS 系统会开启优先级最高的线程 vm_pressure_monitor 来监控系统的内存压力情况，并通过一个堆栈来维护所有 App 的进程。另外，iOS 系统还会维护一个内存快照表，用于保存每个进程内存页的消耗情况

当监控系统内存的线程发现某 App 内存有压力了，就发出通知，内存有压力的 App 就会去执行对应的代理，也就是你所熟悉的 didReceiveMemoryWarning 代理。通过这个代理，你可以获得最后一个编写逻辑代码释放内存的机会。这段代码的执行，就有可能会避免你的 App 被系统强杀

系统在强杀 App 前，会先做优先级判断。那么，这个优先级判断的依据是什么呢？

iOS 系统内核里有一个数组，专门用于维护线程的优先级。这个优先级规定就是：内核用线程的优先级是最高的，操作系统的优先级其次，App 的优先级排在最后。并且，前台 App 程序的优先级是高于后台运行 App 的；线程使用优先级时，CPU 占用多的线程的优先级会被降低

iOS 系统在因为内存占用原因强杀掉 App 前，至少有 6 秒钟的时间可以用来做优先级判断。同时，JetSamEvent 日志也是在这 6 秒内生成的

除了 JetSamEvent 日志外，我们还可以通过 XNU 来获取内存的限制值


<a id="orgca47c86"></a>

### 通过 XNU 获取内存限制值

在 XNU 中，有专门用于获取内存上限值的函数和宏。我们可以通过 memorystatus_priority_entry 这个结构体，得到进程的优先级和内存限制值。结构体代码如下：

    typedef struct memorystatus_priority_entry {
      pid_t pid;
      int32_t priority;
      uint64_t user_data;
      int32_t limit;
      uint32_t state;
    } memorystatus_priority_entry_t;

在这个结构体中，priority 表示的是进程的优先级，limit 就是我们想要的进程内存限制值


<a id="orgd65b8e8"></a>

### 通过内存警告获取内存限制值

通过 XNU 的宏获取内存限制，需要有 root 权限，而 App 内的权限是不够的，所以正常情况下，作为 App 开发者你是看不到这个信息的。那么，如果你不想越狱去获取这个权限的话，还可以利用 didReceiveMemoryWarning 这个内存压力代理事件来动态地获取内存限制值

iOS 系统在强杀掉 App 之前还有 6 秒钟的时间，足够你去获取记录内存信息了。那么，如何获取当前内存使用情况呢？

iOS 系统提供了一个函数 task_info， 可以帮助我们获取到当前任务的信息。关键代码如下：

    struct mach_task_basic_info info;
    mach_msg_type_number_t size = sizeof(info);
    kern_return_t kl = 
      task_info(mach_task_self(), 
                MACH_TASK_BASIC_INFO, 
                (task_info_t)&info, &size);

代码中，task_info_t 结构里包含了一个 resident_size 字段，用于表示使用了多少内存。这样，我们就可以获取到发生内存警告时，当前 App 占用了多少内存。代码如下：

    float used_mem = info.resident_size;
    NSLog(@"使用了 %f MB 内存", used_mem / 1024.0f / 1024.0f)


<a id="orgc359611"></a>

### 定位内存问题信息收集

现在，我们已经可以通过三种方法来获取内存上限值了，而且通过内存警告的方式还能够动态地获取到这个值。有了这个内存上限值以后，你就可以进行内存问题的信息收集工作了

要想精确地定位问题，我们就需要 dump 出完整的内存信息，包括所有对象及其内存占用值，在内存接近上限值的时候，收集并记录下所需信息，并在合适的时机上报到服务器里，方便分析问题

获取到了每个对象的内存占用量还不够，你还需要知道是谁分配的内存，这样才可以精确定位到问题的关键所在。一个对象可能会在不同的函数里被分配了内存并被创建了出来，当这个对象内存占用过大时，如果不知道是在哪个函数里创建的话，问题依然很难精确定位出来。那么，怎样才能知道是谁分配的内存呢？

这个问题，我觉得应该从根儿上去找答案。内存分配函数 malloc 和 calloc 等默认使用的是 nano_zone。nano_zone 是 256B 以下小内存的分配，大于 256B 的时候会使用 scalable_zone 来分配

在这里，我主要是针对大内存的分配监控，所以只针对 scalable_zone 进行分析，同时也可以过滤掉很多小内存分配监控。比如，malloc 函数用的是 malloc_zone_malloc，calloc 用的是 malloc_zone_calloc

使用 scalable_zone 分配内存的函数都会调用 malloc_logger 函数，因为系统总是需要有一个地方来统计并管理内存的分配情况

具体实现的话，你可以查看 malloc_zone_malloc 函数的实现，代码如下：

    void *malloc_zone_malloc(malloc_zone_t *zone, size_t size) {
      MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);
      void *ptr;
      if (malloc_check_start && (malloc_check_counter++ >= malloc_check_start)) {
        internal_check();
      }
      if (size > MALLOC_ABSOLUTE_MAX_SIZE) {
        return NULL;
      }
      ptr = zone->malloc(zone, size);
      // 在 zone 分配完内存后就开始使用 malloc_logger 进行进行记录
      if (malloc_logger) {
        malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE,
                      (uintptr_t)zone, 
                      (uintptr_t)size, 
                      0, 
                      (uintptr_t)ptr, 
                      0);
      }
      MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);
    
      return ptr;
    }

其他使用 scalable_zone 分配内存的函数的方法也类似，所有大内存的分配，不管外部函数是怎么包装的，最终都会调用 malloc_logger 函数。这样的话，问题就好解决了，你可以使用 fishhook 去 Hook 这个函数，加上自己的统计记录就能够通盘掌握内存的分配情况。出现问题时，将内存分配记录的日志捞上来，你就能够跟踪到导致内存不合理增大的原因了


<a id="orga86a7d1"></a>

# Tips

移动端音视频开发实战    展晓凯


<a id="orgf0e372c"></a>

# Share

Young 不等式

<https://artofproblemsolving.com/wiki/index.php/Young%27s_Inequality>


<a id="org0179d3b"></a>

## Hölder 指数形式

如果 a, b 为非负实数，且 p, q 为正实数满足 $ \\frac{1}{p} + \\frac{1}{q} = 1 $，则如下不等式对所有 a, b 成立

$ \\frac{a^{p}}{p} + \\frac{b^{q}}{q} \\ge ab $

当 $ a^{p} = b^{q} $ 时等式成立


<a id="org729b009"></a>

## 定义积分的形式

假设 f 是一个在 [0, t] 区间中严格递增且连续的函数，且 f(0) = 0。则如下不等式成立 $ \\forall a \\in [0, c], b \\in [0, f(c)] $

$ \\int^{a}_ {0} f(x) dx + \\int^{b}_ {0}f^{-1}(x) dx \\ge ab $

当 f(a) = b 时等式成立


<a id="org2e129ba"></a>

## 证明

log 函数是凹函数且我们知道 $ \\frac{1}{p} + \\frac{1}{q} = 1 $，这样通过 Jensen 不等式，我们有

$ \\log{(\\frac{a^{p}}{p} + \\frac{b^{q}}{q})} \\ge \\frac{1}{p} \\log{(a^{p})} + \\frac{1}{q} \\log{(b^{q})} $

$ \\log{(\\frac{a^{p}}{p} + \\frac{b^{q}}{q})} \\ge \\log{a} + \\log{b} = \\log{ab} $

则得证


---
layout:     post
title:      "Weekly 045"
subtitle:   "Algorithm: Traveling by Stagecoach; Review: ; Tips: geek nots; Share: Constructing ZDDs
"
thumbnail-img: ""
date:       2021-09-01 12:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#orgc60049d)
2.  [Review](#org6f8da5e)
3.  [Tips](#org9ff1ff3)
4.  [Share](#org6e1430a)


<a id="orgc60049d"></a>

# Algorithm

Traveling by Stagecoach: <http://poj.org/problem?id=2686>

<https://dreamume.medium.com/poj-traveling-by-stagecoach-e56c27d45cc8>


<a id="org6f8da5e"></a>

# Review


<a id="org9ff1ff3"></a>

# Tips

代码精进之路 - 第二模块部分

代码只是能正确运行，这个门槛特别低，需要注意代码性能。性能架构是一个重要因素，代码细节也是关键

敏捷开发最重要的原则，就是高质量工作

性能的标准要有详细的评价指标，比如，互联网应用中，用户的最大等待时间是2秒以内，最大可容忍等待时间是最佳等待时间的4倍，即8秒，如果达到8秒内的用户跟所有用户占比要达到90%才算是好成绩

合理使用资源，使用好的算法，算法可通过时间复杂度和空间复杂度评价

如何判断过度设计？首先要识别是否是关键需求，非关键需求设计过于复杂则基本是过度，如是关键需求，看是设计解决的是什么问题，及设计的理由是什么，如确实解决关键问题或将来确实需要的问题，综合考虑取舍，合理的就应该设计，不合理地则是过度了

原则是把时间花在关键的地方，做重要的事情，非重要事情可合理简化

代码要简洁直观，要想简单直观，首先思路要是清晰的，有好的设计，80%的时间用在设计、拆解和验证上，20%写代码

把问题拆分成几个小问题，即分治法，是解决问题的必备武器之一。这里讲到了接口设计，也遵循简单直观的原则，接口是提供给别人用的，使用方式要“傻”，独立且容易理解，减少依赖

线程同步也是老生常谈的话题，也是必须要精通的。要有一些好习惯：

1.  比如尽量让变量只读，只要变量是只读的，就不存在需要同步的问题
2.  最好对资源的访问能封装成接口，接口内部去维护锁，这样简化代码也不容易出问题
3.  合理使用语言特性或设计，避免加锁
4.  最后有同步问题该加锁时就得加锁，特别对于app开发，只要不是高频操作，不要过度担心效率问题

对于内存使用，这里的技巧主要还是让类、对象只读，这样可以共享，不需要多份。还要使用合理的数据结构，如果使用了不合理的数据结构，导致又需要存储一些辅助的数据，导致代码复杂且数据操作容易出错

OC代码里也经常用延迟属性，就是访问该属性时才真正创建对象。这样确实会有效节省内存，但也不是适合所有场景。当该属性还会被释放的情况下，释放后再次访问该属性就会自动再创建，比如代码里音频引擎有些属性在引擎停止时需要释放该属性，而在释放时又访问了该属性，导致又重新创建，这样代码就很难理解也容易出问题。这样的场景就不适合作为延迟属性

可持续发展的代码，这里主要可伸缩性（Scalability），这里明显借用了分布式里的概念。扩展主要分两种：垂直扩展和水平扩展

垂直扩展指增加硬件，软件上指优化算法、程序，水平扩展指考虑代码分布式运行

代码中注意尽量不要有状态数据，影响代码水平扩展，状态数据需要注意数据同步问题。而无状态数据是最好的。可尽量把无状态数据分离出来，提高扩展能力。或者提供无状态服务，无状态服务不一定没有服务状态，只是服务状态数据相对比较小，比如Http中的Cookie机制

尽量减少代码，优秀的代码往往简短有效。代码行数越少bug越少，一是使用已有的轮子，二是如需要造轮子，需要不断改进，

我理解经济代码的含义是代码要高效解决问题，实现功能，同时避免常见的错误，要考虑性能、代码可读性、扩展性等常见指标，保证在有效的时间内能产出高质量的代码


<a id="org6e1430a"></a>

# Share

构建ZDDs

<https://crypto.stanford.edu/pbc/notes/zdd/construction.html>

给定一个集合的家族F，我们可找到它的ZDD如下：

1.  如果 $ F = \\emptyset $ (F为空)返回 $ \\bot $。如果 $ F = \\epsilon $(F只包含空集)则返回 $ \\top $
2.  找到F的所有集合中所有元素中的最小元素v，创建一个节点v
3.  设 $ F_ {0} $为F中不包含v的所有集合的家族，则 $ F_ {0} = \\{\\alpha: \\alpha \\in F, v \\notin \\alpha \\} $。从 $ F_ {0} $递归构建ZDD，且从v到 $ F_ {0} $的根连接LO边
4.  设 $ F_ {1} $为F中所有包含v的集合，从每个集合: $ F_ {1} = \\{\\alpha \\ \\{v \\}: \\alpha \\in F, v \\in \\alpha \\} $中删除v。从 $ F_ {1} $中递归构建ZDD，且连接v到 $ F_ {1} $的根的HI边
5.  找到确定的节点（相同的标签，相同的LO目标和相同的HI目标）且组合他们

一些家族有特色的属性允许它们的ZDD为立即构建。在一个大小为n的宇宙中，考虑例子所有集合大小为k的家族我们记为 $ S_ {k}(\\{1, \\ldots, n\\}) $。ZDD $ S_ {2} (\\{1,2,3\\}) = \\{\\{1,2\\}, \\{2,3\\}, \\{ 1,3\\}\\} $如下：

![img](../img/example_zdd_of_size_2.png)

$ S_ {k}(\\{1, \\ldots, n\\}) $的ZDD容易描述

这里有更多的例子。设 $ U = \\{1, \\ldots, 6\\} $且 $ S = \\{2, 3, 5 \\} $。U的所有子集的ZDD只包含S的一个元素，为：

![img](../img/construct_zdd_example_of_con2.png)

所有至少包含S中一个元素的集合的ZDD为：

![img](../img/construct_zdd_examples_con3.png)

最多只包含S的一个元素的集合的ZDD为：

![img](../img/construct_zdd_examples_con4.png)

在许多组合问题中，我们使用家族处理。我们在这些家族中执行操作来构建其他的家族来解决问题。例如，给定ZDD F和G，我们构建 $ F \\cup G, F \\cap G $等


---
layout:     post
title:      "Weekly 033"
subtitle:   "Algorithm: ; Review: Total Order Broadcast and Multicast Algorithms; Share:introduction to algorithm, chapter 35, "
thumbnail-img: ""
date:       2020-12-10 23:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#orgd8af2cf)
2.  [Review](#org481a26c)
    1.  [简介](#org2f217f0)
        1.  [总序广播文献](#orga8ba206)
        2.  [相关工作](#org7f68034)
        3.  [贡献](#orga548954)
        4.  [结构](#org5803692)
    2.  [基本术语和记号](#org82fcfd6)
        1.  [记号](#orgdbbd63b)
        2.  [基本系统模型](#org0fc6364)
3.  [Tips](#org239b077)
4.  [Share](#org52ec16c)


<a id="orgd8af2cf"></a>

# Algorithm

Leetcode 680: 


<a id="org481a26c"></a>

# Review

Total Order Broadcast and Multicast Algorithms:∗ Taxonomy and Survey

<http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.3.4709&rep=rep1&type=pdf>

总序广播和多播（也称为原子广播或原子多播）在分布式系统中是一个重要的问题，特别对容错。剪短地说，最初地确定发送到一系列进程的消息会被这些进程已相同的总序转发。

该问题激发了大量的工作，大量的提名算法。本文提出基于顺序机制的一个典型总序广播和多播算法，且处理一些重要的其他问题。本文研究60种算法，这样提供问题的最扩展的研究。本文讨论算法的同步和异步模型，并学习不同算法的属性和行为。


<a id="org2f217f0"></a>

## 简介

分布式系统和应用程序是出名的难构建。最主要是由于这样的系统的不可避免的并发，及结合提供全局控制的困难度。相比提供早期的比标准点对点通讯更高地保证，依赖组通讯极大地缩减了困难度。一个这样的初始方案为总序广播。该方案确保所有的进程已相同的顺序转发发送到一系列进程的消息。总序广播是重要的，例如，一个实现的中心角色是状态机（也称为活动节点）。它也有其他应用程序，比如时钟同步，支持协调写的计算机，分布式共享内存，或分布式锁。最近，它也显示总序广播的使用能显著地改善复制数据库的性能。


<a id="orga8ba206"></a>

### 总序广播文献

存在关于总序广播可观的文献和许多算法，及各种处理，被提出用来解决该问题。相比它的实际属性，假设，目标或其他重要方面，要困难。因此很难知道什么样的解决方案适合给定的应用程序内容。当面临新的需求，缺乏对总序广播问题的规划常常导致工程师和研究员要么开发新的算法而不是适配现有的解决方案（重新发明轮子），或使用一个不是很好的解决方案适配应用程序需要。一个改进当前解决方案的重要步骤是提供现有算法的分类。


<a id="org7f68034"></a>

### 相关工作

之前分类和比较总序广播算法的尝试是Anceaume 1993b, Anceaume and Minet 1992, Cristian et al. 1994, Friedman and van Renesse 1997, Mayer 1992。然而，都没有基于现存算法的理解调查，因此缺乏一般性。

最完整的比较是Anceaume and Minet 1992，基于算法的属性的有趣处理。该论文引起一些基础的问题，我们的一些工作基于它的启发。然而它有一点落后了。此外，作者只学习了7种不同的算法，例如，没有一个基于通讯历史处理。

Cristian et al. 1994使用另一种处理聚焦于这些算法的实现而不是它们的属性。他们学习4种不同的算法，且使用离散事件模拟比较他们。他们根据不同实现策略的性能找到了有趣的结果。然而，他们缺失对不同算法属性的讨论。此外，他们只比较了4种算法，他们的工作比Anceaume的更缺乏一般性。

Friedman and van Renesse 1997学习了压缩消息在算法性能的影响。为这个目的，他们学习了6种算法，包括通过Cristian el al 1994的学习。他们测量这些算法实际的性能且确认了Crisitan et al 1994的观察。他们显示压缩一些协议消息为单个物理消息提供了一个有效的方法改进算法的性能。该比较也缺乏一般性，但这是非常能理解的但这不是本论文的主要关心点。

Mayer 1992定义了一个框架使得总序广播算法能从性能方面进行比较。该框架的定义对算法扩展和有意义的比较是一个重要的步骤。然而，论文在比较大量算法方面没有进一步处理。


<a id="orga548954"></a>

### 贡献

本文我们提出一类基于顺序消息机制的总序广播算法。选择的原因是顺序机制是算法通讯范型最有影响的特征：相同类型的两个算法因此展示了相似的行为。我们定义顺序机制的5种类型：通讯历史、基于优先级、移动序列、固定序列和目标同意。

在本文中，我们也提供关于60种已发布的总序广播算法的广泛的检查。只要可能，我们提及每个算法的属性和假设。然而不总是可能因为在本文中的信息不总是能精确地对应到算法特征行为。


<a id="org5803692"></a>

### 结构

本文逻辑上组织为3个主要部分：指导说明，机制和调查。更精确地，剩余的本文结构如下。

第一部分是关于定义，指导说明和属性。第2节介绍重要的概念，术语和记号。第3节展现最常见的总序广播问题的指导说明（原子广播）。基于这个指导说明，第4-6节讨论一些重要的属性（及其他问题）和它们在指导说明问题上的影响。更特别地，第4节讨论可能的算法额外属性（例如，单个 vs 多个群），及第6节展示当考虑分区系统和拜占庭故障时指导说明系统模型的影响。

第二部分描述机制。在第7节，我们定义如下5种总序广播算法，根据消息顺序：通讯历史、优先级、移动序列，固定序列和目标同意。第8节讨论从一般化上的故障问题。

第三部分我们审查现存的算法。更特别地，第9节给定一个白板调查总序广播算法找到的文献。算法按它们的类型分组，且我们讨论每个算法的规律特性。

在第10节，我们谈论各种跟总序广播相关的其他问题，第11节包含论文。


<a id="org82fcfd6"></a>

## 基本术语和记号


<a id="orgdbbd63b"></a>

### 记号

$ \\mathcal{M} $是包含所有有效消息的集合，$ \\Pi $是系统中所有进程集合，给定任意消息m，sender(m)指明 $ \\Pi $中发送消息m的进程，且Dest(m)记为m的目标进程的集合。

另外，$ \\Pi_ {sender} $是 $ \\Pi $中可能发送消息的进程集合。

$ \\begin{equation} \\Pi_ {sender} \\stackrel{def}{=} \\cup_ {m \\in \\mathcal{M}}sender\\left(m\\right) \\end{equation} $

$ \\Pi_ {dest} $是所有可能的目的集合 $ \\Pi_ {dest} \\stackrel{def}{=} \\cup_ {m \\in \\mathcal{M}}Dest\\left(m\\right) $


<a id="org0fc6364"></a>

### 基本系统模型

一个分布式系统包含一系列进程 $ \\Pi = \\{p_ {1}, \\ldots, p_ {n} \\} $通过通讯频道交换唯一识别号消息。存在一些模型限制系统行为。考虑最重要的特征是同步性和故障模型。

1.  同步性

    模型的同步性是进程行为和通讯频道上的时间相关的假设。更确切地，通常考虑两个主要参数。第一个参数是进程速度间隔，系统中最快的进程和最慢的速度的差异。第二个参数是通讯延迟，消息发送和接收需要的时间。系统的同步性被定义考虑这两个参数的各种边界。对每个参数，通常考虑如下的同步性水平：
    
    1.  知道一个总能确保的上界
    2.  有一个总能确保的未知上界
    3.  有一个最终总能确保的已知上界
    4.  有一个最终总能确保的未知上界
    5.  参数值无上界
    
    两个参数的系统假设满足(1)被称为同步系统，在另一个极端中，一个进程速度和通讯延无上界的系统被称为异步系统。在这两个极端之间定义各种部分同步系统模型。

2.  进程故障

    系统故障模型指明期望会发生的故障类型，及这些故障可能或不能发生的条件。通常使用的进程故障集合类型如下：
    
    -   崩溃故障。当一个进程崩溃，它永远停止工作。这意味着它停止执行任意活动包含发送、传输或接收任何消息
    -   丢失故障。当一个进程丢失故障，它丢失执行一些行为比如发送或接收消息
    -   时间故障。当一个进程违法一个同步性假设则发生了一个时间故障。该类型故障在异步系统是没有的
    -   拜占庭故障。拜占庭故障是最一般化的故障类型。一个拜占庭组件允许任意行为。例如，一个故障进程可能改变消息内容，重复消息，发送未请求的消息，或甚至恶意尝试使整个系统崩溃
        
        实际上，经常考虑拜占庭故障的一个特殊例子，称为鉴权拜占庭故障。鉴权拜占庭故障允许拜占庭进程任意行为。然而，它假设系统已访问一些鉴权机制（例如，数字签名），这样使它可能通过拜占庭进程检测有效消息的伪造。当在后续提及拜占庭故障（在第9节）时，我们指的是鉴权拜占庭故障。
    
    **注意（时间故障的特殊性）** 一个系统以故障模型为特征且展示了同步性总计。当故障模型正常正交与系统同步性，这不是时间故障直接相关系统同步性的例子。时间故障是以违背系统同步性为特征。

3.  通讯

    根据它们提供的确保，存在通讯频道的一些定义。我们考虑如下类型的通讯频道。除非说明否则，本文假设通讯频道没有重复消息也没有错误的消息。
    
    1.  可靠频道
    
        可靠频道保证如果一个正确的进程p发送一个消息m给一个正确的进程q，则q将最终接收到消息m。这通常假设可靠通讯被网络协议栈提供（例如TCP/IP）
    
    2.  丢失频道
    
        丢失频道是那些丢失消息的频道。一些丢失消息通常的原因是：网络冲突，噪声频道，缓存过载，连线掉线，路由表损坏或间断的连接。虽然消息丢失维护通常由网络栈机制实现（物理层和传输层之间），但网络很弱任然可能发生。这可以在两种丢失频道类型中进行区分。
        
        最简单的例子，通讯频道有一个丢失消息数的上界k。拷贝这样的丢失是简单的，因为它有效地发送一个消息k + 1次为了确保至少一个拷贝会被接收。该模型在网络不差的情况下性能会差一些。


<a id="org239b077"></a>

# Tips

-   某些书里的内容如果看着比较难理解，先放一放，过几天再看可能又变得显然了
-   学习过程中有周期起伏，有些时候效率高，有些时候效率低，调整好节奏和进度（难度），不好的情况下也要尽量有进度（最好不要导致完全没进展的情况），比如只看一页也行，确保持续力


<a id="org52ec16c"></a>

# Share

xxx

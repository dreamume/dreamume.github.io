
# Table of Contents

1.  [Algorithm](#org5bfefea)
2.  [Review](#orgc9d7a16)
    1.  [简介](#orgfcd7dcf)
    2.  [经典Paxos算法](#orgc08a58d)
        1.  [问题](#org1dca3d7)
        2.  [安全性](#orgd55babb)
        3.  [进展](#org16b2763)
3.  [Tips](#org2f5fdd7)
4.  [Share](#org76fa629)
    1.  [Dropbox文件格式](#org59b354a)
    2.  [服务器文件日志](#org407299f)
    3.  [高水平改变](#orgf9efc90)
    4.  [协议更改](#org22022dc)
    5.  [元数据服务器变更](#orgf510862)
    6.  [客户端变更](#org7db932c)
    7.  [完成](#orgac4482a)
    8.  [流同步有什么好处？](#orgf28a4c9)


<a id="org5bfefea"></a>

# Algorithm

leetcode 321: <https://leetcode.com/problems/create-maximum-number/>

<https://medium.com/@dreamume/leetcode-321-create-maximum-number-45af2be1d47d>


<a id="orgc9d7a16"></a>

# Review

<https://www.microsoft.com/en-us/research/publication/fast-paxos/>

Fast Paxos


<a id="orgfcd7dcf"></a>

## 简介

共识问题需要一系列进程来选择一个值。本文在一个异步消息传递系统非拜占庭故障环境下考虑共识问题。该问题的一个解决方案在任意数量故障的情况下禁止选择两个不同的值，在有足够非故障进程及互相能通讯的情况下最终会选择一个值。

在传统的共识问题描述中，每个进程提议一个值和选择一个提议值。可以看到任何解决方案需要至少两个消息延迟以达到任意进程已学习了解被选中的值。一系列算法在最好的情况下能达到这种延迟情况。经典的Paxos算法这么流行是因为在实际系统中Paxos算法能在正常情况下达到这种延迟状况。

可以看到用传统共识算法优化消息延迟数是不可能的 &#x2013; 一个人为的传统问题描述，提议的进程和选择的进程为同一个进程。在很多应用程序中，提议和选择的进程并不是同一个。例如，在一个客户端/服务器系统中，客户提议下一个被执行的命令，服务器会选择一个提议值。当传统共识算法用在这样的系统时，需要3个消息延迟：客户端提议一个命令，一些进程学习到被选中的命令。

一种快速共识算法是一个进程可以以两个消息延迟学习到选中值，即使值提议和选择在不同系列的进程中。该算法显示没有一般性的共识算法能保证在提议值竞争冲突时能在两个消息延迟学习到选中值，即如果两个不同的值同时提议的时候。快速共识算法因此不能总是像预计的那么快速，如果遇到冲突事件的时候。

快速Paxos是一种快速共识算法，为经典Paxos的变种。在正常情况下，如果无冲突学习将在两个消息延迟完成，并保证冲突时3个消息延迟能完成。甚至，它能使用最小可能的进程数达到想要的容错。

快速Paxos的基本思想依赖于更早的Brasileiro算法。然而，它们仅考虑传统的共识问题，没有意识到他们的算法能轻易地修改来达到快速共识。Pedone和Schiper的R共识算法也能修改成为快速共识算法。然而，修改后的算法在冲突的情况下需要至少4个消息延迟。

快速Paxos算法是经典Paxos算法扩展的核心。如果理解经典Paxos工作原理则能容易理解快速Paxos。因此我开始在第2节解释经典Paxos。第3节解释如何修改经典Paxos来获得快速Paxos。这两节的解释描述有些是非形式化的。目的是解释算法如何工作，不提供按照惯例的用伪代码或其他语言的算法简约描述。经典Paxos算法的精确描述在第4和第7节，一个形式化的TLA+快速Paxos指导说明在书后附录里给出。TLA+指导说明足够详细，可以指导这里讨论的所有变量。然而，没有一种快速Paxos的描述能描述出实现中的所有变量细节。要透彻理解快速Paxos的原理最好准备实现它而不是看算法的任何伪代码或形式化语言的描述。

在最后的章节将讨论快速Paxos的优化，解释Brasileiro算法和快速Paxos算法的关系，简略提及经典和快速Paxos的一般化来处理拜占庭故障。


<a id="orgc08a58d"></a>

## 经典Paxos算法


<a id="org1dca3d7"></a>

### 问题

共识问题可以很好的用3种集合代理的术语来描述：提议者提议值，接受者选择一个值，学习者学习被选中的值。代理代表在进程中扮演的角色；一个进程可以扮演多个角色。例如，在客户端/服务器系统中，一个客户端可扮演提议者和学习者，服务端扮演接受者和学习者。

我假设异步，分布式，非拜占庭计算模型：

1.  代理以任意速度工作，可能因故障停止，并重启。然而，代理不能执行错误的行为。
2.  代理通过发送消息来通讯，可能转发很耗时，转发乱序和重复、丢失。然而，消息不能损坏。

共识算法的安全需求如下，一个值只能被一个提议者提议：

1.  不平凡性，只有提议值能被学习
2.  一致性，最多只能学习一个值

大多数共识算法，包括快速Paxos，都会满足不平凡性。我这里将因此忽略不平凡性。一致性通过确保接受者只能选择一个值来保证，且只有该值能被学习。确保只有一个值被选中是比较困难的，学习选中值则相对简单，我们将集中关注在接受者如何选择值这块。

安全需求需要在任意数量（非拜占庭）故障中也能维护住。一个共识算法同样需要满足进度需求，即如果有足够的非故障代理某个值最终会被选中。我们不想回复提议者或学习者进度信息，因为它们不可靠。例如，我们不想一个客户端/服务器系统因一个客户端失去响应而整个系统挂掉；客户端可能会扮演提议者或学习者角色。进度只需要有足够多的非故障接受者，一个非故障提议者提议一个值和一个非故障学习者学习该值。然而，这样的需求是有问题的，因为典型的Fischer、Lynch、Paterson结果显示它不能满足任意满足共识安全属性的容错异步算法。因此，需要一些额外的假设。不同的共识算法使用不同的假设。我将稍后介绍Paxos算法进度属性的精确描述，其中会定义“非故障”，直到我描述了它如何满足安全属性之后。这是可能的，因为安全需求在没有任何非故障假设前提下也需要保持。

如果所有代理都正常进度能够得到保持，即使所有代理故障后重启。因为一个值可能在代理故障前学习到，代理必须有一些稳定的存储保存，因为代理可能故障和重启。我假设代理重启时从存储中恢复它的状态，这样一个故障的代理就像被一个简单地暂停了一样没有不同。


<a id="orgd55babb"></a>

### 安全性

1.  基本算法

    我开始描述一个Paxos共识算法的简单版本，他满足共识的安全需求。在2.3节将扩展到完整算法，并满足进度属性。
    
    算法执行多轮，每轮有一个正整数号。但不需要按号顺序执行，不需要完成并可能跳过，不同轮可能并发执行。每轮选择一个值。一个值被选中当且仅当在某轮中它被选中。每一轮，接受者可能投票接受某个值或确定不投票。在某轮一个值v定义为选中当且仅当在该轮中多数接受者投票接受该v值。简单来说，我描述一个算法不会终止且持续一轮轮执行即使某个值被选中。终止和其他优化将在2.4章节讨论。
    
    达到一致性需要没有不同值被选中。因为每轮接受者投票接受最多一个值，且任意两个多数中包含一个共同的接受者，因此在同一轮中不可能有两个不同的值被选中。然而，接受者可以在不同的轮中投票接受不同的值。达到一致性的难点是保证不同的轮中不会被选中不同的值。
    
    虽然我们以接受者投票的所有投票的方式推理算法，接受者不需要记住这些投票。接受者a维持仅仅如下数据：
    
    -   rnd[a]，a参与的最高轮轮号，初始化为0（因0不是一个轮号，rnd[a] = 0意味着a未参与任何轮次）。
    -   vrnd[a]，a投过票的最高轮号，初始化为0（因此，vrnd[a] <= rnd[a]）
    -   vval[a]，a在vrnd[a]轮中接受的值
    
    Paxos假设有一系列协调代理集合。协调者的角色和接受者通常为同一个进程。对每轮i，一些协调者为i轮预先设置的协调者。每个协调者被设置为无穷轮的协调者。提议值发送它们的提议给协调者。i轮的协调者尝试获取被选中的值。每个协调者c维持如下数据：
    
    -   crnd[c]，c参与开始的最高轮，初始化为0
    -   cval[c]，对crnd[c]轮中c所选择的值，或c未选择任何值则值为空。
    
    i轮进度在以下阶段：
    
    -   如果crnd[c] < i，则c开始i轮，设置crnd[c]为i，设置cval[c]为空，发送消息给每个接受者a请求a参与i轮
    -   如果一个接受者a收到参与i轮的请求且i > rnd[a]，则a设置rnd[a]为i，发送一个消息给协调者c，内容包含轮号i和vrnd[a]及vval[a]的当前值。如果i <= rnd[a]（a已开始i轮或参与了一个更高的轮次），则a忽略该请求。
    -   如果crnd[c] = i（c还没有开始更高轮次），cval[c] = 空（c还没有执行这轮的阶段2a），且c接收到i轮多数接受者的阶段1b消息；则规则描述如下，c使用这些消息的内容包含一个v值并设置cval[c]为v，发送一个消息给接受者请求他们在i轮接受v值。
    -   如果接受者a收到一个请求在i轮投票接受一个v值，i >= rnd[a]且vrand[a] != i；则a在i轮投票接受v值，设置vrnd[a]和rnd[a]为i，设置vval[a]为v，发送一个消息给所有学习者宣布它已在i轮投票。如果i < rnd[a]或vrnd[a] = i（这样a已经开始一个更高序号的轮次或已经在本轮投票），则a忽略这个请求。
    
    学习者学习一个v值，在第i轮，它从多数接受者收到阶段2b消息，宣布它们在第i轮都投票了v值。
    
    协调者在任意时刻对新轮号执行阶段1a行为。然而，该行为的启动条件防止协调者以一个低于之前它启动的轮次的轮号作为新轮轮号。不同的轮次可以并行执行，但接受者如果接收到更高轮次的消息将停止参与本轮。阶段2a消息请求接收不同的值可以在不同的轮次发送。然而，阶段2a行为的启动条件和给协调者唯一分配的轮次确保带不同值的阶段2a消息不会发送到相同的轮次。

2.  阶段2a中选择一个值

    我还没有描述算法的核心 - 协调者如何在阶段2a中选择v值。如何做源于算法维护如下基本属性的需求：
    
    CP. 对任意轮i和j，j < i，如果一个v值在j轮已被选中或将被选中，则接受者在i轮不能投票给除v外的其他值。
    
    当然，一个对等的CP描述是：
    
    对任意轮i和j，j < i，如果一个接受者在i轮已投票给v值，则在j轮，除v以外的值都不会将被或会被选择。
    
    一个值在i轮被选择只会是一些接受者投票给了它。因此，CP意味着，如果j < i，如果v在j轮被选择，除v以外的值都不会在i轮被选择。CP表明两个不同的值不会在不同的轮选中。我们已经看到两个不同的值不会在同一轮中被选中，这样CP代表了一致性。
    
    因为CP代表了一致性需求，我们可以通过维护CP来保证算法满足一致性。接受者在i轮可投票的唯一v值即是协调者在阶段2a指定的值。这样，我们只需要确保v满足如下属性：
    
    CP(v, i)：对任意轮j < i，在j轮除v以外的值不会被选择或选中。
    
    多数集包含接受者的多数。一个v值在j轮将被或被选中当且仅当有一个多数集Q，Q中每个接受者在j轮投票了v或将要投票给v。接受者a不会降低rnd[a]，如果j < rnd[a]它将忽略j轮的投票请求。因此，我们有：
    
    观察1: 一个v值在j轮将被或被选中仅当有一个多数集Q，Q中每个接受者有rnd[a] <= j或在j轮投票了v值
    
    如果“仅当“替换为“当且仅当”则观察1不成立，因为rnd[a] = j在接受者在j轮已投票给非v的其他值时成立。要用“当且仅当”需要把条件rnd[a] <= j替换为：
    
        (rnd[a] <= j) && (vrnd[a] < j)
    
    但我们不需要这么复杂的条件。
    
    因为任何两个多数集合有一个共同的接受者，观察1意味着如下两个观察：
    
    -   观察2: 如果有一个多数集合Q，Q中每个接受者a的rnd[a] > j且在j轮没有投票，则在j轮没有选择或将会选择值
    -   观察3: 如果有一个多数集合Q，Q中每个接受者a的rnd[a] > j，要么投票了v值要么尚未投票，则在j轮不会投票或将会投票给非v的其他值
    
    观察3的假设并不意味着v值在j轮被选中或将被选择。事实上，这些假设表示两个不同的v值，在观察3的约束下在j轮不会选择或将会它们。
    
    假设协调者从多数接受者集合Q中收到i轮阶段1b消息。因为接受者a设置rnd[a]为i且rnd[a]不会变小，对Q中每个接受者rnd[a]当前值满足rnd[a] >= i。设vr(a)和vv(a)为vrnd[a]和vval[a]的值，设k为Q中所有接受者的vr(a)的最大值。我们现在考虑两种情况：
    
        K1. k = 0
        K2. k > 0
    
    K1时，Q中每个接受者a报告vrnd[a] = 0，Q中接受者在j < i轮中都没有投票。因为Q中所有rnd[a] >= i，观察2意味着在j < i轮中没有值被选中或将被选择。因此，不管协调者选择了任意v值，CP(v, i)都满足。然而，为保证不平凡性，协调者必须选择一个提议的v值。
    
    K2时，一个或多个接受者报告在k轮已投票并且在任意j > k轮，没有接受者报告投票。设a<sub>0为Q中vr</sub>(a<sub>0</sub>) = k的一些接受者，在阶段2a，协调者选择一个等于vv(a<sub>0</sub>)的v值。为说明v值满足CP(v, i)，我们必须证明对任意j轮，j < i，非v的值不会被选中或选择。因为vrnd[a] <= rnd[a]且接受者a只在i > rnd[a]时回应一个i轮消息，则我们有k < i。证明因此分成如下3种情况：
    
    1.  k < j < i。设a为Q中任意接受者。因为vr(a)为最大的轮号，a发送消息投票且vr(a) <= k < j，接受者a在j轮没有投票。因它发送消息时设置rnd[a]为i，则a在轮号小于i的轮次中没有投票。因此a在j轮没有投票，Q中没有接受者在j轮投票。因在Q中任意a有rnd[a] >= i > j，观察2意味着在j轮没有值被选中或将被选择。
    2.  j = k。当接受者在k轮投票了v值，接受者a<sub>0设置vrnd</sub>[a<sub>0</sub>]为k，k > 0且vval[a<sub>0</sub>]为v。因为接受者投票仅当协调者在该轮发送了该v值，每个接受者在k轮要么投票v值要么没有投票。因为Q中所有接受者a，rnd[a] >= i > k，观察3意味着在j轮没有非v的值被选中或将被选择。
    3.  j < k。我们可以假设引入属性CP，当在k轮接受者a<sub>0投票了v值</sub>。这意味着在j轮非v值被选中或将被选择。
    
    设Q为任意接受者的多数集合，在i轮发送了阶段1b消息。
    
    对Q中接受者a，其报告的阶段1b消息中vr(a)和vv(a)为vrnd[a]和vval[a]的值。
    
    k为Q中所有接受者a的vr(a)的最大值。
    
    V为Q中所有vr(a) = k的接受者a的值vv(a)的集合
    
    如果k = 0，则选择任意一个提议值否则V包含一个值v。
    
    这个完整的非形式化CP(v, i)证明满足v = vv(a<sub>0</sub>)。
    
    在阶段2a选择v值的规则描述如上，我们观察到该规则允许协调者在收到多数集合的1b消息且收到一个提议者的提议消息时可以选择一个v值。


<a id="org16b2763"></a>

### 进展


<a id="org2f5fdd7"></a>

# Tips

-   构造简单的模型，设计好方案，代码具体实现就是很简单的事情了


<a id="org76fa629"></a>

# Share

流文件同步

<https://dropbox.tech/infrastructure/streaming-file-synchronization>

我们的用户因各种原因喜欢Dropbox，同步性能是其中最主要的。我们继续最近的性能改进称为流同步，其能提升2倍的同步延迟。

在流同步之前，文件同步分为两个阶段：上传和下载。整个文件必须上传到我们的服务器并提交到我们的数据库，其他客户端才能了解到它的存在。流同步运行文件内容作为流存在我们的服务器和客户端之间。

首先我们将讨论Dropbox存储和同步文件。在本地机器中，Dropbox尝试确认你的系统中的主机文件系统。然而，特别考虑到Dropbox支持共享文件夹，服务端Dropbox文件系统有一个不同的抽象。不像传统的文件系统，只有相对路径是不够的。

我们定义命名空间为对更多传统文件系统目录树根目录的抽象。每个用户拥有一个根命名空间。每个共享目录为一个命名空间，可以加载到一个或多个根命名空间。注意用户拥有命名空间而不是相反。在这个抽象下，在Dropbox服务器下的每个文件和目录可以唯一对应两个值：一个命名空间和一个相对目录。


<a id="org59b354a"></a>

## Dropbox文件格式

Dropbox的每个文件分成4MB大小的块，最后的块可能较小。这些块用SHA-256进行hash并存储。文件内容唯一对应到SHA-256hash列表，我们称为块列表。


<a id="org407299f"></a>

## 服务器文件日志

这是我们的大元数据数据库，代表了我们的文件系统。注意它不包含文件内容，只是块列表。它为只添加记录每一行代表一个文件的特殊版本。关键的列为：

-   命名空间号(NSID)
-   命名空间相对目录
-   块列表
-   日志号(JID)：对一个命名空间来说是单调递增的

两种服务器类型：

-   块数据服务器：维护一个hash的键值存储来加密内容。无法了解用户/文件/块是如何对应的
-   元数据服务器：维护用户数据库，命名空间和服务器文件日志SFJ

服务器通过内部的RPC进行通讯。

我们在流同步之前先讨论Dropbox客户端协议。

每个桌面客户端对每个它的命名空间保存一个在SFJ位置的游标，该游标可以和服务器通讯如何更新。

首先，我们讨论一个上传客户端，当一个文件出现的时候发生了什么。客户端首先尝试提交块列表给服务器（命名空间，路径）。元数据服务器检测是否这些hash值已知及这个用户和命名空间可访问。否则，提交调用返回“需要块”表明哪些块丢失。对文件来说，通常需要上传所有块。

![img](../img/dropbox_client_protocol11.png)

上传客户端必须直接与块服务器通话来添加这些块。我们限制每个请求的字节数，这样可能需要多个请求。

![img](../img/dropbox_client_protocol21.png)

在这个图中，限制为8MB，但我们也试验其他值。

最后，客户端尝试再次提交。这次，它会正常工作。元数据服务器将更新SFJ，添加一个新行。这样文件将出现在Dropbox中。

![img](../img/dropbox_client_protocol31.png)

现在我们看下载客户端。当客户端发现更新有效时，它将发起一个列表调用学习新的SFJ行。列表调用使用每个命名空间的游标作为输入，这样只有新的条目会返回。

![img](../img/dropbox_client_protocol41.png)

空闲客户端维持一个通知服务器的长连接。

一个新文件，我们需要从块中重建。下载客户端首先检查是否块已在本地存在（文件已存在，或在我们的删除文件缓存中）。对新文件，这些检查很可能失败，客户端将直接从块服务器中下载。块服务器检验用户有这些块的访问权限并提供它们。同样，这里可能有多次请求。

![img](../img/dropbox_client_protocol52.png)

现在客户端已有所有的块。它可以重建文件并添加到本地文件系统。我们只展示了一个新文件如何跟客户端同步。我们有不同的线程跟文件系统交互，hash、提交、存储批处理、列表、获取批处理、重建，这允许我们对多文件流水线并行处理。我们使用压缩和远程同步来最小化存储批处理和获取批处理请求的大小。

总结过程，以下是整个的流程图：

![img](../img/dropbox_client_protocol61.png)

典型地，对大文件，同步时间由存储和获取调用的网络时间决定。存储批处理调用发生在SFJ提交之前。列表调用只在SFJ提交后有效。然而，获取批处理依赖提交是没有必要的。这指出我们可优化，该优化我们称之为流同步。我们想要对每个客户端可以部分并行工作。理想情况下下载客户端可以总是只落后一个块服务器网络调用。

![img](../img/dropbox_streamingsyncprotocol1.png)

这样看着会比较好。我们应该如何做来达成这样的效果呢？


<a id="orgf9efc90"></a>

## 高水平改变

对初始化从上传客户端失败的提交开始我们将要维护元数据服务器状态（跟SFJ分离）。这允许下载客户端在SFJ提交前获得进展。下载客户端可以预取那些还没有提交的文件的部分块。这样，当SFJ提交发生时，下载客户端也基本下载完成了。


<a id="org22022dc"></a>

## 协议更改

上传客户端不需要改变它的行为。然而，下载客户端需要监听非SFJ变更。我们通过添加额外的输出到列表来处理。列表现在返回新的SFJ行，新流同步预取块列表。


<a id="orgf510862"></a>

## 元数据服务器变更

我们决定除持久化表外在memchache存储额外的状态。该数据是否持久化不重要，我们选择不考虑写入失败的提交这样额外的成本。memcache条目跟SFJ行相似，除了没有版本控制。这样不需要JID。

-   当失败的提交调用时写入memcache
-   列表处理时从memcache读
-   成功提交调用后删除（memcache驱除）


<a id="org7db932c"></a>

## 客户端变更

当不响应SFJ的文件时客户端需要维护块的预取缓存。客户端对预取进行队列处理，该处理使用预取缓存。在新版客户端中，你可以在".dropbox.cache/prefetch<sub>cache</sub>/"目录找到这些。


<a id="orgac4482a"></a>

## 完成

还有一些东西需要讨论。我们只讨论了上传完整时的正常情况。我们需要确保即使文件没有完整提交，我们也不阻塞该进程。想象开始一个上传并中途改变主意。我们需要确保服务端memcache过期条目且不引起服务震荡。我们需要下载客户端预取缓存定期智能地删除，这样使它不会过度增长。

当访问块时，我们检查memcache表的有效性。因为mamcache条目可能被修改、无效、过期或预取过程中删除，我们需要安排客户端的反馈行为当服务器不能检测块是否满足流同步条件时。这将添加特殊返回值给存储协议来说明这种情况。


<a id="orgf28a4c9"></a>

## 流同步有什么好处？

我们发现流同步只影响那些大文件，需要多次存储/获取请求的，这样我们限制该特征到新的大文件。流同步在多客户端同步时间上提供上达2倍的改进。改进接近2倍是因为文件大小增加相当于上传/下载带宽，但实际上，速度被限制在连接的慢的那端。我们测试两台在相同网络的机器（1.2 mb/s上传，5 mb/s下载）。大约同步时间提高了25%。

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">文件大小 (MB)</td>
<td class="org-right">流同步的同步时间</td>
<td class="org-right">非流同步的同步时间</td>
</tr>


<tr>
<td class="org-right">20</td>
<td class="org-right">21</td>
<td class="org-right">25</td>
</tr>


<tr>
<td class="org-right">40</td>
<td class="org-right">30</td>
<td class="org-right">37</td>
</tr>


<tr>
<td class="org-right">100</td>
<td class="org-right">64</td>
<td class="org-right">89</td>
</tr>


<tr>
<td class="org-right">500</td>
<td class="org-right">293</td>
<td class="org-right">383</td>
</tr>
</tbody>
</table>

![img](../img/dropbox_streamingsyncchart1.png)

当我们首次提供这个特性时，我们跟踪了关键度量像预取块数量、预取缓存大小和memcache hit/miss比例。


---
layout:     post
title:      "Weekly 083"
subtitle:   "Algorithm: Prime Palindrome; Review: Curbing Connection Churn in Zuul; Tips: Swift 5; Share: "
thumbnail-img: ""
date:       2023-10-26 11:40
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org74b1ff3)
2.  [Review](#org72a81e3)
    1.  [文字的过去](#org7308dea)
    2.  [固定流](#org88860a9)
3.  [Tips](#orgb6186e5)
    1.  [运算符](#orgcc01ec5)
4.  [Share](#org5bcb15d)


<a id="org74b1ff3"></a>

# Algorithm

Leetcode 866: [Prime Palindrome](https://leetcode.com/problems/prime-palindrome/description/)

<https://dreamume.medium.com/leetcode-866-prime-palindrome-1eaf3748c375>


<a id="org72a81e3"></a>

# Review

[Curbing Connection Churn in Zuul](https://netflixtechblog.com/curbing-connection-churn-in-zuul-2feb273a3598)


<a id="org7308dea"></a>

## 文字的过去

当 Zuul 设计开发后，有一个内在的假设连接是高效免费的，给定不使用手工的 TLS（mTLS）。它基于 Netty 构建，使用事件循环非阻塞式执行请求，每个核一个循环。为减少事件循环的竞争，我们对每个循环创造连接池，使它们完全独立。结果是整个请求响应循环发生在同一个线程，显著减少上下文切换

还有一个明显的下行。这意味着如果每个事件循环有一个连接池连接到每个源（后台）服务器，则服务器上 Zuul 实例有多个事件循环。例如，一个 16 核连接到一个 800 服务器源有 12800 个连接。如果 Zuul 簇有 100 个实例，则有 1280000 个连接。这是一个很大的数量且在多数簇上比相关必要的流量要多

当流随着每年增长，更多的 Zuul 和源簇导致数量更大。更精确地说，如果一个流量高峰发生且 Zuul 实例扩展，它将使到源的连接指数级增长。虽然这是一个长期以来的已知问题，它未成为关键痛点直到我们移动大量流应用程序到 mTLS 和我们基于 Envoy 的服务网格


<a id="org88860a9"></a>

## 固定流

改进过度连接的第一步是实现 HTTP/2 多路复用到源。多路复用允许通过创建每个连接多个流来重用现存的连接，每个可以发送一个请求。与每个请求需要一个连接不同，我们可对许多同时的请求重用相同的连接。我们重用的连接越多，在建立 mTLS 会话需要的来回、握手等就越少

虽然 Zuul 有时有 H2 代理，它不支持多路复用。它只是把 H2 连接当作 HTTP/1（H1）连接。向后兼容现存的 H1 功能，我们修改 H2 连接改进来创建一个流且立即释放连接到池中。后来的请求将可以重使用现存的连接而不需要新创建一个。理想情况下，到每个源服务器的连接应该趋于每事件循环有一个。这看着是一个小改动，但它已无缝集成到我们现在的度量和连接记录中

通过 TLS 初始化 H2 连接的标准化方法是通过 ALPN（应用层协议协商）升级。ALPN 允许我们优雅地降级到 H1 如果源不支持 H2，这样我们可广泛地启动它而不影响客户。服务网格在许多服务上有效使得测试和回滚该特性非常容易因为它默认启动 ALPN。这意味着在服务网格和 mTLS 上的服务不需要任何额外工作

可惜地是，当我们回滚多路复用时我们的计划遇到了一个问题。虽然特性是稳定的且对功能没有影响，我们对过度连接没有得到减少。因为一些源簇太大，且我们从所有事件循环连接它们，没有足够现存的连接复用来触发多路复用。甚至我们现在可用多路复用，我们却不能利用它


<a id="orgb6186e5"></a>

# Tips

Swift 核心技术与实战    张杰


<a id="orgcc01ec5"></a>

## 运算符

Swift 在支持 C 中大多数标准运算符的同时也增加了一些排除常见代码错误的能力：

-   赋值符号（=）不会返回值，以防它被误用于等于符号（==）
-   算数符号（+，-，\*，/，% 以及其他）可以检测并阻止值溢出

三个支持溢出的运算符：

-   &+
-   &-
-   &\*

类和结构体可以为现有的运算符提供自定义的实现，称为运算符重载

    struct Vector2D {
        var x = 0.0, y = 0.0
    }
    
    extension Vector2D {
        static func + (left: Vector2D, right: Vector2D) -> Vector2D {
            return Vector2D(x: left.x + right.x, y: left.y + right.y)
        }
    }
    
    let vector = Vector2D(x: 3.0, y: 1.0)
    let another = Vector2D(x: 2.0, y: 4.0)
    let combined = vector + another

类与结构体也能提供标准一元运算符的实现，要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定符

    extension Vector2D {
        static prefix func - (vector: Vector2D) -> Vector2D {
            return Vector2D(x: -vector.x, y: -vector.y)
        }
    }
    
    let vector = Vector2D(x: 3.0, y: 1.0)
    let negative = -vector

组合赋值运算符将赋值运算符（=）与其他运算符进行结合，在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改

    extension Vector2D {
        static func += (left: inout Vector2D, right: Vector2D) {
            return left = left + right;
        }
    }
    
    var original = Vector2D(x: 1.0, y: 2.0)
    let toAdd = Vector2D(x: 3.0, y: 4.0)
    original += toAdd

自定义类和结构体不接受等价运算符的默认实现，也就是所谓的“等于”运算符（==）和“不等于”运算符（！=），要使用等价运算符来检查你自己类型的等价，需要和其他中缀运算符一样提供一个“等于”运算符重载，并且遵循标准库的 Equatable 协议

    extension Vector2D : Equatable {
        static func == (left: inout Vector2D, right: Vector2D) -> Bool {
            return (left.x == right.x) && (left.y == right.y)
        }
    }

Swift 为以下自定义类型提供等价运算符合成实现：

-   只拥有遵循 Equatable 协议存储属性的结构体
-   只拥有遵循 Equatable 协议关联类型的枚举
-   没有关联类型的枚举

    struct Vector3D : Equatable {
        var x = 0.0, y = 0.0, z = 0.0
    }
    
    let vector = Vector3D(x: 2.0, y: 3.0, z: 4.0)
    let another = Vector3D(x: 2.0, y: 3.0, z: 4.0)
    if (vector == another) {
        print("These two vectors are also equivalent.")
    }

除了实现标准运算符，在 Swift 当中还可以声明和实现自定义运算符（custom operators），新的运算符要在全局作用域中，使用 operator 关键字进行声明，同时还要指定 prefix、infix 或者 postfix 限定符

    prefix operator +++
    extension Vector2D {
        static prefix func +++ (vector: inout Vector2D) -> Vector2D {
            vector += vector
            return vector
        }
    }
    
    let vector = Vector2D(x: 2.0, y: 3.0)
    let afterDoubling = +++vector

自定义的中缀（infix）运算符也可以指定优先级和结合性，每一个自定义的中缀运算符都属于一个优先级组，优先级组指定了自定义中缀运算符和其他中缀运算符的关系

    precedencegroup MyPrecedence {
        associativity: left
        lowerThan: AdditionPrecedence
    }

          infix operator +-: AdditionPrecedence
          extension Vector2D {
              static func +- (left: Vector2D, right: Vector2D) -> Vector2D {
                  return Vector2D(x: left.x + right.x, y: left.y - right.y)
              }
          }
    
    //      infix operator *^: MultiplicationPrecedence
          infix operator *^: MyPrecedence
          precedencegroup MyPrecedence {
              associativity: left
              lowerThan: AdditionPrecedence
          }
    
          extension Vector2D {
              static func *^ (left: Vector2D, right: Vector2D) -> Vector2D {
                  return Vector2D(x: left.x * right.x, y: left.y * left.y + right.y * right.y)
              }
          }
    
          let first = Vector2D(x: 1.0, y: 2.0)
          let second = Vector2D(x: 3.0, y: 7.0)
          let plusMinusVector = first +- second
          let third = Vector2D(x: 2.0, y: 2.0)
          let vector = first +- second *^ third
          print(vector.x)
          print(vector.y)


<a id="org5bcb15d"></a>

# Share


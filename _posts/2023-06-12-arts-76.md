---
layout:     post
title:      "Weekly 076"
subtitle:   "Algorithm: Minimize the Total Price of the Trips; Review: The Design of a Practical System for Fault-Tolerant Virtural Machines; Tips: Y Combinator and C++; Share: "
thumbnail-img: ""
date:       2023-06-12 11:30
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org9d238bf)
2.  [Review](#org4b07b6c)
    1.  [简介](#org18f7d2e)
3.  [Tips](#org99a30f9)
    1.  [Lambda 微积分](#org09cc298)
    2.  [固定点 Combinator](#org64e21eb)
    3.  [如何克服懒加载](#org2415af6)
    4.  [柯里化的 Y Combinator](#orga006356)
4.  [Share](#orgcf41ef1)


<a id="org9d238bf"></a>

# Algorithm

Leetcode 2646: [Minimize the Total Price of the Trips](https://leetcode.com/problems/minimize-the-total-price-of-the-trips/)

<https://dreamume.medium.com/leetcode-2646-minimize-the-total-price-of-the-trips-48d4e9401d23>


<a id="org4b07b6c"></a>

# Review

[The Design of a Practical System for Fault-Tolerant Virtural Machines](https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf)

我们已实现了一个商业企业级系统提供容错虚拟机，基于在另一台服务器上通过后台虚拟机复制主虚拟机的执行的方式。我们已在 VMware vSphere 4.0 上设计了一个完整的系统，其易使用，运行在商业服务器上且典型地减少实际应用程序 10% 的性能。另外，对几个真实的应用程序，数据带宽需要在主和副虚拟机上执行 lockstep 保持少于 20 Mbit/s，允许长距离容错实现的可能性。一个容易使用，故障后自动恢复冗余的商业系统在复制虚拟机执行上需要许多额外的组件。我们设计和实现了这些额外的组件和在运行企业级应用程序支持的虚拟机上处理许多实际的问题。在本文中，我们描述我们的基本设计，讨论替代设计选择和一些实现细节，且提供微评测和实际的应用程序的性能结果


<a id="org18f7d2e"></a>

## 简介

一个通常的实现容错服务器的方案时主/备份方式，一个备份服务器在主服务器故障时总是有效地进行接管。备份服务器的状态必须保存在所有时刻对主服务器是确定的，这样当主服务器故障时备份服务器可立刻接管，且这样故障对外部客户隐藏且没有数据丢失。在备份服务器上复制状态的一个方法是移植主服务器的所有状态改变，包括 CPU，内存和 I/O 设备，在备份服务器几乎连续地处理。然而，发送这个状态的带宽，特别是内存的改变，可能会非常大

一个不同的办法是复制服务器使用更少的带宽有时作为一种状态机方案。想法是模型服务器作为一个确定性状态机从相同的初始化状态开始保持同步且确保它们以相同的顺序接收到相同的输入请求。因为多数服务器或服务有一些操作是不确定性的，一些额外的条件需要使用来确保一个主服务器和备份服务器同步。然而，保持主服务器和备份服务器同步的额外信息的总数远小于主服务器改变的状态总数（主要是内存更新）

实现协调来确保确定性物理服务器执行是困难的，特别是作为处理器频率的增加。相反地，一个运行在 hypervisor 上的虚拟机是实现状态机方案的优秀平台。一个虚拟机可考虑为一个良好定义的状态机，其操作是虚拟的机器操作（包括所有它的设备）。作为一个物理服务器，虚拟机有一些非确定性操作（例如，读一个时钟或转发一个中断），且这样额外的信息必须被发送到备份服务器来确保它已同步。因为 hypervisor 有对虚拟机执行的完全控制，包括转发所有输入，hypervisor 能够抓获在主虚拟机上非确定性操作的所有必要的信息且在备份虚拟机上正确地重放这些操作

因此，状态机方案可在基于商业硬件在虚拟机上实现，不需要硬件修改，允许对最新的处理器立即地容错。另外，对状态机方案的低带宽要求允许主服务器和备份服务器的更大的物理隔离的可能性。例如，复制的虚拟机可运行在跨校园的分布式物理机上，提供比相同建筑里运行的虚拟机更多的可靠性

我们以主/备份方式在 VMware vSphere 4.0 平台上实现了容错，其以一个高效地方式运行完全的 x86 虚拟机。因为 VMware vSphere 实现了一个完整的 x86 虚拟机，我们能对任意 x86 操作系统和应用程序自动提供容错。基本的技术允许我们记录主服务器的执行且确保备份服务器知道确定性的回放。VMware vSphere 容错基于确定性的回放，但添加了必要的额外信息和功能来构建一个完整的容错系统。为了提供硬件容错，我们的系统自动在一个故障后恢复容错，通过在本地簇上任意有效的服务器上开启一个新的备份虚拟机。这时，确定性回放和 VMware FT 的产品版本只支持单处理器虚拟机。在多处理器虚拟机上记录和回放执行仍然在研发中，由于几乎每个访问恭喜内存都可能是一个非确定性操作导致对性能有显著的影响

Bressoud 和 Schneider 描述了一个 HP-RISC 平台容错虚拟机的原型实现。我们的处理相似，但我们因性能原因和一些替代性设计有一些基本上的不同。另外，我们设计和实现了系统许多额外的组件且处理一些实际问题来构建一个完整系统，使其高效且对运行企业级应用程序的用户有用。同其他实际系统讨论相似，我们只尝试处理故障停止故障，即服务器故障在导致一个不正确额外可见行为前可被检测

本文的后续组织如下。首先，我们描述我们的基本设计和我们基本协议细节确保一个备份虚拟机在主虚拟机故障后接管不会有数据丢失。然后，我们详细描述许多必须处理的实际问题来构建一个健壮，完整和自动化系统。我们也描述一些实现虚拟机容错的设计选择和讨论这些选择的妥协。接着，我们对我们的实现在一些评测和一些实际的企业级应用程序上给出性能结果。最后，我们描述相关工作


<a id="org99a30f9"></a>

# Tips

[Y Combinator and C++](https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/)

搜索 Y combinator，第一个出现的是 Paul Graham 的孵化器公司 Y Combinator。我不确定是否 Paul 喜欢这个 - 作为一个 Lisp 骇客，他一定非常喜欢 Y combinator 并用它给他的公司命名。但现在人们查找数学/编程概念则不是需要他公司的信息。如果他还是一个 Lisp 骇客，他会感到一些抱歉，虽然这样会表面上对他的公司有利

Y combinator 是一个有趣的概念。当我第一次看到时，我花费了整个周末阅读并学习它。然而， 我还是不能完全理解。人们认为 Y combinator 在函数式编程中一个重要的概念：

我们可使用 Y combinator 类似的知识作为函数式程序员（对函数式编程有相当深入了解）和其他程序员的分割线

有很多现有的资料介绍 Y combinator，但我还不知道有为 C++ 程序员写的。我愿意填补这个空缺

即我依然开始用函数式语言，但你，作为读者，不需要知道任何相关知识。聚集于概念，我将显示运行的 C++ 代码

现在旅行开始


<a id="org09cc298"></a>

## Lambda 微积分

当然你可找到大量的材料介绍 lambda 微积分，且我将足够的描述基本概念对 C++ 程序员。除了通常的定义求平方方法 sqr(x) = x \* x，我们可定义它作为一个 lambda 表达式

$ \\text { sqr } = \\lambda x . \\chi \\cdot \\chi $

这是 Haskell 和 Scheme 定义函数的方式，但语法有些不同

Haskell:

sqr = \\ x -> x \* x

Scheme:

    (define sqr (lambda (x) (* x x)))

关键的好处是你不需要一个函数名。为了求 3 的 sqr，我们可简单写成：

$ \\( \\lambda \\chi . \\chi \\cdot \\chi \\) 3 $

C++ 代码打印结果为

    cout << [](int x) { return x * x; } (3) << endl;

然而，考虑到 C++ 语法不能清晰看到 lambda 表达式，使用一个名字更合适

    auto const sqr = [](int x) { return x * x; };
    cout << sqr(3) << endl;

一个 lambda 表达式可转换为一个函数对象，代码如下：

    function<int(int)> const sqr = [](int x) { return x * x; };
    cout << sqr(3) << endl;


<a id="org64e21eb"></a>

## 固定点 Combinator

一个固定点 combinator 是一个更高序函数满足如下等式：

$ yf = f(yf) $

我们看到这个定义可引出无限的扩展

$ yf = f(yf) = f(f(yf)) = f(\\ldots f(yf)\\ ldots) $

这就是它强大之处。如果函数 y 给出，则能以一个非递归方式定义一个递归函数！以下是一个例子

fact n = If IsZero n then 1 else n \* fact(n-1)

假设一个函数 F 存在使得 fact = yF

(yF)n = If IsZero n then 1 else n \* (yF)(n-1)

F(yF)n = If IsZero n then 1 else n \* (yF)(n-1)

用 f 替换 yF:

Ffn = If IsZero n then 1 else n \* f(n-1)

我们现在给出一个函数 F 可用非递归形式定义。在 Haskell 中我们可定义 factorial 如下

fix f = f (fix f)

fact = fix $ \\ f n -> if (n == 0) then 1 else n \* f (n - 1)

这个定义有两个问题：

-   它只能在懒语言如 Haskell 中使用
-   在 fix 定义中出现递归

我们先解决第一个问题


<a id="org2415af6"></a>

## 如何克服懒加载

Haskell 的懒加载非常强大，但它在其他语言中无效。解决方案非常简单：一个额外的间接层。一个 lambda 表达式在参赛给出前不求值，这样如下转换可行：

$ f \\Rightarrow \\lambda \\chi . f \\chi $

下面代码在 Scheme 上可行：

    (define Y
      (lambda (f)
        (f (Y f)))
    
    (define F
      (lambda (f)
        (lambda (n)
          (cond 
           ((eq? n 0) 1)
           (else (* n f (- n 1)))))))
    
    (define fact (Y F))

让我们先分析一下类型。这对我们的 C++ 实现非常重要，且错误理解类型会导致我们认为 Y combinator 在 C++ 中不能实现。一个类 Haskell 记号使用如下：

-   **f(in F):** int -> int
-   **F f:** int -> int
-   **Y F:** int -> int
-   **F:** (int -> int) -> int -> int
-   **Y:** ((int -> int) -> int -> int) -> int -> int

我们可看到 f，F f 和 Y F 都是首序函数，一个整数参数返回一个整数。因此，F 是一个两序函数带一个首序函数返回一个首序函数。我们的 Y 带一个两序函数如 F，返回一个首序函数

Yf 是一个首序函数，我们现在可应用 $ \\eta- $ 抽象消除无限扩展。如下 Y 的定义在更严格的 Scheme 语言上可以运行

    (define Y
      (lambda (f)
        (f (lambda (x) ((Y f) x)))))

同时，如下是 C++ 代码实现

    #include <iostream>
    #include <functional>
    
    using namespace std;
    
    template <typename T, typename R>
    function<R(T)> Y(function<function<R(T)>(function<R(T)>)> f) {
      return f([=](T x) { return Y(f)(x); });
    }
    
    typedef function<int(int)> fn_1ord;
    typedef function<fn_1ord(fn_1ord)> fn_2ord;
    
    fn_2ord almost_fact = [](fn_1ord f) {
      return [f](int n) {
        if (n == 0) return 1;
        else return n * f(n - 1);
      };
     };
    
    int main() {
      fn_1ord fact = Y(almost_fact);
      cout << "fact(5) = " << fact(5) << endl;
    
      return 0;
    }


<a id="orga006356"></a>

## 柯里化的 Y Combinator

现在我们回到处理递归定义问题。在实际使用中它可能不是一个问题，但它非常有趣。解决方案是我们总是统计，Y combinator，属于 Haskell 的柯里化。它也是难以理解的，像自引用迷宫或悖论。我对之很好奇，这也是我写这篇博客的原因

有一些好的引用关于 Y combinator 的起源，我这里简单呈现结果如下：

$ Y = \\lambda f . (\\lambda \\chi . f(\\chi \\chi)) (\\lambda \\chi . f(\\chi \\chi)) $

我也想要显示这个定义满足固定点等式:

$ \\begin{aligned} Y F &= (\\lambda f . (\\lambda \\chi . f(\\chi \\chi)) (\\lambda \\chi . f(\\chi \\chi))) F \\qquad \\text{(扩展 Y)} \\\\ &= (\\lambda \\chi . F(\\chi \\chi)) (\\lambda \\chi . F (\\chi \\chi)) \\qquad (\\beta \\text{ -reduction on the bound variable f}) \\\\ &= F(( \\lambda \\chi . F(\\chi \\chi)) (\\lambda \\chi . F(\\chi \\chi))) \\qquad (\\beta \\text{ -reduction on the first bound variable } \chi) \\\\ &= F(Y F) \\end{aligned} $

注意有一个相等的形式（ $ \\beta $ -reduce it once to get the Y above）:

$ Y = \\lambda f . (\\lambda \\chi . \\chi \\chi) (\\lambda \\chi . f(\\chi \\chi)) $

基本上，这是在懒加载 Scheme 上的定义：

    (define Y
      (lambda (f)
        ((lambda (x) (x x))
         (lambda (x) (f (x x))))))

重新调用 Y 的函数参数 - 上面的 f - 把第一序函数作为参数，我们知道 $ \\chi \\chi $ 应该返回一个首序函数。这样我们可应用 $ \\eta- $ 抽象来获得严格的 Scheme 版本

    (define Y
      (lambda (f)
        ((lambda (x) (x x))
         (lambda (x) (f (lambda (y) ((x x) y)))))))

在用 C++ 实现之前，我们有一个困难。一个严格类型的语言不能定义出函数 $ \\chi \\chi $，需要用一个代理对象糊弄一下类型系统

这里是 C++ 实现：

    template <typename F>
    struct self_ref_func {
      function<F(self_ref_func)> fn;
    };

这种类型的对象包含一个函数把它自己的类型作为一个对象并返回一个模板类型的对象，其为一个函数：

    typedef function<int(int)> fn_1ord;
    typedef self_ref_func<fn_1ord> fn_self_ref;
    fn_self_ref x = { ... };        // assign a suitable value to x
    x.fn(x)

使用这个自引用类型，Y combinator 的柯里化可最终用 C++ 实现:

    template <typename T, typename R>
    function<R(T)> Y(function<function<R(T)>(function<R(T)>)> f) {
      typedef function<R(T)> fn_1ord;
      typedef self_ref_func<fn_1ord> fn_self_ref;
      fn_self_ref f = {
        [f](fn_self_ref x) {
          return f(fn_1ord([x](T y) {
            return x.fn(x)(y);
          }));
        }
      };
    
      return r.fn(r);
    }


<a id="orgcf41ef1"></a>

# Share


---
layout:     post
title:      "Weekly 032"
subtitle:   "Algorithm: ; Review: ; Share:introduction to algorithm, chapter 34, NP-Completeness"
thumbnail-img: ""
date:       2020-11-18 20:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#orge23303e)
2.  [Review](#org54a2972)
3.  [Tips](#org862ee95)
4.  [Share](#orgd94fe42)
    1.  [多项式时间](#org26c236f)
        1.  [抽象问题](#orgef03752)
        2.  [编码](#orgbca0dff)
        3.  [形式语言框架](#org882a1a9)


<a id="orge23303e"></a>

# Algorithm

Leetcode 


<a id="org54a2972"></a>

# Review

xxx


<a id="org862ee95"></a>

# Tips

-   xxx


<a id="orgd94fe42"></a>

# Share

《算法导论》第34章NP完全问题

本章将介绍NP算法

目前我们学过的绝大多数算法都是多项式算法：对输入大小为n，最坏情况下运行时间为O(n<sup>k</sup> )，k为某个常量。然而，不是所有算法都能在多项式时间内解决。例如，图灵著名的“停机问题”，不能被任何计算机解决，也有一些问题可以解决，但不能在O(n<sup>k</sup> )时间内解决。一般地，我们认为多项式时间内能解决的问题是可跟踪的，简单的，需要超多项式时间的问题是不能跟踪的，困难的。

本章的主题是那些NP完全问题，目前没有发现NP完全问题的多项式时间算法，也没有人证明没有多项式时间算法存在。这被称为P != NP问题，其被认为自1971年在理论计算机科学中提出以来最艰深、最模糊不清的开放研究问题之一。

一些NP完全问题非常有趣因为它们表面上看似乎跟一些多项式问题很相似。下面的这对问题，一个有多项式时间解，另一个是NP完全，但他们之间的不同是差别很小的。

最短 vs 最长路径：在第24章中，我们看到即使边的权重为负，我们也能在O(VE)时间内找到在图G = (V, E)中从一个原点的最短路径。然而找到两个点之间的最长路径很困难。决定是否一个图中在给定一系列边时有一个简单路径是NP完全问题。

欧拉旅行 vs 哈密尔顿回路：一个连接、有向的图G(V, E)的欧拉旅行是一个循环，访问G中每条边一次，虽然它允许访问每个点多次。在问题22-3中，我们可以确定在O(E)时间内一个图是否有一个欧拉旅行路径，事实上，我们可以在O(E)时间内找到欧拉旅行的边。一个有向图G = (V, E)的汉密尔顿回路是一个循环，包含V中每个点一次。决定是否一个有向图有汉密尔顿回路是NP完全问题（本章后面，我们将证明决定是否一个无向图有汉密尔顿回路是一个NP完全问题）。

2-CNF满足 vs 3-CNF满足：一个布尔形式包含值为0或1的变量；布尔连接为 $ \\wedge(\\mathrm{AND}), \\vee(\\mathrm{OR}), \\text { and } \\neg \\text { (NOT) } $ 和括号；一个布尔形式是满足的如果存在对其变量的一些赋值使其结果为1.我们将在之后定义更形式化的术语，非形式化的，一个布尔形式是k连接正常形式，或k-CNF，如果它与、或k个变量或其非值。例如，布尔形式 $ \\left(x_ {1} \\vee \\neg x_ {2}\\right) \\wedge\\left(\\neg x_ {1} \\vee x_ {3}\\right) \\wedge\\left(\\neg x_ {2} \\vee \\neg x_ {3}\\right) $ 是2-CNF（当x<sub>1</sub> = 1, x<sub>2</sub> = 0, x<sub>3</sub> = 1是满足）。虽然我们能在多项式时间内确定一个2-CNF形式是否满足，我们将在本章之后知道确定是否一个3-CNF形式是否满足是NP完全问题。

本章中，我们将说明3类问题：P，NP和NPC，最后这类为NP完全问题。这里我们先非形式化的描述它们，我们将在之后更形式化的定义它们。

P类包含那些能在多项式时间内解决的问题。即在O(n<sup>k</sup> )时间复杂度内解决的问题，k为某个常数，n为问题输入的大小。之前章节的大多数问题为P类问题。

NP类包含那些能在多项式时间内验证的问题。验证指如果我们给出一个解决方案的证明，则我们可以在问题输入大小的多项式时间内验证正确性。例如，在汉密尔顿回路问题中，给定一个有向图G = (V, E)，一个证明为\| V \| 顶点的一系列点 $ \\left\\langle\\nu_ {1}, v_ {2}, v_ {3}, \\ldots, v_ {\|V\|}\\right\\rangle $ ，我们容易在多项式时间内检查 $ \\left(v_ {i}, v_ {i+1}\\right) \\in E \\text { for } i=1,2,3, \\ldots,\|V\|-1 $ 及 $ \\left(v_ {\|V\|}, v_ {1}\\right) \\in E $ 。另一个例子，对3-CNF，一个证明为给变量赋值。我们可以在多项式时间内检查该赋值是否使布尔形式满足。

P中的任意问题也在NP中，因为如果一个P中的问题我们可以在多项式时间内解决并不提供一个证明。我们会在之后形式化这些记号，但现在我们可相信 $ \\mathrm{P} \\subseteq \\mathrm{NP} $ 。开放问题为是否P是NP的子集。

非正式地，NPC类的问题我们称之为NP完全问题，如果它是NP的且跟NP问题一样难解。同时，我们将表述但并未证明，如果任意NP完成问题可以在多项式时间内解决，则NP的每个问题都会有多项式算法。大多数理论计算机科学家相信NP完全问题是不可追溯的，因为对于目前所学习到的大范围的NP完全问题，没有人发现任何多项式时间的解决方案，如果所有这些问题都能在多项式时间内解决，这将会是非常令人震惊的事情。

作为好的算法设计者，你必须理解NP完全理论的基本知识。如果你确定一个问题是NP完全的，你知道它是不可追溯的。作为一个工程师，你应该花费时间开发一个近似算法或解决一个可追溯的特殊示例，而不是研究精确解决问题的快速算法。更进一步地，许多自然有趣的问题表面上看不比排序、图搜索或网络流复杂，而事实上却是NP完全问题。因此，你需要熟悉这类问题。

我们使用用来显示特殊问题为NP完全问题的技术跟本书多数设计分析算法的技术有根本性的不同。当我们表示一个问题是NP完全的时候，我们表述它如何困难（或至少我们认为它是如何困难的），而不是表述如何简单。我们不会尝试证明一个有效算法的存在，而是说明很可能不存在有效的算法。

我们依赖3个关键概念来展示一个问题是NP完全问题：

决定问题 vs 优化问题

许多问题为优化问题，每个解有一个值，我们希望找到最好的值。例如，我们称最短路径问题，我们给定一个无向图G和顶点u和v，我们希望找到一个从u到v的路径，使用最少的边。NP完全问题跟优化问题不同，其为决定问题，答案为是或者否。

虽然NP完全问题为决定问题，我们可在优化问题和决定问题之间建立一个方便的联系。我们通常转换一个给定的优化问题作为相关的决定问题，通过引入一个可优化的值边界。例如，最短路径决定问题对应于一个路径：给定一个有向图G，顶点u和v，及一个整数k，存在一个从u到v最多包含k个边的路径吗？

优化问题和它对应的决定问题的关系可简单表述为显示优化问题有多难。因为决定问题似乎容易些，或至少不会更难。例如，我们解决路径问题通过解决最短路径然后比较在找到的最短路径里的边数和参数k对应的决定问题值。如果一个优化问题是容易的，它对应的决定问题也是容易的。如果我们能提供证据显示决定问题很难，我们也能提供证据证明其对应的优化问题也难。这样，NP完全问题的理论通常意味着为一个优化问题。

以上的记号显示一个问题不比另一个问题容易或困难即使两个问题都是决定问题。我们会在几乎所有的NP完全证明上用到这个想法。让我们考虑一个决定问题A，我们想要在多项式时间内解决。我们称一个特定问题的输入为一个问题的实例。例如，在路径中，一个实例为一个特殊的图G，特定的顶点u和v，和一个特别的整数k。现在假设我们已经知道如何在多项式时间内解决一个不同的决定问题B。最后，假设我们有一个过程转换任何A的实例 $ \\alpha $ 为B的某个实例 $ \\beta $，其有如下特征：

-   转换为多项式时间
-   答案相同。$ \\alpha $ 的答案为是当且仅当 $ \\beta $ 的答案也是是

我们称这样的过程为多项式时间缩减算法，它提供了一种在多项式时间内解决问题A的办法：

1.  给定一个问题A的实例 $ \\alpha $ ，使用一个多项式缩减算法转换它为B问题的一个实例 $ \\beta $
2.  在实例 $ \\beta $ 上运行B的多项式时间确定性算法
3.  使用 $ \\beta $ 的答案作为 $ \\alpha $ 的答案

回忆NP完全问题是显示问题如何困难而不是如何容易，我们使用多项式时间缩减来反向展示该问题是NP完全的。让我们更进一步，显示我们如何使用多项式缩减来显示对特殊的问题B没有多项式算法存在。假设我们有一个决定问题A，我们已经知道不存在它的多项式时间算法。假设我们有一个多项式缩减转换A的实例到B的实例。现在我们可使用一个简单地证明引出矛盾来说明不存在B的多项式时间算法。假设B有一个多项式时间算法，则我们有一个方法可以在多项式时间内解决问题A，这跟我们假设不存在A的多项式时间算法矛盾。

对NP完全问题，我们不能假设绝对没有问题A的多项式时间算法。

因为缩减技术依赖于有一个问题已知为NP完全的来证明另一个不同的NP完全问题，我们需要一个NP完全问题。我们将使用电路满足问题，我们给定一个布尔组合电路为AND、OR和NOT的电路门的组合，我们希望知道是否存在一些布尔输入集合使电路输出为1。


<a id="org26c236f"></a>

## 多项式时间

我们开始我们的NP完全问题的学习，先形式化多项式时间解决问题的符号标记。我们已经认为这些问题是可追溯的，基于哲学而不是数学原因。我们可以提供3个支持的论点。

首先，虽然我们认为一个问题需要时间 $ \\Theta (n^{100}) $ 是可追溯的，只有少数实际问题需要如此高的多项式维度。多项式时间可计算问题在实际中通常只需要更少的时间。经验显示一旦一个问题的多项式时间算法被发现，更有效的算法会随后出现。即使当前问题的最好算法需要时间复杂度为 $ \\Theta (n^{100}) $ ，更好的算法会很快出来。

其次，对许多技术推理模型，一个问题可在一个模型中用多项式时间解决则也可以在另一个模型中用多项式时间内解决。例如，本书中通过串行随机访问机器在多项式时间内解决的那些问题也可以同抽象图灵机在多项式时间内解决。通用对于并行计算机在多项式时间内解决的问题，随着输入尺寸的多项式增长处理器个数也同样增长。

第三，多项式时间内解决的问题有很好的闭合属性，即多项式对加法、乘法和组合是闭合的。例如，如果一个多项式时间算法的输出是另一个的输入，则组合算法也是多项式的。


<a id="orgef03752"></a>

### 抽象问题

为理解多项式时间可解决的问题，我们必须首先有一个形式化的什么是问题的记号。我们定义一个抽象问题Q为问题实例的集合I和问题解决方案的集合S的二进制关系。例如，一个最短路径实例为图和两个顶点的三元组。一个解决方案是图的一系列顶点，及可能的空系列表示路径不存在。最短路径问题本身为图和两个顶点及图中连接两个顶点的最短路径的实例关系。因为最短路径不需要唯一，一个问题实例可能有多个解决方案。

抽象问题的形式化比我们需要的目的更一般化。NP完全问题的理论限制为决策问题：有一个是或否的解决方案。因此，我们可以把抽象决策问题作为一个函数映射为解决方案集合{0, 1}的实例集合I。例如，一个最短路径的决策问题为一个之前我们描述的那样的路径。如果i = <G, u, v, k> 是一个决策问题路径实例，则PATH(i) = 1（是）如果从u到v有一个最多k条边的路径，否则PATH(i) = 0（否）。许多抽象问题不是决策问题，而是优化问题，需要一些值来最大化或最小化。然而，通常我们比较容易地转换一个优化问题为一个决策问题。


<a id="orgbca0dff"></a>

### 编码

为了让计算机程序解决抽象问题，我们必须以程序能理解的方式表示问题实例。抽象对象的集合S的编码为一个从S到二进制字符串集合的映射e。例如，我们熟悉把自然数 $ \\mathbb{N} = \\{ 0, 1, 2, 3, 4, \\ldots \\} $ 编码为字符串 $ \\{ 0, 1, 10, 11, 100, \\ldots \\} $ 。使用这样的编码，e(17) = 10001。如果你查看键盘字符的计算机表示，你会看到ascii码，例如，A的编码为1000001。我们通过组合对象的各部分可以编码一个复杂的对象为二进制字符串。多边形、图、函数、有序对、程序，都能编码为二进制字符串。

这样，一个计算机算法解决一些抽象决策问题可编码问题实例作为输入。我们称问题实例集合为二进制字符串集合的问题为实问题。我们说一个算法在O(T(n))时间内解决一个实问题仅当它提供一个长度为n = \| i \| 的问题实例i，算法能在O(T(n))时间内生成解决方案。一个实问题是多项式时间可解决的，如果存在一个算法能在O(n<sup>k</sup> )时间内解决，k为某个常数。

我们现在可以形式化定义P类复杂度为可多项式时间内解决的实决策问题集合。

我们使用编码映射抽象问题到实问题。给定一个抽象决策问题Q映射为{0, 1}的实例集合，一个编码 $ e: I \\rightarrow \\{0, 1\\}^{*} $ 可推导对应的实决策问题，我们记为e(Q)。如果一个抽象问题实例 $ i \\in I $ 的解决方案为 $ Q\\left( i \\right) \\in \\{0, 1\\} $ ，则实问题实例 $ e \\left( i \\right) \\in \\{ 0, 1 \\}^{ * } $ 的解决方案也是Q(i)。细节上，一些二进制字符串可能表达无具体意义的抽象问题实例。为方便起见，我们将假设任何这样的字符串映射到0。这样，实问题产生和抽象问题在二进制字符串实例的相同解决方案代表抽象问题实例的编码。

我们想通过编码扩展多项式时间可解决的定义从实问题到抽象问题，但我们想要定义跟任何特定编码独立。解决问题的有效性应该不依赖问题如何编码。不幸地是，它严重依赖编码。例如，假设提供一个整数k作为算法的输入，假设算法运行时间为 $ \\Theta \\left( k \\right) $ 。如果整数k以一元的方式提供，k个1的字符串，则算法运行时间在n长度的输入时为O(n)。如果我们使用整数k的更自然的二进制表示，则输入长度为 $ n = \\lfloor \\log k \\rfloor + 1 $。这样运行时间为 $ \\Theta \\left( k \\right) = \\Theta \\left( 2^{n} \\right) $ 。这样，由于编码，算法运行时间为多项式时间或超多项式时间。

我们如何编码一个抽象问题关系到我们如何理解多项式时间。我们不能在不指定编码的情况下谈论抽象问题的解决。实际上，如果我们防止发生昂贵的编码，比如一元编码，问题的实际编码跟问题是否能在多项式时间内解决差不多。例如，基于3为底代表整数而不是二进制跟问题是否能在多项式时间内解决完全没有影响，因为可在多项式时间内转换3为底的整数为二进制。

我们说一个函数 $ f : \\{0, 1 \\}^{ * } \\to \\{ 0, 1 \\}^{ * } $ 为多项式时间可计算的仅当存在一个多项式时间算法A，给定任意输入 $ x \\in \\{0, 1\\}^{ * } $ ，产生一个输出f(x)。对一些问题实例集合I，我们说两个编码e<sub>1</sub> 和e<sub>2</sub> 是多项式相关的仅当存在两个多项式时间计算函数f<sub>12</sub> 和f<sub>21</sub> ，使得对任意 $ i \\in I $，我们有 $ f_ {12}\\left(e_ {1}\\left( i \\right)\\right) = e_ {2}\\left(i\\right) \\, and \\, f_ {21}\\left(e_ {2}\\left(i\\right)\\right) = e_ {1}\\left( i \\right) $。即一个多项式时间算法可以从 $ e_ {1}\\left(i\\right) $ 编码中计算出 $ e_ {2}\\left(i\\right) $ 编码，反之依然。如果抽象问题的两个编码e<sub>1</sub> 和e<sub>2</sub> 为多项式相关，问题是否为多项式时间解决跟我们使用的编码无关。

**引理** 设Q为在实例集合I上的抽象决策问题，设e<sub>1</sub> 和e<sub>2</sub> 为I上多项式相关编码，则 $ e_ {q}\\left(Q\\right) \\in P $ 当且仅当 $ e_ {2}\\left( Q\\right) \\in P $


<a id="org882a1a9"></a>

### 形式语言框架

通过聚焦决策问题，我们可以利用形式语言理论。让我们复习一些理论定义。一个字母表 $ \\sum $ 为符号的有限集合。一个 $ \\sum $ 上的语言L为 $ \\sum $ 中由符号组成的任意字符串集合。例如，如果  $ \\sum = \\{0, 1\\} $，集合 $ L = \\{10, 11, 101, 111, 1011, 1101, 10001, \\ldots \\} $为质数的二进制表示语言。我们记空字符串为 $ \varepsilon $，空语言为 $ \\emptyset $，$ \\sum $上所有字符串语言为 $ \\sum^{ * } $。例如，如果 $ \\sum = \\{0, 1\\} $，则 $ \\sum^{ * } = \\{\\varepsilon, 0, 1, 00, 01, 10, 11, 000, \\ldots \\} $为所有二进制字符串集合。 $ \\sum $上每个语言L是 $ \\sum^{ * } $的子集。

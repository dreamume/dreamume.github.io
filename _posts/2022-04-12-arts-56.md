---
layout:     post
title:      "Weekly 056"
subtitle:   "Algorithm: The Windy's; Review: Notes about design patterns; Tips: PHYSICAL AUDIO SIGNAL PROCESSING(Perceptual Aspects Reverberation); Share:Notes about C++"
thumbnail-img: ""
date:       2022-04-12 18:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org97f12b2)
2.  [Review](#org5d11557)
3.  [Tips](#orga5093c5)
    1.  [回响密度和模式密度的感知](#org84b6458)
    2.  [理想反响的感知矩阵](#org46ed33c)
        1.  [能力衰退曲线](#orgd28dca4)
        2.  [能量衰退起伏](#org934b8f8)
4.  [Share](#orgd58545b)
    1.  [拷贝和移动](#orgd0c012a)
    2.  [引用](#org90e19d6)
    3.  [容器](#org152ffa8)
    4.  [异常](#org26a9132)
    5.  [易用性改进](#org32248dd)


<a id="org97f12b2"></a>

# Algorithm

The Windy's: <http://poj.org/problem?id=3686>

<https://dreamume.medium.com/poj-the-windys-b8bc7f3a08fe>


<a id="org5d11557"></a>

# Review

设计模式之美 - 设计模式与范式：行为型

行为型设计模式主要解决“类或对象之间的交互“问题

模板模式，英文为Template Method Design Pattern，在GoF《设计模式》中这么定义

Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure

这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法“

模板模式的作用：

1.  复用
2.  扩展

回调相对于模板模式会更加灵活：

1.  像Java这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力
2.  回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类
3.  如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可

策略模式，英文全称为Strategy Design Pattern，在GoF《设计模式》中定义

Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it

策略模式解耦策略的定义、创建、使用三部分

职责链模式，英文为Chain Of Responsibility Design Pattern，在GoF《设计模式》中定义

Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it

在职责链模式中，多个处理器（也就是定义中的“接收对象”）依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫做职责链模式

有限状态机，英文为Finite State Machine，状态机有3个组成部分：状态(State)、事件(Event)、动作(Action)

访问者模式，英文为Visitor Design Pattern，在GoF《设计模式》中定义

Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure

一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中

Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定

在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch“。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数

Sinngle Dispatch执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关

备忘录模式，也叫快照（Snapshot）模式，英文为Memento Design Pattern，在GoF《设计模式》中定义

Captures and externalizes an object's internal state so that it can be restored later, all without violating encapsulation

这个模式主要表达了两部分内容，一部分是存储副本以便后期恢复，另一部分是要在不违背封装原则的前提下，进行对象的备份和恢复

命令模式的英文为Command Design Pattern，在GoF《设计模式》中定义

The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations

落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方

解释器模式英文为Interpreter Design Pattern，在GoF《设计模式》中定义

Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar

中介模式英文为Mediator Design Patter，在GoF《设计模式》中定义

Mediator pattern defines a seperate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly

在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式应用场景中，参与者之间的交互比较有条理

中介模式正好相反，只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式


<a id="orga5093c5"></a>

# Tips

回响的感知方面

<https://ccrma.stanford.edu/~jos/pasp/Perceptual_Aspects_Reverberation.html>

人造回响是一个不常见的有趣的信号处理问题，如之前章节讨论的那样，明显的方法基于物理模型或输入输出模型对多数应用程序来说是非常昂贵的。这导致回响的感知重要部分是什么的问题，且如何提供高效地计算结构


<a id="org84b6458"></a>

## 回响密度和模式密度的感知

回响问题可在不牺牲感知质量的情况下大幅简化。例如，它可被显示为对典型的房间，回响密度增加为 $ t^{2} $，t为时间。因此，超过某些时间，回响密度会很大使得它可被模型为一些统一的采样随机处理而不会导致感知失真。特别地，不需要直接计算声音的每个采样的多个回响。对光滑延迟回响，一个合适的随机处理在音频采样率上的采样将感知为对等的声音

相似地，它可显示任意给定频率带宽的声音模式的数量是频率增加的平方，这样在某些频率之上，模式很密集其感知相当于关于某个统计产生的随机频率反应。特别地，不需要直接实现耳朵不能听见的回响

总之，基于感知的限制，一个回响房间的脉冲反应可被分割为两个段。第一段，成为早期反射，包含在脉冲回应里相对稀疏的第一回响。剩下的，被称为后回响，其紧密占据使得其以某种方式上可特征为统计回响。章节3.3讨论模拟回响脉冲反应的早期反射的方法

相似地，反响房间的频率反应可被分为两个段。低频间隔包含一个声音模式的相对稀疏分布，而对高频模式非常紧密这样可以特征为带某个统计属性的随机频率反应。3.4章节描述综合高质量后反响的方法


<a id="org46ed33c"></a>

## 理想反响的感知矩阵

对人造回响一些想要的控制包括

-   $ t_ {60}(f) = $ 在每个频率f想要的反响时间
-   $ G^{2}(f) = $ 在每个频率信号能量增益
-   $ C(f) = $ “清晰度”= 在早期反响到后反响的脉冲反应能量比率
-   $ p(f) = $ 左右耳的音差校正系数

衰退到60dB( $ t_ {60} $ )的时间是经典的对象参数用来测量感知回响时间。$ t_ {60} $测量整个反应。更近地，它更常用于设计多个频率的一个给定 $ t_ {60} $，例如，一个低频，另一个高频，且在中间频率的插值。感知学习显示反响时间应该在至少3个频率宽带上独立调整


<a id="orgd28dca4"></a>

### 能力衰退曲线

测量和定义反响时间 $ t_ {60} $，Schroeder引入被称为能量衰退曲线(EDC)其为时刻t上脉冲反应的平方的积分

$ EDC(t) \\triangleq \\int^{\\infty}_ {t} h^{2}(\\tau) d \\tau $

这样，EDC(t)是时刻t在回响脉冲反应中剩余的信号能量总数。EDC比脉冲反应本身衰退更平滑，且因此它对估计 $ t_ {60} $比普通振幅更好


<a id="org934b8f8"></a>

### 能量衰退起伏

能量衰退起伏(EDR)是一个时频分布其产生EDC到多个频率带宽：

$ EDR(t_ {n}, f_ {k}) \\triangleq \\sum^{M}_ {m=n} \| H(m, k) \|^{2} $

其H(m, k)记为在时间帧m上短时傅里叶变换(STFT)的k桶，且M记为时间帧的总数。STFT的FFT典型地用于窗口，比如一个30到40毫秒的Hann窗口

这样，$ EDR(t_ {n}, f_ {k}) $是在时刻 $ t_ {n} = nT $上反响脉冲反应的剩余信号能量总数，其在一个以 $ f_ {k} = k f_ {s} / N $Hz为中心的频率带宽中，N记为FFT长度

小提琴脉冲反应的EDR显示如下图。对更好的音频感知对应，频率坐标包裹为Bark频率扩展，且能量统计在每个Bark带宽（一个鉴别听力带宽等于一个Bark）。一个小提琴体可视为一个非常小的反响房间，对应放大相关谱结构到反响房间

![img](../img/energy_decay_relief_of_a_violin_body_impulse_response.png)

EDR用来测量从摆弦记录中的偏泛音停滞


<a id="orgd58545b"></a>

# Share

现代C++实战（吴咏炜） 笔记


<a id="orgd0c012a"></a>

## 拷贝和移动

用户如果没有自己提供一个拷贝构造函数（必须形如Obj(Obj &) 或 Obj(const Obj&)，不是模板），编译器会隐式声明一个

    class Copyable {
     public:
      Copyable(const Copyable& other) = default;
      Copyable& operator=(const Copyable& other) = default;
    
      // The implicit move operations are suppressed by the declarations above.
      // You may explicitly declare move operations to support efficient moves.
    };
    
    class MoveOnly {
     public:
      MoveOnly(MoveOnly&& other) = default;
      MoveOnly& operator=(MoveOnly&& other) = default;
    
      // The copy operations are implicitly deleted, but you can
      // spell that out explicitly if you want:
      MoveOnly(const MoveOnly&) = delete;
      MoveOnly& operator=(const MoveOnly&) = delete;
    };
    
    class NotCopyableOrMovable {
     public:
      // Not copyable or movable
      NotCopyableOrMovable(const NotCopyableOrMovable&) = delete;
      NotCopyableOrMovable& operator=(const NotCopyableOrMovable&)
          = delete;
    
      // The move operations are implicitly disabled, but you can
      // spell that out explicitly if you want:
      NotCopyableOrMovable(NotCopyableOrMovable&&) = delete;
      NotCopyableOrMovable& operator=(NotCopyableOrMovable&&)
          = delete;
    };

用户如果没有自己声明考吧构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数

RAII机制把资源的有效期跟持有资源的对象生命周期绑定到一起，利用构造函数分配资源，利用析构函数释放资源，确保资源正确使用，防止特别是异常时资源未释放的问题

delete、free函数参数可以传nullptr


<a id="org90e19d6"></a>

## 引用

    smart_ptr& operator=(smart_ptr rhs) noexcept  {
      rhs.swap(*this);
      return *this;
    }

注意这里参数不是引用，避免if (this != &rhs) 这样的判断，这样的异常安全性不够好

    template <typename T> void bar(T&& s) {
      foo(std::forward<T>(s));
    }

forward用法可使函数参数保持其值类别：左值的依然是左值，右值的为右值。因为在T是模板参数时，T&&的作用主要是保持值类别进行转发，它有个名字叫“转发引用”(forward reference)。因为其可以是左值引用也可以是右值引用，它也被称为“万能引用”(universal reference)


<a id="org152ffa8"></a>

## 容器

推荐在代码中尽量使用string来管理字符串。但对于对外暴露的接口，一般不建议在接口中使用const string&，除非确知调用者已经持有string：如果函数里不对字符串做复杂处理的话，使用const char\*可以避免在调用者只有C字符串时编译器自动构造string，这种额外的构造和析构代价并不低。返过来，如果实现较为复杂、希望使用string的成员函数的话，那就应该考虑下面的策略：

-   如果不修改字符串的内容，使用const string& 或 C++17的string_view作为参数类型。后者是最理想的情况，因为即使在只有C字符串的情况，也不会引发不必要的内存复制
-   如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用string作为参赛类型（自动拷贝）
-   如果需要改变调用者的字符串内容，使用string& 作为参数类型（通常不推荐）

对于容器，如果元素没有提供一个保证不抛异常的移动构造函数，通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为noexcept，或只在容器中放置对象的智能指针

某些标准算法在list上会导致问题，list提供了成员函数作为替代，包括下面几个：

-   merge
-   remove
-   remove_if
-   reverse
-   sort
-   unique

forward_list没有insert只有insert_after


<a id="org26a9132"></a>

## 异常

异常安全指当异常发生时，既不会发送资源泄漏，系统也不会处于一个不一致的状态

    class matrix {
      // …
      friend matrix
      operator*(const matrix&,
                const matrix&);
    private:
      float* data_;
      size_t nrows_;
      size_t ncols_;
    };
    
    matrix::matrix(size_t nrows,
                   size_t ncols) {
      data_  = new float[nrows * ncols];
      nrows_ = nrows;
      ncols_ = ncols;
    }
    
    matrix::~matrix() {
      delete[] data_;
    }
    
    matrix operator*(const matrix& lhs,
                     const matrix& rhs)
    {
      if (lhs.ncols != rhs.nrows) {
        throw std::runtime_error(
          "matrix sizes mismatch");
      }
      matrix result(lhs.nrows, rhs.ncols);
      // 进行矩阵乘法运算
      return result;
    }

这个例子中可能会出错误/异常的地方：

-   首先是内存分配。如果new出错，按照C++的规则，一般会得到异常bad_alloc，对象的构造也就失败了。这种情况下，在catch捕捉到这个异常之前，所有栈上对象会全部被析构，资源全部被自动清理
-   如果是矩阵的长度不合适不能做乘法呢？我们同样会得到一个异常，这样，在使用乘法的地方，对象c根本不会被构造出来
-   如果在乘法函数里内存分配失败呢？一样，result对象根本没有构造出来，也就没有c对象了。还是一切正常
-   如果a,b是本地变量，然后乘法失败了呢？析构函数会自动释放其空间，我们同样不会有任何资源泄露

对异常的批评主要有两点：

-   异常违反了“你不用就不需要付出代价“的C++原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀
-   异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常

对于第一条，开发者没什么可做的。事实上，这也算是C++实现的一个折中了。目前的主流异常实现中，都倾向于牺牲可执行文件大小、提供主流程(happy path)的性能。只要程序不抛异常，C++代码的性能比起完全不做错误检查的代码，都只有几个百分点的性能损失。除了非常有限的一些场景，可执行文件大小通常不会是个问题

对第二条，C++不会对异常规约进行编译时的检查。从C++17开始，C++甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能会抛出某某异常。你唯一能声明的，就是某函数不会抛出异常 - noexcept、noexcept(true)或throw()。这也是C++的运行时唯一会调用std::terminate来终止应用程序

不声明异常是有理由的。特别是在范型编程的代码里，几乎不可能预知会发生些什么异常。我个人对避免异常带来的问题有几点建议：

1.  写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄露
2.  如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况，了解需要准备处理哪些异常
3.  对于肯定不会抛出异常的代码，将其标为noexcept。注意类的特殊成员（构造函数、析构函数、赋值函数等）会自动称为noexcept，如果它们调用的代码都是noexcept的话。所以，像swap这样的成员函数应当尽可能标成noexcept

异常安全有四级：

-   不抛异常(noexcept)保证
-   强异常安全保证
-   基本安全异常保证
-   没有任何保证


<a id="org32248dd"></a>

## 易用性改进

    template <typename T, std::size_t N>
    void foo(const T (&a)[N])
    {
      typedef const T* ptr_t;
      for (ptr_t it = a, end = a + N;
           it != end; ++it) {
        // 循环体
      }
    }
    
    template <typename T>
    void foo(const T& c)
    {
      for (typename T::const_iterator
             it = c.begin(),
             end = c.end();
           it != end; ++it) {
        // 循环体
      }
    }

以上代码如果用自动类型推断，可写成

    template <typename T>
    void foo(const T& c)
    {
      using std::begin;
      using std::end;
      // 使用依赖参数查找（ADL）；见 <span class="orange">[2]
      for (auto it = begin(c),
           ite = end(c);
           it != ite; ++it) {
        // 循环体
      }
    }
    </span class="orange">

decltype的用途是获得一个表达式的类型，结构可以跟类型一样使用。它有两个基本用法：

-   decltype(变量名)  可以获得变量的精确类型
-   decltype(表达式)  可以获得表达式的引用类型；除非表达式的结果是个纯右值(prvalue)，此时结果仍然是值类型

通常情况下，能写auto来声明变量肯定是件比较轻松的事情。但这里有个限制，你需要在写下auto时就决定你写下的是个引用类型还是值类型。根据类型推导规则，auto是值类型，auto&是左值引用类型，auto&&是转发类型（可以是左值引用，也可以是右值引用）。使用auto不能通用地根据表达式类型来决定返回值的类型。不过，decltype(auto)即可以是值类型，也可以是引用类型。因此，我们可以这么写：

    decltype(expr) a = expr;

C++14引入了decltype(auto)语法。我们可以改写为

    decltype(auto) a = expr;

这种代码主要用在通用的转发函数模板中：你可能根本不知道你调用的函数是不是会返回一个引用

从C++14开始，函数的返回值也可以用auto或decltype(auto)来声明。用auto可以得到值类型，用auto&或auto&&可以得到引用类型。而用decltype(auto)可以根据返回表达式通用地决定返回的是值类型还是引用类型

    auto foo(参数) -> 返回值类型声明
    {
      // 函数体
    }

通常，在返回类型比较复杂，特别是返回类型跟参数类型有某种推导关系时会使用这种语法

从C++17开始，我们可以直接写

    pair pr{1, 42};
    
    array a{1, 2, 3};
    // 得到 array<int, 3>

这种自动推导机制，可以是编译器根据构造函数来自动生成：

    template <typename T>
    struct MyObj {
      MyObj(T value);
      // …
    };
    
    MyObj obj1{string("hello")};
    // 得到 MyObj<string>
    MyObj obj2{"hello"};
    // 得到 MyObj<const char*>

也可以手工提供一个推导向导，达到自己需要的效果：

    template <typename T>
    struct MyObj {
      MyObj(T value);
      // …
    };
    
    MyObj(const char*) -> MyObj<string>;
    
    MyObj obj{"hello"};
    // 得到 MyObj<string>

    multimap<string, int>::iterator
      lower, upper;
    std::tie(lower, upper) =
      mmp.equal_range("four");

这个例子里，返回值是个pair，我们希望用两个变量来接收数值，就不得不声明了两个变量，然后使用tie来接收结果。在C++11、C++14里，这里没法使用auto。好在C++17引入了一个新语法，解决了这个问题。目前，我们可以把代码简化为

    auto [lower, upper] =
      mmp.equal_range("four");

当一个构造函数没有标成explicit时，你可以使用大括号不写类名来进行构造，如果调用上下文要求那类对象的话。如：

    Obj getObj() {
      return {1.0};
    }

使用大括号时编译器会拒绝“窄”转换，不接受以{1.0}或Obj{1.0}的形式调用构造函数Obj(int)

这个语法的限制是，如果一个类既有使用初始化列表的构造函数，又有不使用初始化列表的构造函数，那编译器会千方百计地试图调用使用初始化列表的构造函数，导致各种意外。所以推荐的话

-   如果一个类没有使用初始化列表的构造函数时，初始化该类对象可全部使用统一初始化语法
-   如果一个类有使用初始化列表的构造函数时，则只应用在初始化列表构造的情况

一些字面量的用法

    int main() {
      cout << "i * i = " << 1i * 1i
           << endl;
      cout << "Waiting for 500ms"
           << endl;
      this_thread::sleep_for(500ms);
      cout << "Hello world"s.substr(0, 5)
           << endl;
    }

要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线_打头。比如，加入我们有下面的长度类：

    struct length {
      double value;
      enum unit {
        metre,
        kilometre,
        millimetre,
        centimetre,
        inch,
        foot,
        yard,
        mile,
      };
      static constexpr double factors[] =
        {1.0,    1000.0,  1e-3,
         1e-2,   0.0254,  0.3048,
         0.9144, 1609.344};
      explicit length(double v,
                      unit u = metre)
      {
        value = v * factors[u];
      }
    };
    
    length operator+(length lhs,
                     length rhs)
    {
      return length(lhs.value +
                    rhs.value);
    }
    
    // 可能有其他运算符

如果允许如下这么写

    1.0_m + 10.0_cm

则需要提供下面的运算符即可：

    length operator"" _m(long double v) {
      return length(v, length::metre);
    }
    
    length operator"" _cm(long double v) {
      return length(v, length::centimetre);
    }

从C++14开始，对于二进制也有了直接的字面量：

    unsigned mask = 0b111000000;

这在需要比特级操作等场合还是非常有用的

不过，遗憾的是，I/O streams里只有dec、hex、oct三个操纵器(manipulator)，没有bin，一个间接的办法是使用bitset，但需要手动指定二进制位数

    cout << bitset<9>(mask) << endl;

C++14开始，允许在数字型字面量中任意添加'来使其更可读，例如

    unsigned mask = 0b111'000'000;
    long r_earth_equatorial = 6'378'137;
    double pi = 3.14159'26535'89793;
    const unsigned magic = 0x44'42'47'4E;

C++11提供了静态断言机制，在编译期检查，例如

    static_assert((alignment & (alignment - 1)) == 0,
      "Alignment must be power of two");

在类定义的时候，C++有一些规则决定是否生成默认的特殊成员函数，这些特殊成员函数可能包括：

-   默认构造函数
-   析构函数
-   拷贝构造函数
-   拷贝赋值函数
-   移动构造函数
-   移动赋值函数

如果成员和父类没有特殊原因导致对象不可拷贝或移动，在用户不声明这些成员函数的情况下，编译器会自动产生这些成员函数，即隐式声明、默认提供、正常状态。有特殊成员、用户声明的话，情况就非常复杂了：

-   没有初始化的非静态const数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除
-   非静态的const数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除
-   用户如果没有自己提供一个拷贝构造函数（必须形如Obj(Obj&)或Obj(const Obj&)；不是模板），编译器会隐式声明一个
-   用户如果没有自己提供一个拷贝赋值函数（必须形如Obj& operator&(Obj&)或Obj& operator=(const Obj&);不是模板），编译器会隐式声明一个
-   用户如果自己声明了一个移动构造函数或移动赋值函数、则默认提供的拷贝构造函数和拷贝赋值函数被删除
-   用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数、编译器会隐式声明一个移动构造函数
-   用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数，编译器会隐式声明一个移动赋值函数

注即使用户要求默认提供某个函数，编译器也可能根据其他规则将特殊成员函数标为删除

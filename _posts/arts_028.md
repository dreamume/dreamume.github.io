---
layout:     post
title:      "Weekly 028"
subtitle:   ""
thumbnail-img: ""
date:       2020-09-22 10:00
author:     "dreamume"
tags: 		[it]
category:   it
---

# Table of Contents

1.  [Algorithm](#orgcab899a)
2.  [Review](#orgc551986)
    1.  [简介](#orgd34cf9e)
    2.  [复制状态机](#org1c6dd66)
        1.  [协调复制节点](#orgcef7dae)
        2.  [租赁：有效地高效计算](#org37a2312)
        3.  [分层租赁](#orgf9e5624)
    3.  [共识](#orgd6ce256)
    4.  [指导说明](#orga64cb47)
        1.  [如何指定状态系统](#org0885004)
        2.  [说明共识](#org31d6ec9)
3.  [Tips](#org49f4663)
4.  [Share](#org9bfcb29)


<a id="orgcab899a"></a>

# Algorithm

Leetcode 327: <https://leetcode.com/problems/count-of-range-sum/>

<https://medium.com/@dreamume/leetcode-327-count-of-range-sum-9f7d0a611469>


<a id="orgc551986"></a>

# Review

How To Build a Highly Available System Using Consensus

<http://research.microsoft.com/en-us/um/people/blampson/58-consensus/acrobat.pdf>


<a id="orgd34cf9e"></a>

## 简介

系统有效指它能按照需求提供服务。从非高效组件中建立高效系统唯一的方法使用冗余。这样系统在部分故障的时候依然能够工作。最简单的冗余即使复制：使每个部分有一些拷贝或复制节点。

本文解释了除了复制节点以外如何构建高效系统，并给出详细指导说明和关键算法的非正式化正确性证明。几乎所有想法源于Leslie Lamport的复制状态机，Paxos共识算法及说明分析并行系统的方法。我写本文因为在我读了Lamport论文之后，它依然使我用长时间来理解这些方法并如何有效地使用它们。奇怪地是很少有人知道这些。

下一节我们将解释如何构建一个有效并高效地重复状态机，给出一个共识容错算法。第3节给出一些共识问题的背景和它的应用程序。第4节用几种形式说明共识。第5节我们介绍Paxos共识算法的基本概念并把算法从想法变为详细说明。最后，我们解释一些重要的优化和归纳我们的结论。


<a id="org1c6dd66"></a>

## 复制状态机

冗余是不够的，需要有协调。最简单的办法是使每个非故障复制节点做相同的事。然后任意非故障复制节点可提供输出；如果复制节点没有故障停止，需要f个复制节点的输出容错f - 1个故障。更复制类型的冗余（比如错误修正代码）更便宜，但它们依赖服务提供的特殊属性。

在本节我们解释如何以泛化并高容错的方式协调复制节点。然后我们探索一个优化称为“租赁”，使几乎在所有情况下协调更加有效。


<a id="orgcef7dae"></a>

### 协调复制节点

我们如何排列每个复制节点做同样的事情？采用一个由Lamport首次提出的方案，我们构建每个复制节点做为确定性状态机；这使交易关系为一个函数从（状态，输入）到（新状态，输出）。通常称一个这样的复制节点为进程。几个进程已相同的状态开始，看懂相同序列的输入将做相同的事情，然后已相同的状态结束并产生相同的输出。这样所有我们需要保持高有效性的是确保所有非故障进程看到相同的输入。该技术术语称为共识（有时称为同意或可靠广播）。我们说一些进程达成共识仅当它们都同意某个值；我们将在之后给出形式化定义。

这样如果一些进程实现相同的确定性状态机并在一些值上达成共识并顺序化输入，它们将做相同的事情。这样它可能重复任意的计算并使它有效。当然我们可通过定义一些输入集合整体有序来使输入数据部分有序，例如通过编号它们为1，2，3&#x2026;。

在许多应用程序中，输入为客户端发送给复制节点服务的请求。例如，一个复制存储服务可能有一个Read(a)和Write(a, d)输入，且一个机场飞行控制系统可能有ReadInstrument(i)和RaiseFlags(d)输入。不同的客户端通常独立地产生它们的请求，这样它们需要同意请求且服务的顺序。最简单的方法是用连续的整数编号，开始为1。这在主复制节点中完成，因为对一个进程来说分配连续编号比较简单。这样存储服务将同意输入1=Write(x, 3)和输入2=Read(x)。

当总序不为连续的整数时，有许多其他达成共识的方案来排序请求。这些方案标签每个输入为一个总序集合的相同值（例如，(客户端UID, tiimestamp)对），然后发明一种方法来确定你看见所有的输入甚至存在比给定值更小的标签。这是比较复杂的，实际系统通常使用一个主机来序列号输入。


<a id="org37a2312"></a>

### 租赁：有效地高效计算

容错共识是昂贵的。单进程（加锁）排他访问是廉价的，但它不容错，如果一个进程在加锁时故障，其他进程不能访问该资源。添加一个加锁超时使锁容错或“租赁”。这样进程持有一个状态组件或资源租赁直到超；我们说进程持有租赁时为该资源的主。其他进程不能接触到资源直到租赁结束。要让这样工作，当然，进程必须同步时钟。更精确地说，如果两个进程时钟之间最大的差异为ε且进程P的租赁到期时间为t，则P知道在P的时钟t - ε内其他进程不会接触到资源。

当它持有租赁时，可自由读写资源。写必须有边界时间，这样它们可保障在租赁到期后是故障还是继续处理任何操作；对SCSI磁盘中的资源来说这将是个严重问题，因它为弱顺序保障且写上限时间较长。

交易处理系统里的锁通常是租赁；如果过期则交易被取消，即写入将退回，交易相当于被跳过。进程使用租赁超过交易范围时必须小心地提供必要的原子性，例如，为确保资源在每次原子写之后仍在好的状态，或基于日志使用标准的重做或回退操作。如果资源重复租赁，回退是必要的。

进程可通过在到期前重新租赁来保持对资源的控制。它也可以按需释放租赁。如果你无法跟租赁中的进程通讯，也许因为故障，你不得不等待租赁到期来接触该资源。这样这里有一个重新租赁成本和等待租赁到期时间的妥协。一个短的租赁表示恢复时间短，但重新租赁成本高。一个长的租赁表示恢复时间长但重新租赁成本低。

租赁通常用来让进程有权限来缓存部分状态，例如它知道不会改变的缓存内容或文件。因租赁为一种锁，它可有一种模式决定持有者能做什么操作。如果租赁为排他的，则进程可自由地改变租赁状态。这就像拥有者访问缓存或多端口磁盘的拥有者关系。


<a id="orgf9e5624"></a>

### 分层租赁

容错系统的租赁必须保障和重租赁来运行共识。如果使用共识依然成本高，解决方案是分层租赁。运行共识一旦选举了领导者C并给C大部分状态的租赁。现在C分配一些子租赁x和y给一些主节点。每个主节点控制它们自己的资源。主节点通过C重新租赁它们的子租赁。因它不需要任何协调因此很轻。C通过共识来重新租赁。这个成本高，但只有一个领导者。同样，领导者可简单并更小几率故障，这样长租赁可接受。

分层租赁通常使用在重复的文件系统和集群中。

通过共识、租赁和分层，可以构建高可用系统同样也高效。


<a id="orgd6ce256"></a>

## 共识

一些进程达成共识当它们都同意某个允许的值称为输出（如果它们能同意任意值则本解决方案无意义：总是同意0）。这样共识的接口有两个行为：允许一个值，读输出。一个共识算法终止当所有非故障进程都了解了输出。

有很多共识的应用程序产生可重复状态机。3个流行的例子为：

-   分布式交易，所有进程需要同意交易是否提交或取消。每个交易需要输出的独立共识
-   成员，一组进程合作提供高可用服务需要同意哪些进程作为当前工作的成员。每次进程故障或重新开始工作需要有一个新的共识
-   在不知道谁是成员的情况下选举一组进程的领导者

如果无故障则共识很容易。这有一个简单实现。有一个固定的领导者进程。它获取所有的允许行为，选择输出，并告诉每个人。如果它故障，则不能工作。标准的两阶段提交即是如此工作：如果所有参与者已准备则允许提交值，如果至少一个故障则取消。如果领导者故障则输出不明。

另一个简单实现为一组进程，每个选择一个值。如果多数选择相同的值，则作为输出（可能的多数为子集，且任意两个多数有一个非空交集）。如果进程选择过程没有达成多数，则没有输出。如果多数中的一些成员故障则输出不明。

当故障存在时共识是困难的。在异步系统中（非故障进程可用任意时间来交易），如果连接是完美的，即是一个进程故障，则没有共识算法能保证能终止。在异步系统，即是进程有任意或恶意故障（拜占庭），共识也可能达成，但需要昂贵的消息发送和用时。


<a id="orga64cb47"></a>

## 指导说明

我们学习状态系统，有一个状态空间（不需要有限），和一系列行为（不需要确定性）时系统从一个状态转换到另一个。数据抽象，并行程序，分布式系统，容错系统都基于这种模型。通常我们描述状态空间作为更小空间的卡特兰乘积，称为变量。


<a id="org0885004"></a>

### 如何指定状态系统

为说明这样的系统，我们指定一些行为或变量为外部的，另一些为内部的。我们关心地是外部行为序列（或外部变量值的序列），因为我们假设你不能从系统外观察到内部行为或变量。我们称这样的序列为系统跟踪。一个指导说明为一系列跟踪，或跟踪预测。这样的集合称为属性。

我们可定义两种特殊类型的属性。一个安全属性断言无有害的事情发生；其为序列程序部分正确性的一般化。一个活跃属性断言一些好的事情最终会发生；其为终止的一般化。你可总是告诉一个跟踪通过查找一些有限的前缀来了解安全属性，但你不能这么处理活跃属性。任何属性（任意序列行为集合）为安全属性和活跃属性的交集。

本文中我们只处理安全属性。因为我们知道没有异步共识的终止算法。幸运地是，活跃属性更难处理。

我们方便地通过状态机定义一个安全属性，它的行为可分为外部的和内部的。所有序列的机器外部行为定义为一个安全属性。不要混淆这些状态机和我们实现共识用的重复状态机。

我们定义一个系统Y来实现另一个系统X:

-   Y的每个跟踪为X的跟踪；即Y的安全属性意味着X的安全属性
-   Y的活跃属性意味着X的活跃属性

第一个要求确保你不能通过观察Y来说这不是X；Y不会做任何有害的事。第二个确保Y会做所有X支持做的好事情。

使用这种方法来说明一个状态系统我们必须首先要定义状态空间和描述其行为。我们选择状态空间来使说明更清晰，而不是状态的实现。对每个行为我们说它对状态做了什么和它是外部的还是内部的。我们用参数和结果模型化一个行为，比如Read(x)，比如一个Read(x)返回3；该行为发生时客户端读取x并得到结果3.

以下为一些有用的提示来写这些说明：

-   标注很重要，因为它帮助你了解在发生什么。使用一个合适的词汇
-   少即是多。行为越少越好
-   更多地非确定性更好，因为它允许更多的实现


<a id="org31d6ec9"></a>

### 说明共识


<a id="org49f4663"></a>

# Tips

-   快速读，追求一定的速度，如看不懂则返回来再重复读之前需要的一些章节，如一些内容依然不是很懂，可同时阅读讲解相同内容的不同书籍做参考
-   为快速理解一些概念，看题解，以理解概念为重


<a id="org9bfcb29"></a>

# Share

Polynomials and the FFT

算法导论第30章

本章内容并不难，需要一点线性代数和复数知识。几乎以最简练的语言讲解了FFT算法，非常经典通透。

主要是讨论了多项式乘法O(n<sup>2</sup>)的普通算法通过FFT优化为O(nlogn)。

在简单介绍了多项式后，用范德孟德矩阵和拉格朗日插值公式求解。

首先求出两个多项式分别n个x值的y值，然后把两个多项式值分别相乘，最后用拉格朗日插值公式求出最终的各项系数。

这里利用了复数性质，以1的n次方根作为x值带入来求其多项式的值。

剩下的就是利用1的n次方根的特点进行局部优化，衍生出FFT的分治算法和迭代算法，及简单说明了一下FFT的并行化。

相关C++代码实现如下：

<https://github.com/dreamume/introduction2algorithm/blob/master/chapter30/fft.cc>


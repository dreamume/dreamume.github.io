---
layout:     post
title:      "Weekly 091"
subtitle:   "Algorithm: Two city Scheduling; Review: Separation of Concerns in Software Design; Tips: ; Share: "
thumbnail-img: ""
date:       2024-04-17 20:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org9b1537e)
2.  [Review](#org035db36)
    1.  [编程函数的 SoC](#org2eac7b9)
    2.  [模块的 SoC](#orgf167c35)
    3.  [内聚和耦合](#orgcde6525)
    4.  [松耦合和高内聚的好处](#org7efb7cd)
3.  [Tips](#orgf2996b6)
4.  [Share](#org8a1d4a3)


<a id="org9b1537e"></a>

# Algorithm

Leetcode 3102: [Two city Scheduling](https://leetcode.com/problems/two-city-scheduling/)

<https://dreamume.medium.com/leetcode-1029-two-city-scheduling-25e01e1ad4fe>


<a id="org035db36"></a>

# Review

[Separation of Concerns in Software Design](https://nalexn.github.io/separation-of-concerns/)

担忧隔离（SoC）在软件开发中是最基础的原则之一

5 个 SOLID 原则的两个（单一原则和接口隔离）直接源于这个概念

原则非常简单：不要把你的程序写成固定一块，而是，分离代码为块，每个系统小块能完成一个简单不同的任务

在本文中，我特意应用这个原则在抽象的所有层级：从每个函数内部的编程代码和整个应用程序架构的模块设计，所有都为了获得高质量软件的特性


<a id="org2eac7b9"></a>

## 编程函数的 SoC

如果我们看最底层（实际的编码），SoC 指导我们避免写长并复杂的函数。当函数大小变得巨大，则表明函数可能包含了太多东西

这时 SoC 让我们重构它，转换成更简洁和可描述的版本。在这个过程中，原始算法的部分以私有访问级别导出并封装成几个更小的函数。我们获得清晰的代码，并算法块最终变得可重用于其他地方，甚至如果我们开始并没有想到这些


<a id="orgf167c35"></a>

## 模块的 SoC

在更高的层级，这个原则告诉我们组织函数到自包含模块，每个负责单个任务集，其有清晰的逻辑关系

该过程跟我们对函数做的非常相似：分离不紧密关联的功能并组织特性服务相同的不同的目的


<a id="orgcde6525"></a>

## 内聚和耦合

应用程序的担忧隔离包含两个过程：减少耦合和增加内聚

内聚是职责集合、细节层级和本地性的相似性度量。例如，drawCircle 和 drawTriangle 函数足够内聚属于负责绘制的相同模块，且它自然且把这两个函数在代码上互相接近（高相似性 ～ 高内聚）

上面提及的 drawCircle 和 drawTriangle 可被其他函数 DrawCybertruck 使用。我们可尝试把这个函数也放入绘制模块，但 drawCybertruck 可能依赖物理引擎和外部状态。这样这将使得整个绘制模块和其他组件减少了重可用性和更加耦合

你可告诉原始的绘制函数和 drawCybertruck 属于不同层级的抽象和逻辑复杂度，这样它们需要位于不同的模块

且如果在一些点上我们决定在其他工程中使用绘制模块 - 则不需要依赖物理引擎，这样我们将更容易利用它

一个快速的方式记住什么属性应该增加或减少：

-   解偶是好的 - 这样我们需要目标朝向一个松散的耦合
-   内聚代码是好的 - 我们需要目标朝向一个高的内聚

高内聚代码的一个好的例子是使用闭包回调而不是代理方法。考虑发送网络请求的代码：

    // configuring and sending the request
    session.send(request: URLRequest) { response in
        // handling the response
    }

想象如果 URLSession 有一个基于代理的 API 发送请求：所有的响应需要转发到一个函数 handle(response: URLResponse, for request: URLRequest)

这将使得网络更容易出错和单调乏味，因为处理所有响应的逻辑需要绑定到一个函数

用基于回调的 API，行为和行为的结果在一个地方处理，使得更容易跟踪处理流程

如果我们需要在函数或模块之间跟随算法逻辑跳跃，这意味着代码有低内聚


<a id="org7efb7cd"></a>

## 松耦合和高内聚的好处

遵循隔离担忧的原则帮助改进代码的很多特性

1.  代码更加清晰。更容易理解程序当每个模块有一个简洁和清晰的逻辑范围方法集合的 API
2.  代码更重用。重用主要的好处是减少维护成本。无论你需要扩展功能或修复 Bug，由于代码只有一份更容易修复
3.  更容易测试。适合范围功能的独立模块和更应用程序其他部分的隔离使得测试更容易。你不需要设立整个环境来看你的模块怎么工作 - 可以有效的用模拟假数据源替换实际模块。这个方法你可测试模块作为黑盒验证输出，或作为白盒也能看到哪个模块在连接的模块上被调用
4.  快速工程演进。无论一个新特性或一个现有功能的升级，模块隔离帮助确定应用程序被影响的范围，加速开发
5.  多个开发者之间更容易组织同时开发。他们只需要在他们工作的模块上一致并确保它们不相互干扰。只有更新一个模块的 API 需要直接通知其他开发者，大多数修改可被添加而不需要其他人的立即注意。当耦合用好的测试覆盖，并行开发变得高效


<a id="orgf2996b6"></a>

# Tips


<a id="org8a1d4a3"></a>

# Share



# Table of Contents

1.  [Algorithm](#orgd0899c2)
2.  [Review](#org2a11cc7)
    1.  [问题](#orgda8cdcd)
        1.  [Paxos岛](#orgccec4a3)
        2.  [需求](#orgc8122c0)
        3.  [假设](#org9d00a6f)
    2.  [单法令会议](#org1763add)
        1.  [数学结果](#org71f8222)
        2.  [原始协议](#org3f97282)
        3.  [基本协议](#orgb3e795b)
        4.  [完整的会议协议](#org53ef2e6)
3.  [Tips](#orga11dff1)
4.  [Share](#orgd44a7fb)
    1.  [简介](#org7530943)
    2.  [WAL如何工作](#org743c852)
        1.  [checkpointing](#orgc4c20e5)
        2.  [并行](#orgeb53479)
        3.  [性能考量](#org6405da7)
    3.  [激活和配置WAL模式](#org9de946e)
        1.  [自动checkpoing](#orgf83b9ef)
        2.  [应用程序初始化checkpoint](#org3647acd)
        3.  [WAL模式的持久性](#org9626b98)
    4.  [WAL文件](#org85cbaab)
    5.  [只读数据库](#orgb2878d5)
    6.  [避免过大的WAL文件](#org49ae438)
    7.  [wal-index的共享内存实现](#org366fbe2)
    8.  [使用没有共享内存的WAL模式](#orgae2c0cd)
    9.  [WAL模式下一些查询返回SQLITE_BUSY](#orgc271db8)
    10. [向后兼容性](#org561577b)


<a id="orgd0899c2"></a>

# Algorithm

leetcode 673: <https://leetcode.com/problems/number-of-longest-increasing-subsequence/>

<https://medium.com/@dreamume/leetcode-673-number-of-longest-increasing-subsequence-5d05faa85070>


<a id="org2a11cc7"></a>

# Review

The Part-Time Parliament

<https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf>

最近在Paxos岛上的考古发现那里议会即使有经常旅游的兼职立法议员也能正常运行。议员维护议会记录的一致性拷贝，即使经常不在议会或送信者忘记了。Paxon议会协议提供了新的状态机机制来实现分布式设计。


<a id="orgda8cdcd"></a>

## 问题


<a id="orgccec4a3"></a>

### Paxos岛

一千年前左右，爱琴海的Paxos岛是一个成长中的商业中心。财富导致政治复杂性，Paxos人以议会的形式政府取代了早期的宗教式统治。在城市职责出现前就已有交易，但在Paxos没有人愿意为议会出力。Paxos议会不得不在立法议员频繁出入国会议院的情况下颁布法令。

管理这样的兼职议会面临的问题跟现在的容错式分布式系统相似，立法议员对应进程，离开议院对应进程出错。科学家们因此对Paxos人的解决方案很感兴趣。这里我呈现Paxos议会协议的一个简短历史，接着会有一个更剪短的分布式系统的相关讨论。

Paxos文明已被外来侵略者摧毁，考古学家最近开始揭露其未知的历史。我们对Paxos议会的了解因此也是琐碎的。虽然基本的协议我们知道，但我们会忽略很多细节。当一些细节比较有趣时，我将Paxos人可能做了什么的讨论自由留给大家。


<a id="orgc8122c0"></a>

### 需求

议会的主要任务是制订岛屿的法律，通过一系列的法令来形成法律。现代议会会雇佣秘书来记录，但在Paxos没有人愿意逗留在议院长达一个季度。因此，每个Paxos立法议员维护一个账本，记录通过的法令。例如，立法员Λ ̆ινχ∂z账本上有这样一条记录：

    155: 橄榄税是每吨3德拉克马

账本使用一种无法篡改的墨水。

议会协议的第一个需求是账本的一致性，不同账本不能含有矛盾的信息。如果立法员Φισ∂ερ有如下记录：

    132: 灯具必须使用橄榄油

则其他立法员没有不同的132条法令。如果立法员还不知道132条法令已通过，他可能没有该条法令记录。

光账本的一致性还不够，因为账本可能无记录。因此需要保证法令最终被通过且记录进账本。在现代议会中，法令需要通过议员的同意。这在Paxos不是问题，因为他们之间充分信任并接受。Paxos的立法议员愿意通过被提议的任何法令。但他们经常旅游的习性引出了一个问题。一致性将丢失当一组立法员发布法令

    37: 禁止在寺庙墙上涂画

然后他们离开去参加宴会。同时另一组议员进入议院，并不知道刚才的法令，他们又通过了一条新的冲突法令：

    37: 允许自由地艺术表达

这样法令进度无法保障，除非足够的立法议员花足够的时间呆在议院。因为Paxos的立法议员不愿意他们的外出活动被限制，因此不能确保任何法令被通过。然而，立法议员愿意保证，当在议院时，他们愿意帮助处理所有的议会事务。这种保证促使Paxos发明了一种议会协议满足如下进度条件：

           如果多数立法员在议院并且在一段长时间内无人进入或离开，则议院里的立法员提议的任意法令都被通过，
           每个通过的法令都会出现在议院里议员的账本里。


<a id="org9d00a6f"></a>

### 假设

议会协议的条件只有在提供给立法议员必要资源后才能达成。每个立法议员拥有一个记录法令的账本，一支笔和不可篡改的墨水。当议员离开议院时可能忘记他们做的事情，所以他们在账本写下备注提醒他们一些重要的议会任务。法令列表的记录不能改变，但备注可以划掉。获取进度需要立法议员能够测量时间，他们给出一个简单的漏斗计时器。

立法议员始终带着账本，总是读着法令列表和未划掉的备注。账本是用最好的皮质制作，并只用于最重要的备注。议员在另一些小纸片上记录其他的备注，当他离开议院时可能丢失。

议院传声很差，不能公开宣讲。议员只能通过信使交流，已提供足够的资金供议员雇佣足够的信使。信使可以信赖不会发送意图不明的消息，但他可能忘记已经发送了消息，并会重复发送。和议员一样，信使也是兼职。信使可能离开议院去做一些生意，可能花费6个月的旅行，然后才传递消息。他甚至可能永远离开，导致消息不被转发。

虽然议员和信使可能在任意时刻进入或离开，当在议院的时候他们会尽力为议会工作。当他们在议院时，信使尽力转发消息，议员反馈收到的信息。

Paxos的官方记录声称议员和信使非常诚实并严格服从议会协议。大多数研究员不在意这点，约定俗成地认为Paxos在道德上比东方邻居做得好。不诚实，虽然罕见，不可怀疑地当然存在。然而，在官方文档里没有提及，我们对议会如何处理不诚信的议员和信使所知甚少。


<a id="org1763add"></a>

## 单法令会议

Paxos议会从早期一种祭司仪式的会议演化而来，祭司每19年聚集一次来选择一个标志性的法令。多个世纪以来，这个会议通过约定俗成的过程来选择法令，该过程需要所有祭司在场。但在商业繁荣发展后，在会议过程中祭司开始往来于议院。最终，旧的协议失效，导致无法令被选中。为防止这种技术灾难的复现，Paxos宗教头领请求数学家来设计新的协议。协议的需求和假设和前述议会相同，除了账本只能最多有一个法令。

数学家通过一系列步骤实现该协议。首先，他们证明结果显示协议满足一些限制就能保障一致性和确保协议在推进。一个原始的协议由这些限制引出。一个限制性的原始协议版本提供基本协议的一致性，但不保证进展。然后完整的协议，满足一致性和进展要求，从这个限制的基本协议中发展出来。


<a id="org71f8222"></a>

### 数学结果

法令选择通过一系列投票产生，每个投票过程，祭司只能选择投或不投。参加本次投票过程的祭司人数叫法定人数。一个投票过程成功当且仅当法定人数里的所有祭司都已作出投票决定。形式上，一个投票活动B包含如下四个部分：

-   B<sub>dec</sub> 本次投票的法令
-   B<sub>qrm</sub> 非空祭司集合（投票的法定人数）
-   B<sub>vot</sub> 已做出投票决定的祭司集合
-   B<sub>bal</sub> 代表本次投票活动的序号

投票活动B成功完成当且仅当B<sub>qrm</sub> ⊆  B<sub>vot</sub>，即每个法定成员都已做出投票决定。

投票活动序号从无边界顺序数字集合中选择。如果B'<sub>bal</sub> > B<sub>bal</sub>，则投票活动B'在B之后。但这并不意味着实际时间顺序，之后的活动也可能发生得更早。

Paxos数学家定义了一系列投票活动ℬ的这些条件，并展示在这些条件下一致性和进度可以得到保障。前两个条件比较简单，形式化描述如下：

-   B1(ℬ) 每个投票活动在集合ℬ中有一个唯一的活动序号
-   B2(ℬ) 任意两个投票活动的法定人数里至少有一个共同祭司

第3个条件比较复杂，一个Paxos手稿上有比较含糊的描述：

B3(ℬ): ℬ集合中的每个投票活动，任何法定人数里的祭司在之前活动中如已投票，则本次活动所代表的法令和该祭司在最新的已投票的早期活动的法令相同

我们通过手稿上的图1来帮助解释，图1显示5个投票活动，有5个祭司：A, B, Γ, ∆, 和 E，并显示了每次活动的法定祭司，方框括起来的表示该祭司已完成投票决定。例如，序号14的活动投票的法令是α，法定人数为3人，2人已做出投票决定。

![img](./resource/paxon_manuscript_figure1.png)

5次活动的条件如下：

-   活动2是最早的活动，因此满足条件要求
-   活动5中的法定成员没有在之前的活动中投票，因此活动5满足条件要求
-   活动14中唯一一个在早期活动中有投票的是祭司∆，他在活动2中投了票，因此按条件要求活动14的法令和活动2的法令必须相同
-   活动27是一次成功的活动，祭司A没有在之前的活动中投票，祭司Γ在活动5中投了票，祭司∆在活动2中投了票，因此按条件要求活动27的法令必须与活动5的法令相同
-   活动29中祭司B在活动14中投了票，祭司Γ在活动5和27中投了票，祭司∆在活动2和27中投了票。这些活动中最新的活动是27，所以按条件要求本活动必须和活动27的法令相同

为形式化描述B1(ℬ) - B3(ℬ) 我们需要添加一些记号。一个投票v有3个部分组成：祭司v<sub>pst</sub>，投票活动号v<sub>bal</sub>和法令v<sub>dec</sub>。它表示祭司v<sub>pst</sub>在投票活动v<sub>bal</sub>中为法令v<sub>dec</sub>选择的投票决定。Paxos定义空投票v<sub>bal</sub> = −∞，v<sub>dec</sub> = BLANK， 对任意投票活动b，−∞ < b < ∞，BLANK表示非法令，对任意祭司，定义null<sub>p</sub>对应v<sub>pst</sub> = p。

Paxos数学家对所有投票定义了一个总序，但部分手稿丢失了该定义。一些琐碎记录显示，对任意投票v和v'，如果v<sub>bal</sub> < v'<sub>bal</sub> 则v < v'。

对任意投票活动集合ℬ，集合Votes(ℬ)定义为包含所有投票v，v<sub>pst</sub> ∈ B<sub>vot</sub>，v<sub>bal</sub> = B<sub>bal</sub>，v<sub>dec</sub> = B<sub>dec</sub>，B ∈ ℬ。如果祭司p和b为一个活动号或±∞，则MaxVote(b, p, ℬ)定义为p投票的最大的投票v，v ∈ Votes(ℬ)v<sub>bal</sub> < b或null<sub>p</sub>。公式如下：
![img](./img/paxos_max_vote_formula.png)

对任意非空祭司集合Q，MaxVote(b, Q, ℬ)定义为集合Q中的祭司p的MaxVote(b, p, ℬ)的最大值。

条件B1(ℬ) - B3(ℬ)形式化描述如下：
![img](./img/paxos_single_decree_formula.png)

虽然MaxVote的定义依赖投票顺序，B1(ℬ)表明MaxVote(b, Q, ℬ)<sub>dec</sub>不依赖于相同活动序号的投票顺序。

为表示这些条件能满足一致性，Paxos人首先表示B1(ℬ) - B3(ℬ)意味着，如果ℬ中的一个投票活动B成功，则任意后面的集合ℬ中的活动，其法令跟本次活动相同的都是活动B。

引理：如果B1(ℬ)，B2(ℬ)，B3(ℬ)满足，则：
![img](./img/paxos_single_decree_lemma.png)

引理的证明

对ℬ集合中的任意投票活动B，定义Ψ(B,ℬ)为晚于B且法令不同于B中的法令的活动集合：
![img](./img/paxos_single_decree_ballot_set_define.png)

为证明引理，需表明如果B<sub>qrm</sub> ⊆ B<sub>vot</sub>，则Ψ(B, ℬ)为空。

Paxos人通过反证法，他们假设存在这样的活动B，B<sub>qrm</sub> ⊆ B<sub>vot</sub> 且 Ψ(B, ℬ) != ∅，则获得矛盾：
![img](./img/paxos_single_decree_lemma_proof1.png)
![img](./img/paxos_single_decree_lemma_proof2.png)

通过这个引理，我们能够得到定理1：
![img](./img/paxos_single_decree_theorem1.png)

Paxos人然后证明了另一个定理，假设如果议院里有足够多的祭司，通过条件B1 - B3能够指导得到一个成功的投票活动。虽然这里没有保证进度，但它至少显示了这样的过程不会被死锁。

定理2：设b为活动号，Q为祭司集合，对所有B ∈ ℬ，有b > B<sub>bal</sub>且Qb>∩B<sub>qrm</sub> !̸= ∅。如果B1(ℬ), B2(ℬ), and B3(ℬ)满足，则存在一个投票活动B'，B'<sub>bal</sub> = b且 B'<sub>qrm</sub> = B'<sub>vot</sub> = Q，使其满足B1(ℬ∪{B′}), B2(ℬ∪{B′})和B3(ℬ ∪ {B′})

证明：从条件B1(ℬ)和B1(ℬ∪{B′}) ，选择B'<sub>bal</sub>和假设b，从条件B2(ℬ)和B2(ℬ ∪ {B′}) ，选择B'<sub>qrm</sub>和假设Q，如果MaxVote(b, Q, ℬ)<sub>bal</sub> = −∞则让B'<sub>dec</sub>为任意法令，否则让它等于MaxVote(b, Q, ℬ)<sub>dec</sub>，则有B3(ℬ)和B3(ℬ ∪ {B′})


<a id="org3f97282"></a>

### 原始协议

Paxos人从B1(ℬ)–B3(ℬ) 条件下得出原始协议。协议定义指出集合ℬ如何改变，该集合不通过直接计算得出。Paxos人认为集合ℬ的数量只能被上帝观察到，任何凡人都不能。

每个投票活动都会被祭司初始化，祭司会选择一个序号，法令和法定人数。每个法定人数里的祭司能做出投或不投的决定。规则决定负责初始化的祭司如何选择投票活动的序号、法令、法定人数和在保证B1(ℬ)–B3(ℬ)条件下祭司如何投票。

为满足B1，每个投票活动需要有一个唯一的序号。通过记录在账本里的投票活动，祭司很容易避免不同的投票活动使用相同的号的问题。为避免不同的祭司初始化出相同的序号，需要在祭司间把可选的序号集进行划分。虽然不知道怎么做，但一个简单易见的方法是让活动序号为号码加祭司的组合，使用字典序，例如：

    (13, Γρα ̆ι) < (13, Λινσε ̆ι) < (15, Γρα ̆ι)

为满足B2，一个活动的法定人数里选择包含一组祭司μαδζ∂ωριτ ̆ισετ。初始化时，μαδζ∂ωριτ ̆ισετ表示简单多数。之后，观察到胖的祭司走动慢且花费更多的时间在议院中，所以μαδζ∂ωριτ ̆ισετ改变为祭司的集合，其总体重大于所有祭司体重的一半。当一些瘦的祭司抱怨不公时，实际的体重被替换为符号化的体重，其值基于祭司的出席记录。μαδζ∂ωριτ ̆ισετ的主要目的是使任何两个祭司集合，包含有μαδζ∂ωριτ ̆ισετ里的祭司则该两集合至少有一个共同的祭司。为满足B2，祭司初始化一个活动B，选择的B<sub>qrm</sub>需要是一个多数集合。

条件B3要求如果MaxVote(b, Q, ℬ)<sub>dec</sub>不为BLANK，则序号为b的活动和法定人数Q必须含有法令为MaxVote(b, Q, ℬ)<sub>dec</sub>。如果MaxVote(b, Q, ℬ)<sub>dec</sub>为BLANK，则投票活动的法令可以是任意法令。为满足条件B3(ℬ)，在初始化序号为b，法定人数为Q的新活动前，祭司p需要找到MaxVote(b, Q, ℬ)<sub>dec</sub>。这样，祭司p需要找到Q中每个祭司q的MaxVote(b, q, ℬ)。

祭司p给q发消息获得MaxVote(b, q, ℬ)。因此协议中一个投票活动祭司p的首要两步是：

1.  祭司p选择一个新的活动号b并发送一个NextBallot(b)的消息给一些集合中的祭司
2.  祭司q响应该消息，发送LastVote(b, v)消息给祭司p，v是祭司q参与的小于b的最大已投票活动号，若祭司q没有参与任何小于b的活动则为null<sub>q</sub>

祭司q必须在账本做备注来记录他的投票。

祭司q发送的LastVote(b, v)，v等于MaxVote(b, q, ℬ)。但集合ℬ的投票活动随着新投票活动的初始化和新的投票产生而变化。由于祭司p需要通过v来选择法令，为满足条件B3(ℬ)，在祭司q发送LastVote(b, v)消息后MaxVote(b, q, ℬ) 不能再改变。为此，祭司q在活动序号v<sub>bal</sub>和b之间的活动不能在参与投票。通过发送LastVote(b, v)消息，祭司q即承诺不再参与有关活动投票。（为保证这个承诺，祭司q必须在账本中记录一些必要的信息）

投票协议的接下来两步：

1.  在收到某个多数集合Q里的每个祭司的LastVote(b, v)消息后，祭司p初始化一个新的投票活动，序号为b，法定人数为Q，及法令d，d必须满足条件B3。则在账本记录该活动并发送一个BeginBallot(b, d)的消息给Q中的每一个祭司
2.  祭司q在收到BeginBallot(b, d)消息后，将做出对活动b的投票决定。（祭司可能不投，因这样可能会违背发送给；另一个投票活动LastVote(b', v')的承诺）如果祭司q对活动b做出决定，则他发送一个Voted(b, q)的消息给祭司q并在账本里做记录。

步骤3将向集合ℬ中添加一个活动B，其B<sub>bal</sub> = b，B<sub>qrm</sub> = Q, B<sub>vot</sub> = ∅（此时还没有人投票）和B<sub>dec</sub> = d。在步骤4中，如果祭司q决定对活动投票，则改变活动集合ℬ，即添加q到集合B<sub>vot</sub>, B ∈ ℬ。

祭司在步骤4中有权利不投票，即使投票不会违背任何承诺。事实上，协议的这些步骤都是可选的。例如，祭司q可以忽略NextBallot(b)消息而不执行步骤2。不采取行动会防止进展，但不会导致不一致性，因不违背条件B1(B)–B3(B)。甚至唯一的影响是未收到消息防止进一步行动发生，消息丢失也不会导致不一致。这样，协议保证了一致性，即使祭司离开议院或消息丢失。

收到重复的消息导致行为重复。除了步骤3，其他情况执行重复的行为并没有影响。例如，在步骤4中发送几个Voted(b, q)消息和发送一个效果相同。步骤3的重复通过账本记录可以防止。这样，一致性条件得到满足即使信使重复发送消息多次。

步骤1-4描述了初始化投票活动和投票的完整协议过程。剩下的是决定投票活动的结果和什么时间宣布法令。提醒一下投票活动成功当且仅当法定人数里的所有祭司都已投票。协议的剩下部分为：

1.  如果祭司p收到集合Q中的每个祭司q的Voted(b, q)消息，则他在账本中写入活动法令d，发送Success(d)消息作为响应
2.  收到Success(d)消息后，祭司q在账本中记录法令d

步骤1-6描述了一个投票活动的过程。原始协议允许任何祭司在任何时间初始化新的投票活动。每个步骤满足B1(ℬ)– B3(ℬ)，所以整个协议也满足该条件。祭司在账本中记录法令仅当该法令为一个成功的投票活动的法令。定理1意味着祭司的账本是一致的。协议未提及进度问题。

在步骤3中，通过条件B3决定法令，则有可能法令已经写入一些祭司的账本。祭司不需要在法定人数中，他可能离开了议院。这样如果步骤3允许更多的自由来选择法令d的话一致性将不能保证。


<a id="orgb3e795b"></a>

### 基本协议

原始协议中，祭司需要记录每个他初始化的投票活动号，每个投票，每个他发送的LastVote消息。记录所有这些信息对一个忙碌的祭司比较困难。Paxos人因此限制原始协议来获得更加实用的基本协议，使祭司p只需要维护下面信息到账本中：

1.  lastTried[p] 祭司p初始化的最新的活动序号，如没有则−∞
2.  prevVote[p] 祭司p投过票的最新的活动号，如没有则−∞
3.  nextBal[p] 祭司p发送过的LastVote(b, v)消息中最大的b值

原始协议的步骤1-6描述了祭司p如何指导单个投票活动。原始协议允许祭司p同时指导任意数量的投票活动。在基本协议中，只能允许一个时间一个活动，该活动号为lastTried[p]。祭司p初始化该活动后，他将忽略有关以前他初始化的其他活动的消息。祭司p会在纸片上记录lastTried[p]活动的所有进度信息。如果他丢失了该纸片，则他停止指导该活动。

在原始协议中，祭司q发送的每个LastVote(b, v)消息代表一个承诺不在v<sub>bal</sub>和b之间的任意活动中投票。在基本协议中，将代表一个更强的承诺：不去给活动号小于b的任何活动投票。这将防止该祭司在基本协议步骤4中投票，该行为在原始协议中是允许的。然而，原始协议总是给祭司q一个权利可以不投票，基本协议不要求他做任何原始协议不允许的事。

原始协议的步骤1-6变成如下基本协议的6个步骤（所有信息被祭司p用来指导投票活动，除了lastTried[p]，prevVote[p]，nextBal[p]记录在纸片中）。

1.  祭司p选择一个大于lastTried[p]的新活动号b，设置lastTried[p]为b，发送NextBallot(b)消息给一些祭司
2.  收到b > nextBal[q]的NextBallot(b)消息后，祭司q设置nextBal[q]为b，发送LastVote(b, v)消息给祭司p，v为prevVote[q]（如果b <= nextBal[q]，NextBallot(b)消息将被忽略）
3.  在收到祭司集合Q中每个祭司的LastVote(b, v)消息后，b = lastTried[p]，祭司p初始化一个新的投票活动，其号为b，法定人数为Q，法令为d，d需要满足条件B3。祭司p然后发送BeginBallot(b, d)消息给Q中每个祭司
4.  当收到b = nexgtBal[q]的BeginBallot(b, d)消息后，祭司q在活动b中投票，设置prevVote[q]为本次投票，发送Voted(b, q)消息给祭司p。（如果b != nexgtBal[q]则BeginBallot(b, d)消息将被忽略）
5.  如果祭司p收到Q中每个祭司q的Voted(b, q)消息，b = lastTried[p]，则祭司p把法令d写入账本并发送Success(d)消息给每个祭司。
6.  当收到Success(d)消息时，祭司在账本中记录法令d

基本协议是原始协议的限制版本，即基本协议允许的操作在原始协议中同样允许。因原始协议满足一致性，基本协议因此也满足一致性。跟原始协议一样，基本协议甚至不需要任何操作被执行，因此它也没有涉及进度问题。

然而，一些类似的显而易见的古老智慧被证明是错误的，一些质疑的市民要求一个更严谨的证明。这些Paxos数学家的证明协议满足一致性要求将放在附录中。


<a id="org53ef2e6"></a>

### 完整的会议协议


<a id="orga11dff1"></a>

# Tips

-   看源码，找一些经典、简短的，比较有效果
-   一个人自学确实进度偏慢，有人讨论还是很有必要的，不行的话只能网上找找资料
-   leetcode首先要看清题意
-   练leetcode首先熟悉套路，如果不能快速想出思路，说明这样的题还不熟悉，则想半小时到两小时，不行则不要纠结看题解，然后是细节优化
-   leetcode题如果比较复杂，可以先把一般情况写下来，然后再考虑特殊情况，先让题能过，最后再想优化


<a id="orgd44a7fb"></a>

# Share

<https://www.sqlite.org/wal.html>

Write-Ahead Logging


<a id="org7530943"></a>

## 简介

SQLite实现原子提交和回滚的默认方法是使用回滚日志。3.7.0版本之后，新出了一个"Write-Ahead Log"选项，简称WAL。

使用WAL的优点：

1.  WAL在大多数场景下更快
2.  WAL提供更好的并发，读不阻塞写，写不阻塞读。读写可并发执行。
3.  WAL使磁盘IO操作更加顺序执行
4.  WAL使用更少的fsync()函数，这样fsync()函数爆发的缺点不会像以前那么明显

缺点：

1.  WAL需要VFS支持共享内存。（除了一种特殊情况，后面会讲到）。unix和windows系统支持，但一些自定义系统的三方扩展可能不支持。
2.  使用数据库的所有进程必须在同一台主机上
3.  多个数据库的交易对于每个数据库是原子的，但对整个数据库集不是
4.  进入WAL模式后不能改变page size，只能在回滚日志模式下能改变
5.  3.22.0版本之后，只读WAL模式数据库文件在-shm和-wal文件存在或这些文件能被创建或数据库不能修改的情况下能被打开
6.  WAL模式在读多写少的情况下可能比传统回滚日志模式慢（慢1%-2%）
7.  每个数据库存在"-wal"文件和"-shm"共享内存文件，使SQLite不适合作为应用程序文件格式
8.  额外的checkpointing操作，虽然默认自动，需要应用开发人员注意
9.  3.11.0版本之后，WAL模式对于大交易跟回滚模式一样有效率


<a id="org743c852"></a>

## WAL如何工作

传统回滚日志模式先把原始未改变的数据库内容写入一个回滚日志文件，然后把改变写入数据库。当崩溃或回滚发生时，回滚日志里的原始内容会覆盖到数据库文件，使数据库回退到原始状态。当回滚日志删除后提交才会发生。

WAL模式刚好相反。原始内容保留在数据库文件，更新放入一个WAL文件。提交操作时提交内容添加到WAL文件。提交不需要写入到数据库文件，这样读操作可以继续访问数据库中未改变的部分。


<a id="orgc4c20e5"></a>

### checkpointing

checkpoint即把WAL文件中的交易记录合并到数据库中。

当WAL文件超过1000页面大小时SQLite会自动执行checkpoint（SQLITE_DEFAULT_WAL_AUTOCHECKPOINT编译选项可以用来改变默认值）。


<a id="orgeb53479"></a>

### 并行

当WAL模式数据库在执行一个读操作时，它首先找到WAL文件里最新有效提交记录的位置。该位置被叫做“end mark“。由于WAL文件会增长并添加新的提交记录，每个读者可能有各自的end mark。end mark在交易过程中不会改变。

当读者需要一页内容时，它首先检测WAL文件，如发现它会拷贝该页面。该页面应该在end mark之前，否则从数据库文件里拷贝。读者可能在不同的进程，为避免每个读者都去扫描整个WAL文件，读者可以通过共享内存中维护的wal-index数据结构来快速定位页面及最小化IO。wal-index极大地改进了读性能，但使用共享内存则意味着所有读者必须在同一台主机中。这是WAL模式不能工作在网络文件系统的原因。

写操作只是向WAL文件尾部添加内容。因为写操作不会干扰读操作，读写可以同时进行。然而因为只有一个WAL文件，写操作同一时段只能有一个。

当读者从数据库里读某页面时，而checkpoint需要把该页面内容从WAL写入数据库文件时，checkpoint操作将被取消。checkpoint会记住该页面的wal-index，下次调用时会更快找到该页。

一个长时间的读交易会阻碍checkpoint的进行。但每个读交易最终都会结束，checkpoint终有可能执行。

当写操作执行时，写操作会检查checkpoint的情况，如果整个WAL文件已经被同步到数据库并且没有读者使用WAL文件，则写操作会重定位文件到开头，并从开头写入新的交易内容。该机制防止WAL文件变得过大。


<a id="org6405da7"></a>

### 性能考量

由于写操作只写内容一次因此会很快（回滚日志交易写两次），并且写操作都是顺序的。同步到磁盘也不需要，如果应用程序愿意牺牲一些持久性（掉电或重启）的话（PRAGMA synchronous设置为FULL时每次交易会同步WAL文件，NORMAL是不同步）。

随着WAL文件增长读性能会下降，因为读操作需要检查WAL文件内容，检查时间随着文件大小增长，即使wal-index能帮助提高速度。因此要确保好的读性能需要定期调用checkpoint方法。

checkpoint把WAL文件内容同步到数据库之前需要先同步到磁盘，重置WAL文件之前数据库文件必须先同步。checkpoint会需要更多的seek操作，checkpoint会尽量顺序地写页面到数据库，但页面写入期间依然会有很多seek操作。这使得checkpoint操作比写交易慢。

默认的策略是允许连续地交易写入WAL文件直到文件大小超过1000个页面，则运行checkpoint操作进行同步直到WAL被恢复到小于1000页面大小。默认情况下，线程提交交易导致WAL文件大小超限时会自动执行checkpoint。这使得大部分的交易操作会很快，除了触发checkpoint时会变慢。如果该影响不能接受，应用程序可以禁止自动checkpoint操作，并用一个单独的线程或进程定期执行checkpoint。

当PRAGMA synchronous设置为NORMAL时，checkpoint仅处理I/O barrier和同步操作（unix系统里的fsync()或windows系统的FlushFileBuffers()）。如果应用程序在一个单独的线程或进程中执行checkpoint，主线程或进程在数据库查询或更新时不会被同步操作阻塞。这将帮助应用程序在磁盘读写频繁时出现锁定现象。缺点是交易不再耐久，当断电或硬重启时会被回滚。

注意这里对读性能和写性能有一个权衡。最大化读性能需要保持WAL文件尽量小，并因此频繁运行checkpoint，而最大化写性能，需要摊销每次checkpoint的写开销，即意味着checkpoint不要频繁调用并让WAL文件尽量增长。如何取舍需要根据应用程序读写情况来定，默认的策略在终端机中运行良好，但在不同的平台或不同的工作负载中用其他的策略或许更好。


<a id="org9de946e"></a>

## 激活和配置WAL模式

SQLite数据库连接默认journal_mode=DELETE，为使用WAL模式，使用如下语法：

    PRAGMA journal_mode=WAL;

该命令返回"wal"表示成功，如果转换模式失败，则使用之前的模式，返回"delete"。


<a id="orgf83b9ef"></a>

### 自动checkpoing

当交易提交导致WAL文件超过1000页面或最后的数据库连接关闭时，SQLite默认自动执行checkpoint。如果应用程序想要更多地控制可强制执行checkpoint，使用wal_checkpoint_pragma或调用sqlite3_wal_checkpoint()接口。通过wal_autocheckpoint_pragma或调用sqlite3_wal_autocheckpoint()接口可以改变自动执行checkpoint的阙值或禁止自动checkpoint。应用程序可以使用sqlite3_wal_hook()注册一个回调，当交易提交到WAL文件时被调用。该回调里可以调用sqlite3_wal_checkpoint()或sqlite3_wal_checkpoint_v2()（自动执行checkpoint机制即是通过sqlite3_wal_hook()来实现的）。


<a id="org3647acd"></a>

### 应用程序初始化checkpoint

应用程序可通过任意可写数据库连接执行checkpoint，调用sqlite3_wal_checkpoint()或sqlite3_wal_checkpoint_v2()即可。checkpoint有三种子类型：PASSIVE、FULL或RESTART。缺省类型为PASSIVE，在不干扰其他数据库连接时尽量做更多的工作，当有读者或写者并行时checkpoint可能不能执行完成。所有sqlite3_wal_checkpoint()和自动checkpoint机制为PASSIVE类型，FULL和RESTART类型会更激进地尝试执行checkpoint使其完成，该类型只能通过sqlite3_wal_checkpoint_v2()接口调用。


<a id="org9626b98"></a>

### WAL模式的持久性

WAL模式具有持久性。关闭和重新打开数据库时，数据库将进入WAL模式。相反，如果进程设置PRAGMA journal_mode=TRUNCATE并关闭重开数据库将回到缺省的DELETE模式。


<a id="org85cbaab"></a>

## WAL文件

当数据库连接打开一个WAL模式数据库时，SQLite将维持一个以数据库名后接"-wal"的文件，可通过SQLite编译选项SQLITE_ENABLE_8_3_NAMES改变该命名规则。

当有数据库连接打开数据库时WAL文件会一直存在。通常，当最后一个数据库连接关闭时WAL文件会自动删除。当打开数据库的最后一个进程退出并没有关闭数据库连接或使用了sqlite3_file_control()接口，则所有数据库连接关闭后WAL文件还会存在。WAL文件是数据库文件持久化的一部分，如果数据库被拷贝或移动时需要把WAL文件一并处理，否则交易可能被丢失，或数据库被损坏。唯一安全的删除WAL文件的方式是用sqlite3_open()接口打开数据库并立马使用sqlite3_close()关闭数据库。

WAL文件格式是跨平台的。


<a id="orgb2878d5"></a>

## 只读数据库

老版本的SQLite不能读取只读状态下的WAL模式数据库。即读取WAL模式数据库需要写访问权限。该限制在3.22.0版本被取消。

新版本的SQLite，在只读媒介中的WAL模式数据库或缺少写权限的WAL模式数据库，在满足如下条件下可以被读取：

1.  -shm和-wal文件存在并可读
2.  数据库所在目录可写
3.  数据库连接是使用不可修改查询参数选项打开的

虽然可以打开只读WAL模式数据库，烧录SQLite数据库镜像到只读媒介时更好的操作是先转换模式：PRAGMA journal_mode=DELETE。


<a id="org49ae438"></a>

## 避免过大的WAL文件

通常情况下，当WAL文件超过1000页面大小时sqlite会自动执行checkpoint来控制WAL文件大小，checkpoint不会截断WAL文件（除非journal_size_limit_pragma被设置）。它只是使SQLite从开头覆盖WAL文件。因为覆盖文件内容比添加新内容更快。当最后一个数据库连接关闭时，连接执行checkpoint并删除WAL文件和共享内存文件。

大多数情况下，应用程序不需要担心WAL文件过大的问题。但仍有可能使WAL文件过大，导致磁盘空间被过多占用及查询速度下降。以下是一些可能导致问题的情况及避免方法：

1.  禁止自动checkpoint机制
    
    默认是开启的，然而编译选项和运行时选项可能禁止或延迟自动checkpoint。如果应用程序禁止自动checkpoint，则没有办法防止WAL文件增长了。

2.  checkpoint starvation
    
    当没有其他数据库连接使用WAL文件时checkpoint才能完成执行，否则checkpoint不能重置WAL文件。checkpoint会在下个写交易后重新启动，直到一些checkpoint完成。
    
    然而，如果数据库一直存在读者会导致没有checkpiont执行完成，WAL文件将会不断变大。
    
    该场景可通过一个读者间隔概念避免，这时没有读者且checkpoint尝试执行完成。当应用程序有大量并行读者时，可以考虑运行手动的checkpoint，并带上SQLITE_CHECKPOINT_RESTART和SQLITE_CHECKPOINT_TRUNCATE选项，缺点是读者会被阻塞。

3.  超大的写交易
    
    checkpoint执行需要无交易在运行，数据库的大量修改则会导致大的WAL文件。checkpoint只能在该交易完成后执行。
    
    3.11.0版本的SQLite，WAL文件会对单个交易的大小做适配。交易改变的页面只写入WAL文件一次。然而，旧版本的SQLite，如果交易数据增长超过页面缓存，相同页面可能被写入WAL文件多次。


<a id="org366fbe2"></a>

## wal-index的共享内存实现

wal-index用普通文件mmap实现。之前的实现使用易失性共享内存，比如linux上的/dev/shm或unix上的/tmp。该问题是进程在不同root目录将看到不同的文件并因此使用不同的共享内存区域，导致数据库不一致。创建无命名共享内存块在不同unix系统中不能兼容，并且这在windows系统上是不行的。我们找到的唯一办法是使用共享内存mmap到数据库目录下来使所有进程能访问相同的数据库文件。

使用普通磁盘文件提供共享内存有一个缺点是可能有一些不必要的写共享内存到磁盘的IO操作。开发者不认为这个问题值得担忧因为wal-index文件很少超过32k字节并且不需要同步。当最后一个数据库连接关闭时，wal-index备份文件会被删除，这将防止出现实际的磁盘IO操作。

一些特殊的应用程序使用自定义的VFS不能支持共享内存，如果知道数据库只被一个进程的线程访问，wal-index可以用堆内存实现。


<a id="orgae2c0cd"></a>

## 使用没有共享内存的WAL模式

3.7.4版本之后，WAL模式可以在没有共享内存的情况下使用，需要第一次尝试访问是locking_mode设置为EXCLUSIVE。即保证只有一个进程访问数据库的情况即可。该特性允许WAL模式数据库在一些特殊VFS上创建和读写，只是sqlite3_io_methods里不含有版本2的共享内存方法xShmMap，xShmLock，xShmBarrier和xShmUnmap。

这种情况下SQLite不会调用任何共享内存方法，不创建共享内存的wal-index，数据库连接会一直保持在EXCLUSIVE模式，使用PRAGMA locking_mode=NORMAL;来改变模式会无效，唯一改变locking mode的方法是先改变WAL日志模式。

VFS必须支持版本2的共享内存，NORMAL locking mode才会起效，如果VFS不支持则在该模式下尝试打开WAL数据库或转换数据库为WAL模式都会失败。在只有一个数据库连接时，locking mode可以在NORMAL和EXCLUSIVE之间自由切换。只有当共享内存wal-index不允许，第一次WAL数据库访问前locking mode被设置为EXCLUSIVE时，locking mode只能停留在EXCLUSIVE。


<a id="orgc271db8"></a>

## WAL模式下一些查询返回SQLITE_BUSY

WAL模式下读写互不阻塞，但一些复杂情况下查询会返回SQLITE_BUSY，应用程序需要为该偶然情况做准备：

1.  如果另一个数据库连接以EXCLUSIVE locking mode打开，则所有的查询将返回SQLITE_BUSY。Chrome和Firefox都是EXCLUSIVE locking mode。
2.  当最后一个连接正在关闭，该连接会请求一个排他锁清理WAL和共享内存文件，如果另一个连接尝试打开则可能返回SQLITE_BUSY
3.  如果最后一个连接崩溃，则第一个新的连接会启动一个恢复进程，该进程会持有一个排他锁，则当其他连接尝试查询时会返回SQLITE_BUSY


<a id="org561577b"></a>

## 向后兼容性

老版本可能不能识别WAL和wal-index文件，当崩溃发生时老版本不能恢复WAL数据库，当其尝试连接时会报"file is encrypted or is not a database"的错误。

可以使用PRAGMA journal_mode=DELETE;改变WAL模式，这样老版本就可以访问了。


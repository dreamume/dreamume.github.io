
# Table of Contents

1.  [Algorithm](#org8d55fe5)
2.  [Review](#org8a92ed1)
    1.  [简介](#org5a82373)
    2.  [共识算法](#orgd5bf3e1)
        1.  [问题](#orgd8a3cf1)
        2.  [选择提议](#org5ad770a)
        3.  [学习一个选中的提议值](#org8e812f9)
        4.  [进度](#org3474a40)
        5.  [实现](#orgb6a1dbc)
    3.  [实现状态机](#org4209f98)
3.  [Tips](#org13d99ae)
4.  [Share](#orgdf37b95)
    1.  [简介](#org24583be)
    2.  [WAL如何工作](#orgc3f0b11)
        1.  [checkpointing](#org617b7e2)
        2.  [并行](#org4e5110b)
        3.  [性能考量](#org606b023)
    3.  [激活和配置WAL模式](#org4432b70)
        1.  [自动checkpoing](#org21f46ce)
        2.  [应用程序初始化checkpoint](#orgeed5558)
        3.  [WAL模式的持久性](#orga04346a)
    4.  [WAL文件](#orgdf296cb)
    5.  [只读数据库](#org73b70c7)
    6.  [避免过大的WAL文件](#org39c3f60)
    7.  [wal-index的共享内存实现](#org94aea5d)
    8.  [使用没有共享内存的WAL模式](#orgd8fa893)
    9.  [WAL模式下一些查询返回SQLITE_BUSY](#org6546f0b)
    10. [向后兼容性](#org8a17919)


<a id="org8d55fe5"></a>

# Algorithm

leetcode 673: <https://leetcode.com/problems/number-of-longest-increasing-subsequence/>

<https://medium.com/@dreamume/leetcode-673-number-of-longest-increasing-subsequence-5d05faa85070>


<a id="org8a92ed1"></a>

# Review

The Part-Time Parliament

<https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf>


<a id="org5a82373"></a>

## 简介

实现容错分布式系统的Paxos算法被认为难以理解，可能是原始论文是以古希腊故事呈现的，但事实上，它是最简单最显而易见的分布式算法。


<a id="orgd5bf3e1"></a>

## 共识算法


<a id="orgd8a3cf1"></a>

### 问题

假设一系列进程进行提议，共识算法则确保众多提议中只有一个被选中。如果没有任何提议，则没有任何提议会选中。如果一个提议被选中，则这些进程能够知道被选中的提议。共识需要满足如下安全性要求：

1.  只有提议的值能选中
2.  只有一个提议被选中
3.  直到提议被选中之前进程不知道有提议被选中

目的是确保最终某个提议被选中，如果一个提议被选中，则进程最终能知道这个提议。

我们定义共识算法中的三个角色：提议者，接收者和学习者。在实现中，一个进程可能扮演多个角色。

我们使用自定义的异步、非拜占庭模型：

-   可以在任意速度下工作，可能因为停止工作而故障，可以重启。因为可能在选中某提议后发生故障并重启，除非故障、重启等信息能被记录，否则没有解决方案
-   消息可以任意长时间才转发，复制，也可能会丢失，但不会损坏。


<a id="org5ad770a"></a>

### 选择提议

只有一个接受者的情况下最简单，提议者发送提议给接收者，接收者选择它收到的第一个提议。但是该方案会导致接收者故障的话后续处理无法进行。

另一种方式是有多个接收者，提议者发送提议给这些接收者。接收者可能接受该提议，当足够多的接收者接受该提议后该提议变为被选中状态。我们选择多数的接收者作为被选中的底线，因为两个多数集合至少有一个共同的接收者。当一个接收者最多接受一个提议时成立。

在没有故障和消息丢失的情况下，我们希望提议被选中即使只有一个提议者提议。这将要求：

P1 &#x2013; 接收者必须接受它收到的第一个提议。

但该要求引出一个问题。多个提议可能被多个提议者同时提出，导致一种情形即每个接收者接受一个提议，但没有一个提议占多数。即使只有两个提议，如果每个被一半的接收者接受，一个故障发生后的接收者却不能学习到应该选哪个。

P1和多数接收者接受才能变为选中状态的要求意味着接收者必须允许接受多个提议。我们通过给提议赋予一个序号来跟踪不同的提议，这样一个提议包含一个序号和提议值。为防止混淆，我们要求不同的提议有不同的序号。满足该要求依赖具体的实现，我们先假设是这样。

我们可以允许多个提议被选中，但需要保证这些提议的提议值是相同的。通过引入序号，则以下条件必满足：

P2 &#x2013; 如果一个提议被选中，则每个被选中的高序号提议跟该提议的提议值是相同的

P2<sup>a</sup> &#x2013; 如果提议被选中，该提议值为v，则每个被接受的高序号提议其提议值也为v

由于异步环境，一个提议可能被没有收到任何提议的接收者选中。假设一个新的提议者醒来，发布一个新的高序号提议，且提议值不同。P1要求接收者接受该提议，这将导致与P2<sup>a冲突</sup>。则需要有以下要求：

P2<sup>b</sup> &#x2013; 如果提议值v被选中，则每个发布的高序号提议的提议值都为v

进一步可推出：

P2<sup>c</sup> &#x2013; 对于任意提议值v和序号n，如果一个提议包含提议值v和序号n被发布，则存在一个集合S包含一个多数接收者，

-   不存在集合S中的接收者接受了任何小于n的提议
-   v是所有被集合S中的接收者接受的小于n的提议中最高序号提议的提议值

这样提议者想要发布序号n的提议之前必须知道小于n的最高序号提议（已经或将要被接受的提议，该提议是指被多数接收者中的接收者接受的提议）。学习已被接受的提议非常容易，预测将来的接受提议很困难。为避免预测，提议者通过获得承诺没有什么样的接受列表来控制。即提议者请求接收者不要接受小于n的提议。以下通过算法解决该问题：

1.  提议者选择序号n的新提议，发送一个请求给接收者集合的每一个成员，要求响应以下内容：
    
    1.  承诺不接受小于序号n的提议
    
    2.  如果有已接受的提议，返回小于n序号的最高接受提议
    
    我们称该请求为序号n的准备请求

2.  如果提议者接收到多数接收者的请求响应，则该提议者可以发布一个序号n和提议值为v的提议，v为响应中的最高序号提议值，或者响应无提议时v为提议值可选择的任意值

提议者发布一个提议，通过发送给一些接收者，请求提议被接受（不需要是响应初始请求的相同接收者集合）。我们把这个请求称为接受请求。

以上是提议者的算法，关于接收者，它会接收到两种类型提议者的请求：准备请求和接受请求。接收者可以无妥协的忽略任何请求。即：

P1<sup>a</sup> &#x2013; 接收者可以接受序号n的请求当且仅当它没有响应一个要求序号大于n的准备请求

最终的算法还需要一个小优化。假设接收者接受到一个准备请求要求序号n，但接收者已经响应了一个准备请求要求的序号n'大于n，因此承诺不接受任何序号n的提议。因此接收者不响应这个新准备请求，因为它不接受提议者想要发布的带序号n的提议。所以接收者忽略该准备请求。同样接收者将忽略新的它已接受的准备请求。

基于这个优化，接收者需要记住它接受的最高序号提议和它响应的最高序号的准备请求。因为P2<sup>c必须保持不变</sup>，不管是否故障，接收者故障重启后必须记住这些信息。注意提议者可以丢弃提议，它不会发布相同序号的另一个提议。

结合提议者和接收者的行为，我们看到算法分为以下两个阶段：

第一阶段：

1.  提议者选择一个序号n和发送一个带序号n的准备请求给多数接收者
2.  如果接收者接收一个带序号n的准备请求，该序号n大于任何它已经响应的准备请求中的序号，则接收者响应该请求，承诺不接受任何小于序号n的提议及给出它已接受的最高序号提议。

第二阶段：

1.  如果提议者接收到多数接收者的准备请求响应，则它发送一个带序号n和值v的接受请求给每个响应的接收者，v是响应中最高提议的值或者任意值（当响应中没有任何提议）
2.  如果接收者接受一个带序号n的接受请求，它接受该提议除非它已响应一个带大于序号n的准备请求

提议者可发起多个提议，每个提议各走一遍算法。提议者可在过程中任意时刻丢弃提议（即使提议者的请求或响应在提议被丢弃后才到达，依然可以保证正确性）。如果有提议者在尝试发布高序号的提议，则丢弃之前的提议是个好办法。因此，如果一个接收者忽略一个准备请求或接受请求，因为它已经接收到一个带更高序号的准备请求，接收者应该通知提议者丢弃提议。这是一个性能优化，并不影响正确性。


<a id="org8e812f9"></a>

### 学习一个选中的提议值

为了解已经被选中的提议值，一个学习者必须找到被多数接收者接受的提议。一个显见的算法是接受提议的接收者，响应所有的学习者，发送该提议。这使得学习者能尽快找到选中提议值，但它需要每个接收者响应每个学习者，响应数为接收者个数乘以学习者个数。

假设非拜占庭故障使一个学习者容易从另一个学习者发现已接受的提议值。我们可以使接收者响应不同的学习者，这些学习者再通知其他的学习者。这种实现需要额外一轮处理，而且可靠性变差，因为学习者故障将导致一些第二轮的学习者出现无法学习到的情况。但它需要的响应数少些，为接收者和学习者数目之和。

一般来说，接收者可以响应一系列不同的学习者，这些学习者再通知所有学习者。使用更大集合的学习者提供更高的可靠性，同时带来更高的通讯复杂度。

由于消息丢失，可能没有学习者找到已选中的提议值。学习者可询问接收者已接受的提议，但接收者故障可能导致是否有多数接受了某提议。这种情况下，学习者只有当新的提议被选中时才能找到。如果学习者需要知道是否一个提议值被选中，可以使一个提议值发布一个提议，使用上述描述的算法。


<a id="org3474a40"></a>

### 进度

我们可以构造一个场景，两个提议者各自发布一系列提议，序号为增序，而无提议被选中。提议者p完成序号n_1 的提议的第一阶段，另一个提议者q完成序号n_2 提议的第一阶段，n_2 > n_1。提议者p的第二阶段的接受请求被忽略，因为接收者承诺了不接受任何序号小于n_2 的任何提议。这样提议者p开始并完成新序号n_3 提议的第一阶段，n_3 > n_2，导致提议者q的第二阶段的接受请求被忽略。如此循环。

为保证进度，一个不同的提议者必须被选择作为唯一的提议者尝试发布提议。如果一个不同的提议者能跟多数接收者通讯，并且用一个提议其序号比当前所有使用的更大，则该提议能成功接受。如果提议者学习到一些请求带有更高的序号，通过丢弃提议并重新尝试，提议者最终能选择到一个足够高的序号。

如果整个系统工作正常，通过选举出一个不同的提议者能保证进度进行下去。Fischer，Lynch和Patterson的著名结论表示一个可靠的选举提议者算法必须使用随机或实时 &#x2013; 例如通过使用超时。然而，安全性可以得到保证，不管选举成功或失败。


<a id="orgb6a1dbc"></a>

### 实现

在共识算法中，每个进程扮演提议者、接收者或学习者的角色。请求和响应通过消息来传送。算法选择一个领导，扮演不同的提议者和不同的学习者角色。稳定的持久化存储，用来维护接收者必须记录的信息。接收者在发送响应之前把响应记录进持久化存储中。

剩下的用来描述机制保证没有两个提议者发布相同序号的提议。不同的提议者选择不相交集合中的数，这样两个不同的提议者不会发布相同序号的提议。每个提议者记录它尝试发布的最高序号的提议，并且用一个比它所有使用过的更高的序号开始第一阶段。


<a id="org4209f98"></a>

## 实现状态机

一个实现分布式简单的方法是所有客户端发布命令给中央服务器。该服务器可被描述为确定性状态机，串行执行客户端命令。状态机有当前的状态，从输入端获取执行步骤，产生输出和一个新的状态。一旦该服务器故障则无法工作。我们然后选择用多个服务器，每个都独立执行状态机。

为保障所有服务器执行相同序列的状态机命令，我们实现一系列Paxos共识算法的独立实例，每个服务器扮演算法实例里的所有角色（提议者、接收者和学习者）。

在正常操作中，一个服务器被选举为领导。客户端发送命令给领导，领导决定每个命令出现在何处。如果领导决定某个客户端应该是第135个命令，它尝试把这个命令选择为第135个共识算法实例的值。它可能成功，可能因为故障失败，或因为另一个服务器相信它自己为领导并且对第135个命令有不同的看法。但共识算法确保至多一个命令能被选中作为第135个。

效率的关键是在Paxos共识算法中，被提议的值应该在第二阶段才被选中。完成第一阶段的提议者算法，要么被提议值被确定或提议者可以自由的提议任何值。

我将描述Paxos状态机实现在正常操作中如何工作。之后，将讨论什么将导致出错。考虑当之前的领导故障和新的领导被选择是发生什么（系统启动是一个特殊例子，此时还没有命令被提议）。

一个新的领导，作为所有实例共识算法的学习者，应该知道已被选择的大多数命令。假设它知道命令1-134，138和139 &#x2013; 实例1-134，138和139被选中的值，然后执行实例135-137实例的第一阶段和所有大于139的所有实例。假设这些执行的输出决定被提议的135和140实例的值，而对其他实例无限制。领导然后执行135和140实例的第二阶段，然后选择命令135和140。

领导现在执行命令1-135。然而，它不执行命令138-140，因为命令136和137还没有被选择。领导可以选择下来的两个命令136和137，然而，我们让它填补隔阂立即提议，作为命令136和137，一个特殊的"no-op"命令让状态不变（通过执行共识算法实例136和137的第二阶段）。一旦no-op命令被选中，命令138-140即可被执行。

命令1-140现在都被选中。领导同样完成所有大于140的实例的第一阶段，可以提议这些实例的任何提议值。它赋予命令141给客户端请求的下一个命令，提议它作为141共识算法实例的第二阶段的值。提议下一个收到的客户端命令作为命令142，等等。

领导可以在学习到它的提议命令141被选中之前提议命令142。可能发送提议命令141的所有消息都丢失了，在所有其他服务器学习到领导提议什么作为命令141之前命令142已被选中。当领导未收到实例141第二阶段消息的响应，它将重传这些信息。如果正常，被提议的命令将被选中。然而，它可能失败。一般来说，假设领导可领a命令超前 &#x2013; 在1-i命令被选中之后提议命令i + 1到i + a。

一个新选中的领导如上述场景所述执行无穷多共识算法实例的第一阶段，实例135-137和所有实例大于139。使用所有实例的相同提议数值，通过发送一个短消息给所有服务器。在第一阶段，一个接收者响应多个OK仅在它收到一些建议者的第二阶段消息（在这个场景中，指实例135和140）。这样，这个服务器（作为接收者）可以响应所有实例的一个短消息。因此执行这些无穷多实例的第一阶段没有问题。

因为领导故障并选举一个新的领导不是一个常见的事情。执行状态机命令的有效成本 &#x2013; 获得命令/值的共识 &#x2013; 是执行共识算法的第二阶段成本。在允许故障的情况下Paxos共识算法的第二阶段具有所有算法的最小可能成本来达到共识。因此，Paxos算法本质上是最好的算法了。

系统正常操作的讨论假设总是只有一个领导，除了短暂的领导故障新领导选举期间。在异常环境下，领导选举可能失败。如果没有服务器作为领导，则没有新的命令被提议。如果多个服务器认为自己作为领导，则他们都能在共识算法实例中提议，可能导致无值被选中。然而，安全性能够得到保障，两个不同的服务器不会在某值选中作为第i个状态机命令上发生分歧。

如果服务器变动，则必须有什么方法确定什么服务器实现共识算法的什么实例。最容易的办法是通过状态机本身。当前的服务器可以使部分状态和状态机命令改变，我们可以允许一个领导提前获得a命令，通过一系列服务器执行实例i + a共识算法，在执行第i个状态机命令之后。这样允许任意复杂的重新配置算法的简单实现。


<a id="org13d99ae"></a>

# Tips

-   看源码，找一些经典、简短的，比较有效果


<a id="orgdf37b95"></a>

# Share

<https://www.sqlite.org/wal.html>

Write-Ahead Logging


<a id="org24583be"></a>

## 简介

SQLite实现原子提交和回滚的默认方法是使用回滚日志。3.7.0版本之后，新出了一个"Write-Ahead Log"选项，简称WAL。

使用WAL的优点：

1.  WAL在大多数场景下更快
2.  WAL提供更好的并发，读不阻塞写，写不阻塞读。读写可并发执行。
3.  WAL使磁盘IO操作更加顺序执行
4.  WAL使用更少的fsync()函数，这样fsync()函数爆发的缺点不会像以前那么明显

缺点：

1.  WAL需要VFS支持共享内存。（除了一种特殊情况，后面会讲到）。unix和windows系统支持，但一些自定义系统的三方扩展可能不支持。
2.  使用数据库的所有进程必须在同一台主机上
3.  多个数据库的交易对于每个数据库是原子的，但对整个数据库集不是
4.  进入WAL模式后不能改变page size，只能在回滚日志模式下能改变
5.  3.22.0版本之后，只读WAL模式数据库文件在-shm和-wal文件存在或这些文件能被创建或数据库不能修改的情况下能被打开
6.  WAL模式在读多写少的情况下可能比传统回滚日志模式慢（慢1%-2%）
7.  每个数据库存在"-wal"文件和"-shm"共享内存文件，使SQLite不适合作为应用程序文件格式
8.  额外的checkpointing操作，虽然默认自动，需要应用开发人员注意
9.  3.11.0版本之后，WAL模式对于大交易跟回滚模式一样有效率


<a id="orgc3f0b11"></a>

## WAL如何工作

传统回滚日志模式先把原始未改变的数据库内容写入一个回滚日志文件，然后把改变写入数据库。当崩溃或回滚发生时，回滚日志里的原始内容会覆盖到数据库文件，使数据库回退到原始状态。当回滚日志删除后提交才会发生。

WAL模式刚好相反。原始内容保留在数据库文件，更新放入一个WAL文件。提交操作时提交内容添加到WAL文件。提交不需要写入到数据库文件，这样读操作可以继续访问数据库中未改变的部分。


<a id="org617b7e2"></a>

### checkpointing

checkpoint即把WAL文件中的交易记录合并到数据库中。

当WAL文件超过1000页面大小时SQLite会自动执行checkpoint（SQLITE_DEFAULT_WAL_AUTOCHECKPOINT编译选项可以用来改变默认值）。


<a id="org4e5110b"></a>

### 并行

当WAL模式数据库在执行一个读操作时，它首先找到WAL文件里最新有效提交记录的位置。该位置被叫做“end mark“。由于WAL文件会增长并添加新的提交记录，每个读者可能有各自的end mark。end mark在交易过程中不会改变。

当读者需要一页内容时，它首先检测WAL文件，如发现它会拷贝该页面。该页面应该在end mark之前，否则从数据库文件里拷贝。读者可能在不同的进程，为避免每个读者都去扫描整个WAL文件，读者可以通过共享内存中维护的wal-index数据结构来快速定位页面及最小化IO。wal-index极大地改进了读性能，但使用共享内存则意味着所有读者必须在同一台主机中。这是WAL模式不能工作在网络文件系统的原因。

写操作只是向WAL文件尾部添加内容。因为写操作不会干扰读操作，读写可以同时进行。然而因为只有一个WAL文件，写操作同一时段只能有一个。

当读者从数据库里读某页面时，而checkpoint需要把该页面内容从WAL写入数据库文件时，checkpoint操作将被取消。checkpoint会记住该页面的wal-index，下次调用时会更快找到该页。

一个长时间的读交易会阻碍checkpoint的进行。但每个读交易最终都会结束，checkpoint终有可能执行。

当写操作执行时，写操作会检查checkpoint的情况，如果整个WAL文件已经被同步到数据库并且没有读者使用WAL文件，则写操作会重定位文件到开头，并从开头写入新的交易内容。该机制防止WAL文件变得过大。


<a id="org606b023"></a>

### 性能考量

由于写操作只写内容一次因此会很快（回滚日志交易写两次），并且写操作都是顺序的。同步到磁盘也不需要，如果应用程序愿意牺牲一些持久性（掉电或重启）的话（PRAGMA synchronous设置为FULL时每次交易会同步WAL文件，NORMAL是不同步）。

随着WAL文件增长读性能会下降，因为读操作需要检查WAL文件内容，检查时间随着文件大小增长，即使wal-index能帮助提高速度。因此要确保好的读性能需要定期调用checkpoint方法。

checkpoint把WAL文件内容同步到数据库之前需要先同步到磁盘，重置WAL文件之前数据库文件必须先同步。checkpoint会需要更多的seek操作，checkpoint会尽量顺序地写页面到数据库，但页面写入期间依然会有很多seek操作。这使得checkpoint操作比写交易慢。

默认的策略是允许连续地交易写入WAL文件直到文件大小超过1000个页面，则运行checkpoint操作进行同步直到WAL被恢复到小于1000页面大小。默认情况下，线程提交交易导致WAL文件大小超限时会自动执行checkpoint。这使得大部分的交易操作会很快，除了触发checkpoint时会变慢。如果该影响不能接受，应用程序可以禁止自动checkpoint操作，并用一个单独的线程或进程定期执行checkpoint。

当PRAGMA synchronous设置为NORMAL时，checkpoint仅处理I/O barrier和同步操作（unix系统里的fsync()或windows系统的FlushFileBuffers()）。如果应用程序在一个单独的线程或进程中执行checkpoint，主线程或进程在数据库查询或更新时不会被同步操作阻塞。这将帮助应用程序在磁盘读写频繁时出现锁定现象。缺点是交易不再耐久，当断电或硬重启时会被回滚。

注意这里对读性能和写性能有一个权衡。最大化读性能需要保持WAL文件尽量小，并因此频繁运行checkpoint，而最大化写性能，需要摊销每次checkpoint的写开销，即意味着checkpoint不要频繁调用并让WAL文件尽量增长。如何取舍需要根据应用程序读写情况来定，默认的策略在终端机中运行良好，但在不同的平台或不同的工作负载中用其他的策略或许更好。


<a id="org4432b70"></a>

## 激活和配置WAL模式

SQLite数据库连接默认journal_mode=DELETE，为使用WAL模式，使用如下语法：

    PRAGMA journal_mode=WAL;

该命令返回"wal"表示成功，如果转换模式失败，则使用之前的模式，返回"delete"。


<a id="org21f46ce"></a>

### 自动checkpoing

当交易提交导致WAL文件超过1000页面或最后的数据库连接关闭时，SQLite默认自动执行checkpoint。如果应用程序想要更多地控制可强制执行checkpoint，使用wal_checkpoint_pragma或调用sqlite3_wal_checkpoint()接口。通过wal_autocheckpoint_pragma或调用sqlite3_wal_autocheckpoint()接口可以改变自动执行checkpoint的阙值或禁止自动checkpoint。应用程序可以使用sqlite3_wal_hook()注册一个回调，当交易提交到WAL文件时被调用。该回调里可以调用sqlite3_wal_checkpoint()或sqlite3_wal_checkpoint_v2()（自动执行checkpoint机制即是通过sqlite3_wal_hook()来实现的）。


<a id="orgeed5558"></a>

### 应用程序初始化checkpoint

应用程序可通过任意可写数据库连接执行checkpoint，调用sqlite3_wal_checkpoint()或sqlite3_wal_checkpoint_v2()即可。checkpoint有三种子类型：PASSIVE、FULL或RESTART。缺省类型为PASSIVE，在不干扰其他数据库连接时尽量做更多的工作，当有读者或写者并行时checkpoint可能不能执行完成。所有sqlite3_wal_checkpoint()和自动checkpoint机制为PASSIVE类型，FULL和RESTART类型会更激进地尝试执行checkpoint使其完成，该类型只能通过sqlite3_wal_checkpoint_v2()接口调用。


<a id="orga04346a"></a>

### WAL模式的持久性

WAL模式具有持久性。关闭和重新打开数据库时，数据库将进入WAL模式。相反，如果进程设置PRAGMA journal_mode=TRUNCATE并关闭重开数据库将回到缺省的DELETE模式。


<a id="orgdf296cb"></a>

## WAL文件

当数据库连接打开一个WAL模式数据库时，SQLite将维持一个以数据库名后接"-wal"的文件，可通过SQLite编译选项SQLITE_ENABLE_8_3_NAMES改变该命名规则。

当有数据库连接打开数据库时WAL文件会一直存在。通常，当最后一个数据库连接关闭时WAL文件会自动删除。当打开数据库的最后一个进程退出并没有关闭数据库连接或使用了sqlite3_file_control()接口，则所有数据库连接关闭后WAL文件还会存在。WAL文件是数据库文件持久化的一部分，如果数据库被拷贝或移动时需要把WAL文件一并处理，否则交易可能被丢失，或数据库被损坏。唯一安全的删除WAL文件的方式是用sqlite3_open()接口打开数据库并立马使用sqlite3_close()关闭数据库。

WAL文件格式是跨平台的。


<a id="org73b70c7"></a>

## 只读数据库

老版本的SQLite不能读取只读状态下的WAL模式数据库。即读取WAL模式数据库需要写访问权限。该限制在3.22.0版本被取消。

新版本的SQLite，在只读媒介中的WAL模式数据库或缺少写权限的WAL模式数据库，在满足如下条件下可以被读取：

1.  -shm和-wal文件存在并可读
2.  数据库所在目录可写
3.  数据库连接是使用不可修改查询参数选项打开的

虽然可以打开只读WAL模式数据库，烧录SQLite数据库镜像到只读媒介时更好的操作是先转换模式：PRAGMA journal_mode=DELETE。


<a id="org39c3f60"></a>

## 避免过大的WAL文件

通常情况下，当WAL文件超过1000页面大小时sqlite会自动执行checkpoint来控制WAL文件大小，checkpoint不会截断WAL文件（除非journal_size_limit_pragma被设置）。它只是使SQLite从开头覆盖WAL文件。因为覆盖文件内容比添加新内容更快。当最后一个数据库连接关闭时，连接执行checkpoint并删除WAL文件和共享内存文件。

大多数情况下，应用程序不需要担心WAL文件过大的问题。但仍有可能使WAL文件过大，导致磁盘空间被过多占用及查询速度下降。以下是一些可能导致问题的情况及避免方法：

1.  禁止自动checkpoint机制
    
    默认是开启的，然而编译选项和运行时选项可能禁止或延迟自动checkpoint。如果应用程序禁止自动checkpoint，则没有办法防止WAL文件增长了。

2.  checkpoint starvation
    
    当没有其他数据库连接使用WAL文件时checkpoint才能完成执行，否则checkpoint不能重置WAL文件。checkpoint会在下个写交易后重新启动，直到一些checkpoint完成。
    
    然而，如果数据库一直存在读者会导致没有checkpiont执行完成，WAL文件将会不断变大。
    
    该场景可通过一个读者间隔概念避免，这时没有读者且checkpoint尝试执行完成。当应用程序有大量并行读者时，可以考虑运行手动的checkpoint，并带上SQLITE_CHECKPOINT_RESTART和SQLITE_CHECKPOINT_TRUNCATE选项，缺点是读者会被阻塞。

3.  超大的写交易
    
    checkpoint执行需要无交易在运行，数据库的大量修改则会导致大的WAL文件。checkpoint只能在该交易完成后执行。
    
    3.11.0版本的SQLite，WAL文件会对单个交易的大小做适配。交易改变的页面只写入WAL文件一次。然而，旧版本的SQLite，如果交易数据增长超过页面缓存，相同页面可能被写入WAL文件多次。


<a id="org94aea5d"></a>

## wal-index的共享内存实现

wal-index用普通文件mmap实现。之前的实现使用易失性共享内存，比如linux上的/dev/shm或unix上的/tmp。该问题是进程在不同root目录将看到不同的文件并因此使用不同的共享内存区域，导致数据库不一致。创建无命名共享内存块在不同unix系统中不能兼容，并且这在windows系统上是不行的。我们找到的唯一办法是使用共享内存mmap到数据库目录下来使所有进程能访问相同的数据库文件。

使用普通磁盘文件提供共享内存有一个缺点是可能有一些不必要的写共享内存到磁盘的IO操作。开发者不认为这个问题值得担忧因为wal-index文件很少超过32k字节并且不需要同步。当最后一个数据库连接关闭时，wal-index备份文件会被删除，这将防止出现实际的磁盘IO操作。

一些特殊的应用程序使用自定义的VFS不能支持共享内存，如果知道数据库只被一个进程的线程访问，wal-index可以用堆内存实现。


<a id="orgd8fa893"></a>

## 使用没有共享内存的WAL模式

3.7.4版本之后，WAL模式可以在没有共享内存的情况下使用，需要第一次尝试访问是locking_mode设置为EXCLUSIVE。即保证只有一个进程访问数据库的情况即可。该特性允许WAL模式数据库在一些特殊VFS上创建和读写，只是sqlite3_io_methods里不含有版本2的共享内存方法xShmMap，xShmLock，xShmBarrier和xShmUnmap。

这种情况下SQLite不会调用任何共享内存方法，不创建共享内存的wal-index，数据库连接会一直保持在EXCLUSIVE模式，使用PRAGMA locking_mode=NORMAL;来改变模式会无效，唯一改变locking mode的方法是先改变WAL日志模式。

VFS必须支持版本2的共享内存，NORMAL locking mode才会起效，如果VFS不支持则在该模式下尝试打开WAL数据库或转换数据库为WAL模式都会失败。在只有一个数据库连接时，locking mode可以在NORMAL和EXCLUSIVE之间自由切换。只有当共享内存wal-index不允许，第一次WAL数据库访问前locking mode被设置为EXCLUSIVE时，locking mode只能停留在EXCLUSIVE。


<a id="org6546f0b"></a>

## WAL模式下一些查询返回SQLITE_BUSY

WAL模式下读写互不阻塞，但一些复杂情况下查询会返回SQLITE_BUSY，应用程序需要为该偶然情况做准备：

1.  如果另一个数据库连接以EXCLUSIVE locking mode打开，则所有的查询将返回SQLITE_BUSY。Chrome和Firefox都是EXCLUSIVE locking mode。
2.  当最后一个连接正在关闭，该连接会请求一个排他锁清理WAL和共享内存文件，如果另一个连接尝试打开则可能返回SQLITE_BUSY
3.  如果最后一个连接崩溃，则第一个新的连接会启动一个恢复进程，该进程会持有一个排他锁，则当其他连接尝试查询时会返回SQLITE_BUSY


<a id="org8a17919"></a>

## 向后兼容性

老版本可能不能识别WAL和wal-index文件，当崩溃发生时老版本不能恢复WAL数据库，当其尝试连接时会报"file is encrypted or is not a database"的错误。

可以使用PRAGMA journal_mode=DELETE;改变WAL模式，这样老版本就可以访问了。


---
layout:     post
title:      "Weekly 038"
subtitle:   "Algorithm:; Review: digital video introduction, Redundancy removal; Share: Scalability for Dummies, Asynchronism"
thumbnail-img: ""
date:       2021-04-06 14:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org9890338)
2.  [Review](#orgb874c60)
3.  [Tips](#orgcb64a58)
4.  [Share](#org2401d34)
    1.  [第一种](#orgbc72147)
    2.  [第二种](#org81db141)


<a id="org9890338"></a>

# Algorithm

Leetcode 363: 


<a id="orgb874c60"></a>

# Review

digital video introduction

<https://github.com/leandromoreira/digital_video_introduction#intro>


<a id="orgcb64a58"></a>

# Tips

-   把学的东西能简单概要的讲出来，才能说明真学懂了，而且所讲的东西能体现你理解的程度


<a id="org2401d34"></a>

# Share

Scalability for Dummies - Part 4: Asynchronism

<https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism>

系列的第4部分开始于一个场景：想象你想要在你喜欢的面包店买面包。你进入面包店，要一块面包，但现在没有面包。你要求当你的面包订单好了后2小时内再来。这很让人恼火，是吧？

为避免这样请等一会的问题，需要异步。这样对面包店好，也同样对你的web服务或web app好

一般地，有两种异步范型


<a id="orgbc72147"></a>

## 第一种

让我们用之前的面包店的场景继续说明。异步处理的第一部是“在晚上烤面包且在早上出售“。对应web应用程序这意味着做一些耗时且服务于完成的工作的事情在低请求时期

常见的这种范式用来转换动态内容为静态内容。网站的页面，可能用大量框架或CMS构建，在每次改变后预渲染和本地存储为静态HTML文件。通常这些计算任务在一个常规的基准上完成，可能是一个脚本被cronjob每小时调用。这种预计算产生的数据极大地改善网站和web app，使得它们容易扩展和高效。想象你的网站的扩张性如果脚本上传这些预渲染的HTML页面到AWS S3或Cloudfront或其他内容转发网络！你的网站将每小时快速响应和处理百万级的访问！


<a id="org81db141"></a>

## 第二种

不幸地是，有些时候客户有特殊请求比如一个生日蛋糕带祝福语“Steve，生日快乐！“面包店不能预测这类客户的祝福，这样它必须在客户在面包店里时开始该任务并告诉他在明天回来。对web服务这意味着异步处理任务

一个典型的工作流：

一个用户来到你的网站且开始一个计算密集型任务，该任务可能将花费数分钟完成。这样你的网站前端发送一个工作给工作队列且立即通知给用户：你的工作在处理中，请继续浏览网页。工作队列让一些工作线程处理新的工作。如果有新的工作则工作线程处理并数分钟后发送信号说明已完成。前端检查该信号，收到后通知用户。这是一个非常简单的例子

如果你现在想要深入一些细节且做技术设计，我推荐你看RabbitMQ的前3个简要说明。RabbitMQ是帮助实现异步处理的系统之一。你也可以使用ActiveMQ或一个简单的Redis列表。基本的思想是有一个任务队列用来待处理。异步似乎比较复杂，但它值得你花时间学习它且亲自实现它。后端变得近乎无限扩展且前端让用户体验更有吸引力

如果你做一些耗时的事情，尝试异步去做

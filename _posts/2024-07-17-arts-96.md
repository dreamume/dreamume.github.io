---
layout:     post
title:      "Weekly 096"
subtitle:   "Algorithm: ; Review: ; Tips: ; Share: Maximum subarray problem"
thumbnail-img: ""
date:       2024-07-17 10:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org3bdb773)
2.  [Review](#org4036f2f)
3.  [Tips](#orgcb14882)
4.  [Share](#org098b57f)
    1.  [历史](#org106d6b1)
    2.  [应用程序](#org9d6a794)
    3.  [Kadane 算法](#org8b21447)
        1.  [不允许空数组](#org9129de5)
        2.  [允许空子数组](#org1def615)
        3.  [计算最好子数组的位置](#orgf3c150d)
        4.  [复杂度](#orgc39a11a)
    4.  [一般化](#orgce76a59)


<a id="org3bdb773"></a>

# Algorithm


<a id="org4036f2f"></a>

# Review


<a id="orgcb14882"></a>

# Tips


<a id="org098b57f"></a>

# Share

[Maximum subarray problem](https://en.wikipedia.org/wiki/Maximum_subarray_problem)

在计算机科学中，最大子数组和问题，也被称为最大段和问题，是对一维数组中找到连续子数组中最大和。它可在 O(n) 时间复杂度和 O(1) 空间复杂度下完成

形式上，该任务是找到下标 i 和 j，1 <= i < j <= n，使得和

$ \\sum^{j}_ {x=i} A[x] $

最大（一些问题公式也允许考虑空子数组；为方便起见，空子数组的和为 0）。输入数组的每个数可为正、负或零

例如，对数组 [-2, 1, -3, 4, -1, 2, 1, -5, 4]，最大连续子数组 [4, -1, 2, 1] 和为 6

这个问题的某些属性：

1.  如果数组包含所有非负数，则最大子数组为整个数组
2.  如果数组包含所有非正数，则结果是包含最大值的长度为 1 的子数组（或空数组，如果允许的话）
3.  一些不同的子数组可能有相同的最大和

虽然这个问题可使用不同的算法技巧解决，包括暴力求解，分治，动态规划和缩变为最短路径，一个简单的被称为 Kadane 算法的一次处理算法解决这个问题非常高效


<a id="org106d6b1"></a>

## 历史

最大子数组问题于 1977 年由 Ulf Grenander 在数字化图形中作为最大可能估计范型的简化模型提出

Grenander 在寻找一个矩形子数组最大和，在两维实数数组中。一个暴力求解算法运行要 $ O(n^{6}) $ 时间复杂度；因为这明显地慢，Grenander 提出一维问题来获得它的结构的一些洞察力。Grenander 分隔一个算法在 $ O(n^{2}) $ 时间复杂度下解决一维问题，改进暴力求解的 $ O(n^{3}) $。当 Michael Shamos 听说这个问题后，他花了整晚发明了一个 $ O(n \\log{n}) $ 分治算法。不久之后，Shamos 在卡梅隆大学的一个研讨会上描述了一维问题和他的历史，Jay Kadane 出席了该研讨会，其用一分钟时间设计了一个 $ O(n) $ 时间复杂度算法。在 1982 年，David Gries 通过应用 Dijkstra 的标准策略获得了相同的 $ O(n) $ 时间复杂度算法；其起源于 1989 年 Richard Bird 使用 Bird-Meertens 形式通过纯代数乘法的暴力求解算法

Grenander 的两维一般化形式作为子程序通过使用 Kadane 的算法可在 $ O(n^{3}) $ 时间复杂度下解决，或通过分治处理。更快的算法基于 Tamaki & Tokuyama(1998) 和 Takaoka(2002) 提出的距离矩阵乘法。有一些证据显示没有明显更快的算法存在；一个在 $ O(n^{3 - \\varepsilon}), \\forall \\varepsilon > 0 $ 时间复杂度下解决两维最大子数组问题算法，可应用于所有配对最短路径问题的相似算法


<a id="org9d6a794"></a>

## 应用程序

最大子数组问题在许多领域出现过，比如基因序列分析和计算机视觉

基因序列分析应用最大子数组算法确定不寻常的重要的蛋白质序列的生物段，通过对序列中对点打分，当一个范型被识别存在则为正，否则为负，且然后在这些分数中寻找最大子数组。这些问题包括节省段、GC-rich 范围、协同重复、低复杂度过滤、DNA 绑定域和高收费区域

在计算机视觉中，位图图像一般只包含正值，则最大子数组问题是显然的：结果总是整个数组。然而，在对每个像素减去一个阙值（比如像素平均值），这样在平均值之上的像素为正，之下则为负，最大子数组问题可被应用于修改图像来检测明亮区域


<a id="org8b21447"></a>

## Kadane 算法


<a id="org9129de5"></a>

### 不允许空数组

Kadane 算法从左到右扫描给定数组 A[1 ... n]。在第 j 步，它计算以 j 结尾的最大子数组和；这个和维护在变量 current_sum 中。且它计算任意在 A[1 ... j] 中的子数组和，维护在变量 best_sum 中

作为一个循环不变量，在第 j 步中，current_sum 的旧值持有和 $ A[i] + \\cdots + A[j - 1], \\forall i \\in \\{1, \\ldots, j-1\\} $。因此，current_sum + A[j] 是最大和 $ A[i] + \\cdots + A[j], i \\in \\{1, \\ldots, j-1\\} $。为扩展后续的最大覆盖 i = j 的情况，可考虑单子数组 $ A[j \\ldots j] $。在第 6 行通过赋值 max(A[j], current_sum + A[j]) 作为 current_sum 的新值，其之后持有对 $ i \\in \\{1, \\ldots, j \\}, A[i] + \\cdots + A[j] $ 和的最大

这样，问题可被如下 Python 代码解决

    def max_subarray(numbers):
        """Find the largest sum of any contiguous subarray."""
        best_sum = - infinity
        current_sum = 0
        for x in numbers:
            current_sum = max(x, current_sum + x)
            best_sum = max(best_sum, current_sum)
        return best_sum

如果输入不包含正元素，返回值为最大的元素，或负无穷如果输入为空。为正确性，当输入数组为空时一个异常应该抛出，因为一个空数组没有最大非空子数组。如果数组非空，它的第一个元素可被用来替换负无穷，如果需要避免混淆数和非数值


<a id="org1def615"></a>

### 允许空子数组

Kadane 原始的算法解决空子数组为允许的情况。如果输入不包含正元素这个变种会返回 0。它对代码包含两个改变：在第 3 行，best_sum 应该初始化为 0 和第 6 行 current_sum 应该更新为 max(0, current_sum + x)


<a id="orgf3c150d"></a>

### 计算最好子数组的位置

算法可被修改跟踪最大子数组的开始和结束索引

因为这个算法使用最优子结构，这个算法可视为一个简单的动态规划问题


<a id="orgc39a11a"></a>

### 复杂度

Kadane 算法的时间复杂度为 O(n)，空间复杂度为 O(1)


<a id="orgce76a59"></a>

## 一般化

相似的问题可被用于高维数组，但它们的解决方案会更复杂

k 个不相交子数组最大和也可在时间复杂度 O(n+k) 内计算


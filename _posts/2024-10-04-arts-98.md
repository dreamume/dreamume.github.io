---
layout:     post
title:      "Weekly 098"
subtitle:   "Algorithm: Replace the Substring for Balanced String; Review: Access Control; Tips: ; Share: Gray Code"
thumbnail-img: ""
date:       2024-10-04 23:00
author:     "dreamume"
tags: 		[it]
category:   it
---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# Table of Contents

1.  [Algorithm](#org5a302aa)
2.  [Review](#org96d5ed5)
    1.  [模块、源文件和包](#org07ff4f6)
    2.  [访问层级](#org00b6d2a)
    3.  [访问层级的指导原则](#org2cbe279)
    4.  [缺省访问层级](#org4036a31)
        1.  [单目标 app 的访问层级](#org79cfb2b)
        2.  [库的访问层级](#orgc50b4db)
        3.  [目标单元测试的访问层级](#org6495994)
    5.  [访问控制语法](#org5860704)
    6.  [自定义类型](#org18ad466)
        1.  [元组类型](#orgd233910)
        2.  [函数类型](#org1018341)
        3.  [枚举类型](#org2fc18e0)
3.  [Tips](#org07f29ec)
4.  [Share](#org7629984)
    1.  [功能](#org89668d3)
    2.  [发明](#orgc2de1c0)
    3.  [历史和实际的应用程序](#org5148f25)
        1.  [数学谜](#org4dc34f3)
        2.  [电报代码](#org648dd34)
        3.  [模拟到数字信号转换](#org6960c6c)
        4.  [位置编码器](#org956333c)
        5.  [基因算法](#orgd0df5b9)
        6.  [布尔电路最小化](#org78cf2d3)
        7.  [错误矫正](#org7a7776a)
        8.  [时钟域间的通信](#orgbdbe3a4)
        9.  [最小影响的通过状态循环](#org54424b8)
    4.  [构建一个 n 位 Gray code](#org37906b9)
    5.  [转换成 Gray code 和从 Gray code 转换](#orgca73418)
    6.  [Gray code 的特殊类型](#org3abe39e)
        1.  [n 位 Gray code 且长度小于 $ 2<sup>n</sup> $](#orgd94850f)
        2.  [n 进制 Gray code](#org018dff4)
        3.  [平衡 Gray code](#orgd5e1c11)
        4.  [长运行 Gray code](#org08370ef)
        5.  [单调 Gray code](#orgdb76306)
        6.  [Beckett-Gray code](#org35cb358)


<a id="org5a302aa"></a>

# Algorithm

Leetcode 1234: [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string)

<https://dreamume.medium.com/leetcode-1234-replace-the-substring-for-balanced-string-9885b4a64adf>


<a id="org96d5ed5"></a>

# Review

[Access Control](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/accesscontrol/)

访问控制从代码中在其他源文件和模块中限制访问你的代码部分。这个特性使得你隐藏你代码的实现细节，且指定一个更好的接口让代码访问和使用

你可赋值特别的访问层级到私有类型（类、结构和枚举），和属于这些类型的属性、方法、初始化函数和下标。协议可限制到某个上下文，可为全局常量、变量和函数

另外提供各种访问控制层级，Swift 通过提供类型场景的默认访问层级来缩减直接指明访问控制层级的需要。事实上，如果你写单个 app，你可完全不需要指明访问控制层级


<a id="org07ff4f6"></a>

## 模块、源文件和包

Swift 的访问控制模型基于模块、源代码和包的概念

一个模块是代码分发的一个单元 - 一个 framework 或应用程序且可用 Swift 的 import 关键字在其他模块导入

在 Xcode 中每个构建目标在 Swift 被作为一个独立模块处理。如果你收集你的应用程序代码作为一个独立 framework - 也许跨多个应用程序封装和重用代码 - 则 framework 里你定义的所有将为一个独立模块的一部分当它导入并使用在一个 app 中时，或被另一个 framework 使用

一个源文件是一个模块里的一个 Swift 源代码文件。虽然通常在独自的源文件中定义独立的类型，一个源文件可包含多个类型、函数等的定义

一个包是你开发的一组模块作为一个单元。你定义模块作为你使用的配置构建系统的一部分，而不是你 Swift 源代码的一部分。例如，如果你使用 Swift 包管理器构建你的代码，你在你的 Package.swift 文件里定义一个包使用 PackageDescription 模块里的 API，且如果你使用 Xcode，你在包访问唯一标识符构建设置里指明包名称


<a id="org00b6d2a"></a>

## 访问层级

Swift 对你的代码提供六种不同的访问层级。这些访问层级对条目定义的源文件，源文件所属的模块和模块所属的包相关

-   open 访问和 public 访问使在条目定义的模块中的任意源文件和导入该定义模块其他模块源文件可以使用该条目。典型地你在指明一个公共接口到库时使用 open 或 public 访问
-   包访问使得条目用于定义它们的包里的任意源文件，其他包源文件则不允许。你典型地在 app 或结构化为多个模块的库中使用包访问
-   内部访问使条目用于定义它们的模块的任意源文件中，其他源文件则不允许。你典型地当定义一个 app 的或库的内部结构时使用内部访问
-   文件私有访问限制条目用于定义它的源文件里。使用文件私有访问隐藏一个特殊功能的细节实现，其细节用于整个文件
-   私有访问限制条目的使用在相同文件中相关定义域和定义扩展中。使用私有访问隐藏一个特殊功能的实现细节，其细节只用于单个定义中

open 访问是最高访问层级且私有访问是最低访问层级

open 访问只应用于类和类成员，且它跟公开访问不同，允许模块外的代码对其子类化和覆盖。标记一个类为 open 直接表示你考虑这个类作为父类在其他模块中的影响，且合理地设计你的类代码


<a id="org2cbe279"></a>

## 访问层级的指导原则

在 Swift 中的访问层级遵循一个总的指导原则：没有条目可用另一个更低访问层级的条目定义

例如：

-   一个 public 变量不能有一个内部、文件私有或私有类型，因为类型可能不会在公开变量的任意位置有效
-   一个函数不能有比它的参数类型和返回类型更高的访问层级，因为函数可能用于当它的组成类型对周围代码无效的情况

这个指导原则的特别间接说明对语言的其他方面的具体细节在后续章节描述


<a id="org4036a31"></a>

## 缺省访问层级

你代码的所有条目当你不直接指定访问层级时有一个内部的缺省访问层级


<a id="org79cfb2b"></a>

### 单目标 app 的访问层级

当你写一个简单的单目标 app，你的程序代码典型地被 app 自包含且不需要在 app 模块外部有效。内部的缺省访问层级已经匹配这个需求。因此，你不需要指明一个自定义的访问层级。你可，想要标记你的代码的一些部分作为文件私有或私有来对 app 模块的其他代码隐藏它们的实现细节


<a id="orgc50b4db"></a>

### 库的访问层级

当你开发一个库，标记一个开放接口作为 open 或 public 这样它可被其他模块看到和访问，这样一个 app 可导入这个库。这样这个开放接口是库的应用程序编程接口


<a id="org6495994"></a>

### 目标单元测试的访问层级

当你用一个单元测试目标写一个 app，你的 app 代码需要对该模块有效来测试。缺省，只有标记为 open 或 public 的条目可被其他模块访问。然而，一个单元测试目标可访问任意内部条目，如果你对一个产品模块用 @testable 属性标记导入定义并用测试启动属性来编译该产品模块


<a id="org5860704"></a>

## 访问控制语法

通过在条目定义的开头摆放 open、public、internal、fileprivate 或 private 修饰符来定义一个条目的访问层级

    open class SomeOpenClass {}
    public class SomePublicClass {}
    internal class SomeInternalClass {}
    fileprivate class SomeFilePrivateClass {}
    private class SomePrivateClass {}
    
    open var someOpenVariable = 0
    public var somePublicVariable = 0
    internal let someInternalConstant = 0
    fileprivate func someFilePrivateFunction() {}
    private func somePrivateFunction() {}

除非已指定，缺省的访问层级是 internal。这意味着 SomeInternalClass 和 someInternalConstant 可不用直接指定访问层级修饰符，将会有 internal 的访问层级

    class SomeInternalClass {}              // implicitly internal
    let someInternalConstant = 0            // implicitly internal


<a id="org18ad466"></a>

## 自定义类型

如果你想要对一个自定义类型指定一个访问层级，在定义它的时候指定。当新类型的访问层级允许时它就可用。例如，如果你定义一个 file-private 类，该类只能用于属性类型或函数参数或返回类型，在 file-private 类定义的文件中

一个类型的访问控制层级也影响该类成员（它的属性、方法、初始化函数和下标）的缺省访问层级。如果你定义一个类型的访问层级为 private 或 file private，它的成员的缺省访问层级将也为 private 或 file private。如果你定义一个类型的访问层级为 internal 或 public（或不直接指定一个访问层级使用 internal 的缺省访问层级），类型成员的缺省访问层级为 internal

重要：一个公开类型缺省有 internal 的成员，而不是 public 的成员。如果你想要一个类型成员为 public，你必须直接标记它为 public。这个需求确保一个类型的公开 API 是你选择发布的，且避免错误地呈现一个类型的内部工作作为公开接口

    public class SomePublicClass {                   // explicitly public class
        public var somePublicProperty = 0            // explicitly public class member
        var someInternalProperty = 0                 // implicitly internal class member
        fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member
        private func somePrivateMethod() {}          // explicitly private class member
    }
    
    class SomeInternalClass {                        // implicitly internal class
        var someInternalProperty = 0                 // implicitly internal class member
        fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member
        private func somePrivateMethod() {}          // explicitly private class member
    }
    
    fileprivate class SomeFilePrivateClass {         // explicitly file-private class
        func someFilePrivateMethod() {}              // implicitly file-private class member
        private func somePrivateMethod() {}          // explicitly private class member
    }
    
    private class SomePrivateClass {                 // explicitly private class
        func somePrivateMethod() {}                  // implicitly private class member
    }


<a id="orgd233910"></a>

### 元组类型

对一个元组类型的访问层级是使用在该元组中所有类型里最受限的访问层级。例如，如果你从两个不同类型拼装一个元组，一个为 internal 访问层级另一个为 private 访问层级，则组合的元组类型访问层级将为 private

**注意** 元组类型没有像类、结构、枚举和函数那样独立的定义。一个元组类型的访问层级自动从构成元组类型的类型中确定，且不能直接指定


<a id="org1018341"></a>

### 函数类型

一个函数类型的访问层级是函数参数和返回类型中最受限的访问层级。你必须直接指定访问层级作为函数的定义如果函数的计算访问层级不匹配缺省的上下文时

下面例子定义一个全局函数称为 someFunction()，没有对函数本身提供一个指定的访问层级修饰符。你可期望这个函数有 internal 的缺省访问层级，但并不是。事实上，someFunction() 不会通过编译

    func somefunction() -> (SomeInternalClass, SomePrivateClass) {
        // function implementation goes here
    }

函数的返回值是一个元组类型由两个自定义类组成。一个类定义为 internal，另一个定义为 private。因此，复合元组类型总的访问层级是 private

因为函数的返回类型是 private，你必须标注函数的总访问层级为 private 到函数定义才有效

    private func someFunction() -> (SomeInternalClass, SomePrivateClass) {
        // function implementation goes here
    }

用 public 或 internal 修饰符标注 someFunction() 的定义是无效的，因为 函数的 public 或 internal 用户不能合适地访问函数返回类型中的 private 类


<a id="org2fc18e0"></a>

### 枚举类型

一个枚举的独立值自动接受它们所属的枚举的相同的访问层级。你不能对一个独立枚举值指定一个不同的访问层级

在下面例子中，CompassPoint 枚举有一个直接的访问层级 public。枚举值 north、south、east 和 west 因此也有访问层级 public

    public enum CompassPoint {
        case north
        case south
        case east
        case west
    }


<a id="org07f29ec"></a>

# Tips


<a id="org7629984"></a>

# Share

[Gray Code](https://en.wikipedia.org/wiki/Gray_code)

反射二进制代码（RBC），也称为反射二进制（RB）或 在 Frank Gray 之后叫 Gray Code，是一个二进制数字系统的顺序使得两个相邻的值只有一个位不同

例如，十进制值 1 在二进制可以表示为 001 和 2 表示为 010。在 Gray code 中，这些值表示为 001 和 011。即，从 1 到 2 增加一个值只改变一个位，而不是 2 个

Gray code 广泛应用于从电子交换机中防止伪造的输出和在电子通信中加快错误矫正比如数字地面电视和一些电缆电视系统。在这些设备中 Gray code 的使用帮助简化逻辑操作和减少实际中的错误


<a id="org89668d3"></a>

## 功能

许多设备通过关闭和打开开关来显示位置。如果该设备使用自然二进制代码，3 和 4 的位置互相靠近但二进制表示的三个位数都不同

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">十进制</th>
<th scope="col" class="org-left">二进制</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
</tr>


<tr>
<td class="org-left">3</td>
<td class="org-left">011</td>
</tr>


<tr>
<td class="org-left">4</td>
<td class="org-left">100</td>
</tr>


<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>

自然二进制代码的问题是物理开关不是理想的：它不太像物理开关精确同步地改变状态。上面显示的两个状态间所有三个开关改变了状态。当所有正在改变的短暂期间，开关将读取一些虚假的位置。甚至没有键反弹，短暂期可能会是 011 - 001 - 101 - 100。当开关出现在位置 001 时，观察者不能说如果有真正的位置 1，或在两个其他位置之间的一个暂时状态。如果输出反馈给一个序列系统，可能通过组合逻辑，则序列系统可能存储一个错误值

这个问题可通过一次只改变一个开关解决，这样没有任何歧义的位置，代码为一个连续集合整数，或对每个环形列表成员，一个字符信号使得没有两个代码为确定的，且每两个相邻的代码只有一个信号不同。这些代码也称为单位距离，单距离，单步，monostrophic 或 syncopic 代码，相邻代码间的 Hamming 距离为 1


<a id="orgc2de1c0"></a>

## 发明

原理上，对于给定字节长度有多种这样的代码，但 Gray code 是第一个应用到非负整数上的一个特殊的二进制代码，二进制反射 Gray code，或 BRGC。贝尔实验室研究员 George R.Stibitz 在 1941 年用一个专利保护的应用程序描述这样的一个代码，在 1943 年获得允许。Frank Gray 在他的 1947 年专利保护的应用程序中引入反射二进制代码的名称，标记该代码“还没有识别的名字“。他从事实中获得“可能通过一些反射系统从方便的二进制代码构建“

在 Gray code 的标准编码中，最低有效位有 2 个开 2 个关的重复范型；下一个位数是 4 个开 4 个关的范型；第 i 位是 $ 2^{i} $ 开 $ 2^{i} $ 关，其他位也是这样。四个位的版本显示如下：

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">十进制</th>
<th scope="col" class="org-right">二进制</th>
<th scope="col" class="org-right">Gray</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0000</td>
<td class="org-right">0000</td>
</tr>


<tr>
<td class="org-right">1</td>
<td class="org-right">0001</td>
<td class="org-right">0001</td>
</tr>


<tr>
<td class="org-right">2</td>
<td class="org-right">0010</td>
<td class="org-right">0011</td>
</tr>


<tr>
<td class="org-right">3</td>
<td class="org-right">0011</td>
<td class="org-right">0010</td>
</tr>


<tr>
<td class="org-right">4</td>
<td class="org-right">0100</td>
<td class="org-right">0110</td>
</tr>


<tr>
<td class="org-right">5</td>
<td class="org-right">0101</td>
<td class="org-right">0111</td>
</tr>


<tr>
<td class="org-right">6</td>
<td class="org-right">0110</td>
<td class="org-right">0101</td>
</tr>


<tr>
<td class="org-right">7</td>
<td class="org-right">0111</td>
<td class="org-right">0100</td>
</tr>


<tr>
<td class="org-right">8</td>
<td class="org-right">1000</td>
<td class="org-right">1100</td>
</tr>


<tr>
<td class="org-right">9</td>
<td class="org-right">1001</td>
<td class="org-right">1101</td>
</tr>


<tr>
<td class="org-right">10</td>
<td class="org-right">1010</td>
<td class="org-right">1111</td>
</tr>


<tr>
<td class="org-right">11</td>
<td class="org-right">1011</td>
<td class="org-right">1110</td>
</tr>


<tr>
<td class="org-right">12</td>
<td class="org-right">1100</td>
<td class="org-right">1010</td>
</tr>


<tr>
<td class="org-right">13</td>
<td class="org-right">1101</td>
<td class="org-right">1011</td>
</tr>


<tr>
<td class="org-right">14</td>
<td class="org-right">1110</td>
<td class="org-right">1001</td>
</tr>


<tr>
<td class="org-right">15</td>
<td class="org-right">1111</td>
<td class="org-right">1000</td>
</tr>
</tbody>
</table>

对十进制 15 代码滚动到 0 只需要改变一个开关。这被称为循环或邻接属性的代码

在现代数字通信中，Gray code 在错误矫正中扮演重要的角色。例如，在数字调制方案比如 QAM 其数据典型地转换 4 位或更多符号，信号的星座表排列为位范型被相邻的星座点只一位不同来转换。通过比较前向错误矫正能矫正单位错误，它可能让接收者矫正任意由一个星座点到邻接点区域的转换错误。这使得转换系统很少会被噪音污染

尽管是 Stibitz 在 Gray 之前描述了这个代码，反射二进制代码之后被其他人命名为 Gray。两个不同的 1953 年专利保护的应用程序使用 Gray code 作为反射二进制代码的替代名；其中之一也列出“最小错误码“ 和”循环排列代码“。一个 1954 年专利保护的应用程序用了“Bell 电话 Gray code“。其他的名字包括“循环二进制代码“，”循环进度代码“，“循环排列二进制“或“循环排列的二进制“

Gray code 有时候错误认为是 19 世纪电子设备发明人 Elisha Gray


<a id="org5148f25"></a>

## 历史和实际的应用程序


<a id="org4dc34f3"></a>

### 数学谜

反射二进制代码在变得对工程师熟知之前应用到数学谜

二进制反射 Gray code 可表示为经典的中国环谜的底层解决方案，French Louis Gros 1872 年描述的一个序列机械谜机制

它可作为解决方案指导汉诺塔问题，基于 French Edouard Lucas 1883 年的一个游戏。相似的，Bucharest 和 Klagenfurt 塔游戏配置为三进制和八进制 Gray code

Martin Gardner 在科学美国人他的 1972 年八月数学游戏栏目中写了一个流行的 Gray code 的报道

代码也形成在超立方体上的一个汉密尔顿循环，其每个位视为一个维度


<a id="org648dd34"></a>

### 电报代码

在 1975 年或 1876 年，当法国工程师 Emile Baudot 对他的打印电报系统从使用 6 位代码改为使用 5 位代码，他在他的打印机轮上使用一个反射二进制代码排序字母，且对元音只使用 3 位代码。元音和辅音以字母序排序，且其他符号适合地排位，5 位字符码被识别为一个反射二进制代码。这个代码变成熟知的 Baudot 代码，且用一个小的改变，最终在 1932 年作为国际电报第一号（ITA1, CCITT-1）采用

同时，1874 年德国奥地利人 Otto Schaffler 展示了在维也纳使用的另一种用 5 位反射二进制代码作为相同目的的打印电报


<a id="org6960c6c"></a>

### 模拟到数字信号转换

Frank Gray 因发明信号方法用来兼容彩色电视而闻名，他使用基于真空管道的一套设备发明了一种转换模拟信号到反射二进制代码组的方法。在 1947 年形成文件，该方法和设备在 1953 年获得专利权，且 Gray 的名字联系到了该代码。Gray 享有专利权的“PCM 管道“设备被贝尔实验室的 Raymond W. Sears 制作了出来。他跟 Gray 和 William M.Goodall 一起工作，他相信 Gray 在反射二进制代码上的想法

Gray 在转换模拟信号到数字信号上使用代码最小化错误上最感兴趣；他的代码在今天依然在用于这个目的


<a id="org956333c"></a>

### 位置编码器

Gray code 相对于权重二进制编码更适合于线性和旋转位置编码器（绝对编码器和相位编码器）。这避免了当一个位置在二进制表达中多个位改变时会导致变化过程中的误读

例如，一些旋转编码器提供一个磁盘其在同心环上有电子传导 Gray code 范型。每个 track 有一个停滞的金属簧接触器提供到传导代码范型的电子接触。这些接触器一起以 Gray code 的形式产生输出信号。其他的编码器基于光纤或电磁传感器使用非接触机制产生 Gray code 输出信号

不管一个移动的编码器的机制或精度，位置测量错误可能在一些特殊位置上发生（代码边界）因为代码在它读取的特别时刻可能会改变。一个二进制输出代码可能因为在相同时刻不能使所有位改变而引起严重的位置测量错误。如果，在位置采样的时刻，一些位已改变而另一些没有，采样的位置将是不正确的。在绝对编码器中，显示位置可能远离实际的位置，且在递增编码器中，这会导致位置跟踪崩溃

相反地，位置编码器使用的 Gray code 确保任意两个连续位置的代码只有一位不同，即一个时刻只能改变一位。这样，最大位置错误将很小，显示一个位置邻接实际的位置


<a id="orgd0df5b9"></a>

### 基因算法

由于 Gray code 的 Hamming 距离属性，它们有时使用在基因算法中。在这个领域它们非常有用，因为代码的修改允许多数时递增改变，但偶尔单个位改变可引起一个大的倾斜并导致一个新的属性


<a id="org78cf2d3"></a>

### 布尔电路最小化

Gray code 也用于从 1953 年开始的标签 Karnaugh 地图裁剪和 1958 年开始的 Handler 环图，这两个都是逻辑电路最小化的图像方法


<a id="org7a7776a"></a>

### 错误矫正

在现代数字通信中，在应用一个错误错误矫正之前 1 维和 2 维 Gray code 在错误防止方面扮演一个重要的角色。例如，在数字调制方案比如 QAM 中数据典型地以 4 位或更多来传输，信号的星座图被排列这样位范型被邻接星座点只以一位之差覆盖。通过与能够矫正一位错误的前向错误矫正比较，对一个接收器它能够矫正导致一个星座点偏离到邻接点区域的任意传输错误。这使得传输系统不容易被噪音干扰


<a id="orgbdbe3a4"></a>

### 时钟域间的通信

数字逻辑设计师使用 Gray code 扩展通过多位统计信息同步不同时钟频率间的逻辑操作。逻辑考虑在不同时钟域上操作。它是许多不同时钟频率上操作设计大型芯片的基础


<a id="org54424b8"></a>

### 最小影响的通过状态循环

如果一个系统需要通过所有可能开关状态的一些控制组合来顺序循环，且控制的改变需要很小的花费（例如，时间、线、人工操作），一个 Gray code 最小化设置改变数来对每个状态组合只改变一个。一个例子为测试一个管道系统所有它的手工操作阀设置的组合

一个平衡 Gray code 可被构造，翻转每位相等的次数。因为位翻转分布均匀，这用下面方法优化：平衡 Gray code 最小化每个位位翻转的最大统计数

1.  Gray code 统计和算术

    George R. Stibitz 在 1941 年已经在一个二进制脉冲统计设备里利用一个反射二进制代码
    
    一个典型 Gray code 统计的使用是构建一个 FIFO 数据缓冲读写存在不同时钟域的端口。在这样一个双端口 FIFO 里的输入输出统计使用 Gray code 防止捕获的跨时钟域无效临时状态。当改变时更新的读写指针需要在时钟域间传递，为能跟踪每个域 FIFO 的空和满状态。指针的每个位在这个时钟域传输中是非确定性采样。这样对每个位，要么旧值要么新值被广播。因此，如果在多位指针中多个位在采样点改变，一个错误的二进制值会被广播。通过确保只改变一个位，Gray code 保证只有可能采样值为新值或旧值。典型的用 2 的指数长度的 Gray code
    
    有时电子系统中的数字总线用来传递一个时刻只增长或减少一个的数量，例如时钟域或一个数字模拟转换器中传递的一个事件统计输出。在这些应用程序中 Gray code 的优点是许多线广播延迟的不同呈现的代码位不能导致接收值通过超出 Gray code 顺序的状态。这个跟机械编码器构建的 Gray code 的优势相似，然而 Gray code 的源在这个例子中是一个电子统计器。统计器本身必须在 Gray code 中统计，否则如果统计器以二进制运行则统计器的输出值必须重新时钟化在它被转换为 Gray code 之后，因为当一个值从二进制转换成 Gray code，它可能在二进制数据位成为二进制到 Gray 转换电路的到达时刻不同即代码会短暂出现无序的状态。在电路转换统计值到 Gray code 之后增加一个时钟注册器可能引入一个时钟循环延迟，这样在 Gray code 中直接统计会更有利
    
    为产生 Gray code 统计器中的下一个统计值，它需要有一些组合逻辑增加存储的当前统计值。一个方法是增加一个 Gray code 号转换它为普通二进制代码，对一个标准二进制增加器加一，且然后转换结果为 Gray code。Gray code 统计的其他方法在 Robert W. Doran 的报告中讨论，包括在一个二进制波动统计器中从第一个主从翻转门阀中获取输出

2.  Gray code 地址

    当编程代码执行时典型地导致一个本地连续地址的指令内存访问范型，使用 Gray code 地址而不是二进制地址的总线编码可减少地址位状态改变的数量，因此在一些低电力设计中减少 CPU 能量消耗


<a id="org37906b9"></a>

## 构建一个 n 位 Gray code

n 位二进制反射 Gray code 可通过反射列表（例如，以倒序列出条目）从 n - 1 位列表中递归产生，用一个二进制 0 前置在源列表之前，用二进制 1 前置在反射列表条目之前，然后用倒序串联源列表，例如，从 n = 2 列表中产生 n = 3 列表：

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">2 位列表</td>
<td class="org-left">00, 01, 11, 10</td>
</tr>


<tr>
<td class="org-left">反射</td>
<td class="org-left">10, 11, 01, 00</td>
</tr>


<tr>
<td class="org-left">用 0 前置旧条目</td>
<td class="org-left">000, 001, 011, 010</td>
</tr>


<tr>
<td class="org-left">用 0 前置新条目</td>
<td class="org-left">110, 111, 101, 100</td>
</tr>


<tr>
<td class="org-left">串联</td>
<td class="org-left">000, 001 011, 010, 110, 111, 101, 100</td>
</tr>
</tbody>
</table>

1 位 Gray code 是 $ G_ {1} = (0, 1) $。这可认为从一个 0 位 Gray code 包含一个 0 长度单条目 $ G_ {0} = ( \\land ) $ 递归构建出来。这个从 $ G_ {n} $ 产生 $ G_ {n+1} $ 的迭代过程使得标准反射代码的如下属性更清晰：

-   $ G_ {n} $ 是数 $ 0, \\ldots, 2^{n} - 1 $ 的一个排列（每个数在列表中只出现一次）
-   $ G_ {n} $ 内嵌在 $ G_ {n+1} $ 的前半段
-   因此，编码是稳定的，一旦一个二进制数出现在 $ G_ {n} $ 中它出现在所有更长列表的相同位置；这样谈论可反射 Gray code 值 G(m) = 第 m 个反射 Gray code，从 0 开始计数
-   $ G_ {n} $ 中每个条目跟之前的条目只有一位不同（Hamming 距离为 1）
-   $ G_ {n} $ 中最后的条目跟第一个条目只有一位不同（代码可循环）

这些特性建议一个简单和快速的方法转换二进制值到对应的 Gray code。如果输入值的下一个更高位设置为 1 则每位被倒置。如果有效这可通过位移和异或操作平行处理：第 n 位 Gray code 通过计算 $ n \\oplus \\lfloor \\frac{n}{2} \\rfloor $ 来获得。前置一个 0 位代码顺序不变，前置一个 1 位反转代码顺序。如果在 i 位被倒置，邻居第 $ 2^{i} $ 块的顺序是反转的。例如，如果在 3 位代码序中 0 位被倒置，两个邻接代码序被反转

$ 000, 001, 010, 011, 100, 101, 110, 111 \\to 001,000,011,010,101,100,111,110 $ （倒置 0 位）

如果第 1 位倒置，2 个代码块改变顺序：

$ 000,001,010,011,100,101,110,111 \\to 010,011,000,001,110,111,100,101 $ （倒置第 1 位）

如果第 2 位倒置，4 个代码块反转顺序：

$ 000,001,010,011,100,101,110,111 \\to 100,101,110,111,000,001,010,011 $ （倒置第 2 位）

这样，在位置 i 对位 $ b_ {i} $ 执行一个异或及在位置 i + 1 如果 $ b_ {i+1} = 0 $ 则对顺序不动，如果 $ b_ {i+1} = 1 $ 则反转 $ 2^{i+1} $ 代码块顺序。现在，这跟反射并前置方法产生 Gray code 的操作完全一致

一个相似的方法可用来反转转换，但每位的计算依赖下一个高位的计算值这样它不能并行执行。假设 $ g_ {i} $ 是第 i 个 Gray code 位（$ g_ {0} $ 是最低位），且 $ b_ {i} $ 是第 i 个二进制代码位（$ b_ {0} $ 是最低位），反转转换可递归给出：$ b_ {0} = g_ {0} $ 且 $ b_ {i} = g_ {i} \\oplus b_ {i-1} $。另外，解码一个 Gray code 为一个二进制数可描述为在 Gray code 里位的一个前置和，在前置和中每个单独的累加操作用 2 取模

为迭代构建二进制反射 Gray code，在第 0 步用 $ code_ {0} = 0 $ 开始，且在第 i > 0 步找到 i 的二进制表示中最小位为 1 的位置且在之前的 $ code_ {i-1} $ 代码中在该位置翻转位来产生下一个代码 $ code_ {i} $


<a id="orgca73418"></a>

## 转换成 Gray code 和从 Gray code 转换

下面 C 函数从二进制代数和它们相关的 Gray code 之间进行转换。然而似乎有一次需要一位被处理的 Gray 到二进制的更快版本算法存在

    typedef unsigned int uint;
    
    /* This function converts an unsigned binary number to reflected binary Gray code. */
    uint BinaryToGray(uint num) {
      return num ^ (num >> 1);
    }
    
    /* This function converts a reflected binary Gray code number to a binary number */
    uint GrayToBinary(uint num) {
      uint mask = num;
      while (mask) {
        mask >>= 1;                 /* Each Gray code bit is exclusive-ored while all more significant bits */
        num ^= mask;
      }
    
      return num;
    }
    
    /* A more efficient version for Gray codes 32 bits or fewer through the use of SWAR
      (SIMD within a register) techniques.
      It implements a parallel prefix XOR function. The assignment statements can be in any order.
      This function can be adapted for longer Gray codes by adding steps */
    uint GrayToBinary32(uint num) {
      num ^= num >> 16;
      num ^= num >> 8;
      num ^= num >> 4;
      num ^= num >> 2;
      num ^= num >> 1;
    
      return num;
    }
    
    /* A Four-bit-at-once variant changes a binary number (abcd)2 to (abcd)2 ^ (00ab)2,
       then to (abcd)2 ^ (00ab)2 ^ (0abc)2 ^ (000a)2.*/

在更新的处理器上，在解码步骤里 ALU 指令数可通过 CLMUL 指令集缩减。如果 MASK 是以一个单零数字结尾的字符为 1 的常量二进制字符串，则带灰编码的 x 用 MASK 非进位乘法将总是得到 x 或它的位对立值


<a id="org3abe39e"></a>

## Gray code 的特殊类型

在实际中，"Gray code" 总是指二进制反射 Gray code(BRGC)。然而，数学家发现了其他类型的 Gray code。像 BRGC，每个包含字节的列表，每个字节跟下一个只相差一个位（Hamming 距离为 1）


<a id="orgd94850f"></a>

### n 位 Gray code 且长度小于 $ 2^{n} $

构建 n 位二进制 Gray code 且长度小于 $ 2^{n} $，如果长度为偶数。一个可能性是用一个平衡 Gray code 开始且移除开始和结尾的值对，或在中间的。OEIS sequence A290772 给出长度为 2n 包括 0 和使用最小位数的可能的 Gray 序列


<a id="org018dff4"></a>

### n 进制 Gray code

有许多不同于二进制反射 Gray code 的特殊类型 Gray code。其中之一为 n 进制 Gray code，也被称为非布尔 Gray code。如名称所示，这种类型 Gray code 在编码中使用非布尔值

例如，一个 3 进制 Gray code 使用值 0，1，2。(n, k) Gray code 是 k 位 n 进制 Gray code。(3，2) Gray code 元素序列为：00,01,02,12,11,10,20,21,22。(n,k) Gray code 可递归构建，跟 BRGC 相似，或可迭代构建。一个迭代产生 (N, k) Gray code 的算法如下：

    /* inputs: base, digits, value
       output: Gray
       Convert a value to a Gray code with the given base and digits.
       Iterating through a sequence of values would result in a sequence
       of Gray code in which only one digit changes at a time */
    void toGray(unsigned base, unsigned digits, unsigned value, unsigned gray[digits]) {
      unsigned baseN[digits];       /* store the ordinary base-N number, one digit per entry */
      unsigned i;                   /* The loop variable */
    
      /* Put the normal baseN number into the baseN array. For base 10, 109 would
         be stored as [9, 0, 1] */
      for (i = 0; i < digits; ++i) {
        baseN[i] = value % base;
        value = value / base;
      }
    
      /* Convert the normal baseN number into the Gray code equivalent.
         Note that
         the loop starts at the most significant digit and goes down */
      unsigned shift = 0;
      while (i--) {
        /* The Gray digit gets shifted down by the sum of the higher digits */
        gray[i] = (baseN[i] + shift) % base;
        shift = shift + base - gray[i]; /* Subtrace from base so shift is possible */
      }
    }
    
    // EXAMPLES
    // input: value = 1899, base = 10, digits = 4
    // output: baseN[] = [9,9,8,1], gray[] = [0,1,7,1]
    // input: value = 1900, base = 10, digits = 4
    // output: baseN[] = [0,0,9,1], gray[] = [0,1,8,1]

有一些其他的 (n, k) Gray code 的算法。从上述算法中产生的 (n, k) Gray code 也是循环的；一些算法，比如 Guan 的算法，当 k 为奇数时缺少这个属性。另一方面，这个方法一个时刻只改变一位数字，它可改变封装的值（从 n - 1 到 0 的循环）。在 Guan 的算法中，统计交替上升下降，这样两个 Gray code 之间的数字只有一位不同

Gray code 没有唯一的定义，因为这样的代码的一个列排列也是 Gray code。上述过程产生一个代码其降低低位数字，改变地越多，其更像一个正常的统计方法

看看 Skew 二进制数字系统，一个变种三进制数字系统其每次增加最多改变两个数字，每次增加可最多一个数字进位操作完成


<a id="orgd5e1c11"></a>

### 平衡 Gray code

虽然二进制反射 Gray code 在很多场景下很有用，但在某些场景下不是最优的因为缺少“均匀”。在平衡 Cray code 中，不同坐标位置数值的改变尽可能接近。为使这更精确，设 G 为一个 R 进制完全 Gray 循环有转换序列 $ (\\delta_ {k}) $；G 的转换统计（光谱）为整数的收集定义为

$ \\lambda_ {k} = \| \{ j \\in \\mathbb{Z}_ {R^{n}} : \\delta_ {j} = k \} \|, \\text{for} \\quad k \\in \\mathbb{Z}_ {n} $

一个 Gray code 是均匀或均匀平衡的如果它的转换统计也是所有相等的，$ \\forall k, \\lambda_ {k} = \\frac{R^{n}}{n} $。明显的，当 R = 2 时，只有 n 是 2 的指数倍时这样的代码才存在。否则，它可能可构建一个似平衡二进制代码，其两个转换统计之间最多只有 2 处不同；这样（组合两种情况）每个转换要么 $ 2 \\lfloor \\frac{2^{n}}{2n} \\rfloor $ 或 $ 2 \\lceil \\frac{2^{n}}{2n} \\rceil $。Gray code 也称为幂平衡如果所有它的转换统计相邻 2 的指数个，且这样的代码对每个 2 的指数都存在

例如，一个平衡 4 位 Gray code 有 16 个转换，可被均匀分布在所有四个位置（每个位置四个转换），使得它均匀平衡：

$ \\begin{array}{llllllllllllllll} 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & \\color{red}{0} \\\\ 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & \\color{red}{0} & 0 & \\color{red}{1} & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & \\color{red}{1} & 1 & 1 & \\color{red}{0} & 0 \\\\ \\color{red}{0} & 0 & 0 & \\color{red}{1} & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 \\end{array} $

一个 5 位平衡 Gray code 有总共 32 个转换，其不能均匀分布在位置上。在这个例子中，4 个位置每个有 6 个转换，且有一个位置有 8 个：

$ \\begin{array}{llllllllllllllllllllllllllllllll} \\color{red}{1} & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & \\color{red}{1} & 1 & \\color{red}{0} & 0 & 0 \\\\ 1 & 1 & \\color{red}{0} & 0 & \\color{red}{1} & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & \\color{red}{0} & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 \\\\ 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & \\color{red}{1} \\\\ 1 & 1 & 1 & 1 & 1 & 1 & \\color{red}{0} & 0 & 0 & 0 & \\color{red}{1} & 1 & \\color{red}{0} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\color{red}{1} & 1 & \\color{red}{0} & 0 & 0 & \\color{red}{1} & 1 & 1 & 1 & 1 & 1 \\end{array} $

我们将展示一个似平衡二进制 Gray code 的构建和实现，其允许我们对每个 n 产生一个 n 位平衡 Gray code。主要原理是归纳构建一个 (n + 2) 位 Gray code $ G^{\\prime} $ 给定一个 n 位 Gray code G 使得平衡属性被保留。为此，我们考虑分区 $ G = g_ {0}, \\ldots, g_ {2^{n} - 1} $ 为偶数 L 个非空块，形如：

$ \{ g_ {0} \}, \{g_ {1}, \\ldots, g_ {k_ {2}} \}, \{g_ {k_ {2} + 1}, \\ldots, g_ {k_ {3}} \}, \\ldots, \{ g_ {k_ {L-2}+1}, \\ldots, g_ {-2} \}, \{ g_ {-1} \} $

$ k_ {1} = 0, k_ {L-1} = -2, k_ {L} \\equiv -1 \\quad (mod \\quad 2^{n}) $。这个分区引入一个 (n+2) 位 Gray code:

$ 00g_ { 0 }, $

$ 00g_ {1}, \\ldots, 00g_ {k_ {2}}, 01g_ {k_ {2}}, \\ldots, 01g_ {1}, 11g_ {1}, \\ldots, 11g_ {k_ {2}}, $

$ 11g_ {k_ {2} + 1}, \\ldots, 11g_ {k_ {3}}, 01g_ {k_ {3}}, \\ldots, 01g_ {k_ {2} + 1}, 00g_ {k_ {2} +1}, \\ldots, 00g_ {k_ {3}}, \\ldots, $

$ 00g_ {-2}, 00g_ {-1}, 10g_{-1}, 10g_ {-2}, \\ldots, 10g_ {0}, 11g_ {0}, 11g_ {-1}, 01g_ {-1}, 01g_ {0} $

如果我们定义转换重数

$ m_ {i} = \| \{ j: \\delta_ {k_ {j}} = i, 1 \\le j \\le L \} \| $

为在一个分区中连续块之间在数位 i 改变的次数，对 (n+2) 位 Gray code 通过这个分区谱 $ \\lambda^{\\prime}_ {i} $ 导入为

$ \\lambda^{\\prime}_ {i} = \\left\\{ \\begin{array}{lc}4 \\lambda_ {i}-2 m_ {i}, & \\text { if } 0 \\leq i < n \\\\ L, & \\text { otherwise } \\end{array} \\right. $

这个构建的修饰部分为了找到一个 n 位 Gray code 的一个普适分区使得通过它引入的代码仍然是平衡的，但这只对转换重数有关；在一个位 i 转换连接两个相邻的块和在另一个 i 位上分隔块产生一个相同转换谱 $ \\lambda^{\\prime}_ {i} $ 上的不同的 Gray code，这样可以例如在位数 i 上指定第一个 $ m_ {i} $转换。均匀代码在 $ R \\equiv 0 \\quad (mod \\, 4) $ 和 $ R^{n} \\equiv 0 \\quad (mod \\, n) $ 上找到，且这个构建可扩展到 R 进制


<a id="org08370ef"></a>

### 长运行 Gray code

长运行（最大间隔）Gray code 最大化相同位置上连续改变数位的距离。即任何位的最小运行长度尽可能不改变


<a id="orgdb76306"></a>

### 单调 Gray code

单调代码在互相连接网络上理论上很有用，特别对处理器的线性数列。如果我们定义一个二进制字符串的重量为字符串里 1 的个数，则虽然我们清楚 Gray code 不可能有严格的增长体重，我们可通过让代码运行在达到下一个之前估计两个相邻的重量

我们可形式化单调 Gray code 的概念如下：考虑超立方体的分区 $ Q_ {n} = (V_ {n}, E_ {n}) $ 为有相同重量的定点层级，例如

$ V_ {n}(i) = \{ \\nu \\in V_ {n} : \\nu \\quad \\text{ has weight i } \}, 0 \\le i \\le n $

这些层满足 $ \| V_ {n}(i) \| = \\binom{n}{i} $。设 $ Q_ {n}(i) $ 为 $ Q_ {n} $ 引入 $ V_ {n}(i) \\cup V_ {n}(i+1) $ 的子图，且设 $ E_ {n}(i) $ 为 $ Q_ {n}(i) $ 中的边。一个单调 Gray code 是 $ Q_ {n} $ 中一个哈密尔顿路径使得当 $ \\delta_ {1} \\in E_ {n}(i) $ 在 $ \\delta_ {2} \\in E_ {n}(j) $ 之前，则 $ i \\le j $

一个对任意 n 的单调 n 位 Gray code 的伟大构建基于递归构建 $ 2 \\binom{n}{j} $ 长度子路径 $ P_ {n, j} $ 其在 $ E_ {n}(j) $ 中有边。我们定义 $ P_ {1,0} = (0, 1), P_ {n,j} = \\emptyset, j < 0 or j \\ge n $ 且

$ P_ {n_1, j} = 1 P^{\\pi_ {n}}_ {n,j-1}, 0P_ {n, j} $

这里，$ \\pi_ {n} $ 是一个适合的被定义排列且 $ P^{\\pi} $ 指路径 P 其坐标被 $ \\pi $ 重新排列。这些路径导致两个单调 n 位 Gray code $ G^{(1)}_ {n}, G^{(2)}_ {n} $：

$ G^{(1)}_ {n} = P_ {n,0}P^{R}_ {n,1}P_ {n,2}P^{R}_ {n,3} \\cdots, G^{(2)}_ {n} = P^{R}_ {n,0}P_ {n,1}P^{R}_ {n,2}P_ {n,3} \\cdots $

$ \\pi_ {n} $ 的选择确保这些代码为 Gray code 证明 $ \\pi_ {n} = E^{-1}(\\pi^{2}_ {n-1}) $。$ P_ {n, j} 的前几个显示在下表中

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">j = 0</th>
<th scope="col" class="org-left">j = 1</th>
<th scope="col" class="org-left">j = 2</th>
<th scope="col" class="org-left">j = 3</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">n = 1</td>
<td class="org-left">0, 1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>


<tr>
<td class="org-left">n = 2</td>
<td class="org-left">00, 01</td>
<td class="org-left">10, 11</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>


<tr>
<td class="org-left">n = 3</td>
<td class="org-left">000, 001</td>
<td class="org-left">100, 110, 010, 011</td>
<td class="org-left">101, 111</td>
<td class="org-left">&#xa0;</td>
</tr>


<tr>
<td class="org-left">n = 4</td>
<td class="org-left">0000, 0001</td>
<td class="org-left">1000, 1100, 0100, 0110, 0010, 0011</td>
<td class="org-left">1010, 1011, 1001, 1101, 0101, 0111</td>
<td class="org-left">1110, 1111</td>
</tr>
</tbody>
</table>

这些单调 Gray code 这样可高效实现，每个子序列元素可在 O(n) 时间复杂度下生成

单调代码有一个有趣的连接到 Lovász conjecture，其表述每个连接的定点转换图包含一个哈密尔顿路径。“中级水平”子图 $ Q_ {2n+1}(n) $ 是向量转换（即，它的自同构组是可转换的，这样每个定点有相同的“本地环境”且不能跟其他不同，因为我们可重标签坐标这样二进制数字来获得一个自同构）且在这个子图中找到一个哈密尔顿路径的问题被称为“中等层级问题“，其可提供到更一般化猜想的洞察。问对 $ n \\le 15 $ 的情况题已获得肯定答复，且单调代码的后续构建确保一个至少 0.839N 长度的哈密尔顿路径，N 是中级层级子图中顶点数


<a id="org35cb358"></a>

### Beckett-Gray code

另一种类型 Gray code，Beckett-Gray code，以爱尔兰剧作家 Samuel Beckett 命名，其在对称性上有很大的兴趣。他的剧“Quad“描写了四位演员并分割为六个时期。每个时期以一个演员进入或离开舞台结束。剧开始结束时是一个空的舞台，且 Beckette 想要演员的每个子集只出现在舞台一次。明显地当前舞台上演员的集合可呈现为 4 位二进制 Gray code。Beckette，然而，在脚本上加了另外一个限制：他希望演员进入或退出使得舞台上所在最长的演员总是存在。演员可呈现为一个先进先出队列，这样（舞台上的演员）被退出的演员总是最先入队列的。Beckette 不能找到适合他的剧的一个 Beckette Gray code，且实际上，一个完全列表所有可能的序列表明对 n = 4 没有这样的代码存在。现在知道这样的代码对 n = 2, 5, 6, 7 和 8 存在，对 n = 3 或 4 不存在。一个 8 位 Beckette-Gray code 的例子可在 Donald Knuth 的计算机编程艺术里发现。根据 Sawada 和 Wong，对 n = 6 的研究空间可被探索在 15 小时以内，且对 n = 7 的情况已发现超过 9500 种解决方案

